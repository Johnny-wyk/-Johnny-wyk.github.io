


[{"content":"","date":"2024-09-28","externalUrl":null,"permalink":"/all/","section":"Alls","summary":"","title":"Alls","type":"all"},{"content":"\r基于pandas的数据清洗 #\r处理丢失数据 #\r有两种丢失数据：\nNone\nnp.nan(NaN)\ntype(None) NoneType type(np.nan) float 为什么在数据分析中需要用到的是浮点类型的空而不是对象类型？\n数据分析中会常常使用某些形式的运算来处理原始数据，如果原数数据中的空值为NAN的形式，则不会干扰或者中断运算。 NAN可以参与运算的\nNone是不可以参与运算\n在pandas中如果遇到了None形式的空值则pandas会将其强转成NAN的形式。\npandas处理空值操作 #\risnull\nnotnull\nany\nall\ndropna\nfillna\n方式1：对空值进行过滤（删除空所在的行数据） #\r技术：isnull，notnull，any，all\ndf.isnull() #哪些行中有空值 #any(axis=1)检测哪些行中存有空值 df.isnull().any(axis=1) #any会作用isnull返回结果的每一行 #true对应的行就是存有缺失数据的行 df.notnull() df.notnull().all(axis=1) #将布尔值作为源数据的行索引 df.loc[df.notnull().all(axis=1)] #获取空对应的行数据 df.loc[df.isnull().any(axis=1)] #获取空对应行数据的行索引 indexs = df.loc[df.isnull().any(axis=1)].index indexs df.drop(labels=indexs,axis=0)#将缺失值行直接删除 方式2：dropna，fillna #\rdropna：可以直接将缺失的行或者列进行删除\n对缺失值进行覆盖 fillna\ndf.dropna(axis=0) df.fillna(value=999) #使用指定值将源数据中所有的空值进行填充 #使用空的近邻值进行填充 #method=ffill向前填充，bfill向后填充 df.fillna(axis=0,method=\u0026#39;bfill\u0026#39;) 什么时候用dropna什么时候用fillna\n尽量使用dropna，如果删除成本比较高，则使用fillna\n使用空值对应列的均值进行空值填充\nfor col in df.columns: #检测哪些列中存有空值 if df[col].isnull().sum() \u0026gt; 0:#说明df[col]中存有空值 mean_value = df[col].mean() df[col] = df[col].fillna(value=mean_value) 处理重复数据 #\r#检测哪些行存有重复的数据 df.duplicated(keep=\u0026#39;first\u0026#39;) df.loc[~df.duplicated(keep=\u0026#39;first\u0026#39;)] #异步到位删除 df.drop_duplicates(keep=\u0026#39;first\u0026#39;) 级联操作 #\rpd.concat, pd.append\npandas使用pd.concat函数\ndf1 = pd.DataFrame(data=np.random.randint(0,100,size=(5,3)),columns=[\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;]) df2 = pd.DataFrame(data=np.random.randint(0,100,size=(5,3)),columns=[\u0026#39;A\u0026#39;,\u0026#39;D\u0026#39;,\u0026#39;C\u0026#39;]) pd.concat((df1,df1),axis=1) #行列索引都一致的级联叫做匹配级联 不匹配级联\n不匹配指的是级联的维度的索引不一致。例如纵向级联时列索引不一致，横向级联时行索引不一致\n有2种连接方式：\n外连接：补NaN（默认模式）\n内连接：只连接匹配的项\n如果想要保留数据的完整性必须使用outer（外连接）\npd.concat((df1,df2),axis=0) pd.concat((df1,df2),axis=0,join=\u0026#39;inner\u0026#39;) #inner直把可以级联的级联不能级联不处理 合并操作 #\rmerge与concat的区别在于，merge需要依据某一共同列来进行合并\n使用pd.merge()合并时，会自动根据两者相同column名称的那一列，作为key来进行合并。\n注意每一列元素的顺序不要求一致\ndf1 = DataFrame({\u0026#39;employee\u0026#39;:[\u0026#39;Bob\u0026#39;,\u0026#39;Jake\u0026#39;,\u0026#39;Lisa\u0026#39;], \u0026#39;group\u0026#39;:[\u0026#39;Accounting\u0026#39;,\u0026#39;Engineering\u0026#39;,\u0026#39;Engineering\u0026#39;], }) df1 df2 = DataFrame({\u0026#39;employee\u0026#39;:[\u0026#39;Lisa\u0026#39;,\u0026#39;Bob\u0026#39;,\u0026#39;Jake\u0026#39;], \u0026#39;hire_date\u0026#39;:[2004,2008,2012], }) df2 pd.merge(df1,df2,on=\u0026#39;employee\u0026#39;) 当两张表没有可进行连接的列时，可使用left_on和right_on手动指定merge中左右两边的哪一列列作为连接的列\ndf1 = DataFrame({\u0026#39;employee\u0026#39;:[\u0026#39;Bobs\u0026#39;,\u0026#39;Linda\u0026#39;,\u0026#39;Bill\u0026#39;], \u0026#39;group\u0026#39;:[\u0026#39;Accounting\u0026#39;,\u0026#39;Product\u0026#39;,\u0026#39;Marketing\u0026#39;], \u0026#39;hire_date\u0026#39;:[1998,2017,2018]}) df1 df5 = DataFrame({\u0026#39;name\u0026#39;:[\u0026#39;Lisa\u0026#39;,\u0026#39;Bobs\u0026#39;,\u0026#39;Bill\u0026#39;], \u0026#39;hire_dates\u0026#39;:[1998,2016,2007]}) df5 pd.merge(df1,df5,left_on=\u0026#39;employee\u0026#39;,right_on=\u0026#39;name\u0026#39;) 替换操作 #\r替换操作可以同步作用于Series和DataFrame中\n单值替换\n普通替换： 替换所有符合要求的元素:to_replace=15,value=\u0026lsquo;e\u0026rsquo;\n按列指定单值替换： to_replace={列标签：替换值} value=\u0026lsquo;value\u0026rsquo;\n多值替换\n列表替换: to_replace=[] value=[]\n字典替换（推荐） to_replace={to_replace:value,to_replace:value}\ndf = DataFrame(data=np.random.randint(0,100,size=(5,6))) df df.replace(to_replace=2,value=\u0026#39;Two\u0026#39;) df.replace(to_replace={1:\u0026#39;one\u0026#39;}) df.replace(to_replace={4:5},value=\u0026#39;five\u0026#39;) #将指定列的元素进行替换to_replase={列索引：被替换的值} 映射操作 #\r概念：创建一个映射关系列表，把values元素和一个特定的标签或者字符串绑定（给一个元素值提供不同的表现形式）\n创建一个df，两列分别是姓名和薪资，然后给其名字起对应的英文名\ndic = { \u0026#39;name\u0026#39;:[\u0026#39;张三\u0026#39;,\u0026#39;李四\u0026#39;,\u0026#39;张三\u0026#39;], \u0026#39;salary\u0026#39;:[15000,20000,15000] } df = DataFrame(data=dic) df #映射关系表 dic = { \u0026#39;张三\u0026#39;:\u0026#39;tom\u0026#39;, \u0026#39;李四\u0026#39;:\u0026#39;jack\u0026#39; } df[\u0026#39;e_name\u0026#39;] = df[\u0026#39;name\u0026#39;].map(dic) df 排序实现的随机抽样 #\rtake()\nnp.random.permutation()\n#生成乱序的随机序列 np.random.permutation(10) #将原始数据打乱 df.take([2,0,1],axis=1) df.take(np.random.permutation(3),axis=1) 数据的分类处理 #\r数据分类处理的核心：\ngroupby()函数\ngroups属性查看分组情况\n#想要水果的种类进行分析 df.groupby(by=\u0026#39;item\u0026#39;) #查看详细的分组情况 df.groupby(by=\u0026#39;item\u0026#39;).groups 分组聚合 #\r#计算出每一种水果的平均价格 df.groupby(by=\u0026#39;item\u0026#39;)[\u0026#39;price\u0026#39;].mean() #计算每一种颜色对应水果的平均重量 df.groupby(by=\u0026#39;color\u0026#39;)[\u0026#39;weight\u0026#39;].mean() dic = df.groupby(by=\u0026#39;color\u0026#39;)[\u0026#39;weight\u0026#39;].mean().to_dict() #将计算出的平均重量汇总到源数据 df[\u0026#39;mean_w\u0026#39;] = df[\u0026#39;color\u0026#39;].map(dic) df 高级数据聚合 #\r使用groupby分组后，也可以使用transform和apply提供自定义函数实现更多的运算\ndf.groupby(\u0026lsquo;item\u0026rsquo;)[\u0026lsquo;price\u0026rsquo;].sum() \u0026lt;==\u0026gt; df.groupby(\u0026lsquo;item\u0026rsquo;)[\u0026lsquo;price\u0026rsquo;].apply(sum)\ntransform和apply都会进行运算，在transform或者apply中传入函数即可\ntransform和apply也可以传入一个lambda表达式\ndef my_mean(s): m_sum = 0 for i in s: m_sum += i return m_sum / len(s) df.groupby(by=\u0026#39;item\u0026#39;)[\u0026#39;price\u0026#39;].transform(my_mean) df.groupby(by=\u0026#39;item\u0026#39;)[\u0026#39;price\u0026#39;].apply(my_mean) 数据加载 #\r读取type-.txt文件数据\ndf = pd.read_csv(\u0026#39;./data/type-.txt\u0026#39;) df pd.read_csv(\u0026#39;./data/type-.txt\u0026#39;,header=None,sep=\u0026#39;-\u0026#39;) #连接数据库，获取连接对象 import sqlite3 as sqlite3 conn = sqlite3.connect(\u0026#39;./data/weather_2012.sqlite\u0026#39;) #读取库表中的数据值 sql_df=pd.read_sql(\u0026#39;select * from weather_2012\u0026#39;,conn) sql_df #将一个df中的数据值写入存储到db df.to_sql(\u0026#39;sql_data456\u0026#39;,conn) 透视表 #\r透视表是一种可以对数据动态排布并且分类汇总的表格格式。或许大多数人都在Excel使用过数据透视表，也体会到它的强大功能，而在pandas中它被称作pivot_table。\n透视表的优点：\n灵活性高，可以随意定制你的分析计算要求\n脉络清晰易于理解数据\n操作性强，报表神器\npivot_table有四个最重要的参数index、values、columns、aggfunc\nindex参数：分类汇总的分类条件\n每个pivot_table必须拥有一个index。如果想查看哈登对阵每个队伍的得分则需要对每一个队进行分类并计算其各类得分的平均值：\n想看看哈登对阵同一对手在不同主客场下的数据，分类条件为对手和主客场\nvalues参数：需要对计算的数据进行筛选\n如果我们只需要哈登在主客场和不同胜负情况下的得分、篮板与助攻三项数据：\ndf.pivot_table(index=[\u0026#39;对手\u0026#39;,\u0026#39;主客场\u0026#39;]) df.pivot_table(index=[\u0026#39;主客场\u0026#39;,\u0026#39;胜负\u0026#39;],values=[\u0026#39;得分\u0026#39;,\u0026#39;篮板\u0026#39;,\u0026#39;助攻\u0026#39;]) Aggfunc参数：设置我们对数据聚合时进行的函数操作\n当我们未设置aggfunc时，它默认aggfunc=\u0026lsquo;mean\u0026rsquo;计算均值。\n","date":"2024-09-28","externalUrl":null,"permalink":"/all/python/pandas/","section":"Alls","summary":"基于pandas的数据清洗 # 处理丢失数据 # 有两种丢失数据： None","title":"Pandas","type":"all"},{"content":"\r基于pandas的数据清洗 #\r处理丢失数据 #\r有两种丢失数据：\nNone\nnp.nan(NaN)\ntype(None) NoneType type(np.nan) float 为什么在数据分析中需要用到的是浮点类型的空而不是对象类型？\n数据分析中会常常使用某些形式的运算来处理原始数据，如果原数数据中的空值为NAN的形式，则不会干扰或者中断运算。 NAN可以参与运算的\nNone是不可以参与运算\n在pandas中如果遇到了None形式的空值则pandas会将其强转成NAN的形式。\npandas处理空值操作 #\risnull\nnotnull\nany\nall\ndropna\nfillna\n方式1：对空值进行过滤（删除空所在的行数据） #\r技术：isnull，notnull，any，all\ndf.isnull() #哪些行中有空值 #any(axis=1)检测哪些行中存有空值 df.isnull().any(axis=1) #any会作用isnull返回结果的每一行 #true对应的行就是存有缺失数据的行 df.notnull() df.notnull().all(axis=1) #将布尔值作为源数据的行索引 df.loc[df.notnull().all(axis=1)] #获取空对应的行数据 df.loc[df.isnull().any(axis=1)] #获取空对应行数据的行索引 indexs = df.loc[df.isnull().any(axis=1)].index indexs df.drop(labels=indexs,axis=0)#将缺失值行直接删除 方式2：dropna，fillna #\rdropna：可以直接将缺失的行或者列进行删除\n对缺失值进行覆盖 fillna\ndf.dropna(axis=0) df.fillna(value=999) #使用指定值将源数据中所有的空值进行填充 #使用空的近邻值进行填充 #method=ffill向前填充，bfill向后填充 df.fillna(axis=0,method=\u0026#39;bfill\u0026#39;) 什么时候用dropna什么时候用fillna\n尽量使用dropna，如果删除成本比较高，则使用fillna\n使用空值对应列的均值进行空值填充\nfor col in df.columns: #检测哪些列中存有空值 if df[col].isnull().sum() \u0026gt; 0:#说明df[col]中存有空值 mean_value = df[col].mean() df[col] = df[col].fillna(value=mean_value) 处理重复数据 #\r#检测哪些行存有重复的数据 df.duplicated(keep=\u0026#39;first\u0026#39;) df.loc[~df.duplicated(keep=\u0026#39;first\u0026#39;)] #异步到位删除 df.drop_duplicates(keep=\u0026#39;first\u0026#39;) 级联操作 #\rpd.concat, pd.append\npandas使用pd.concat函数\ndf1 = pd.DataFrame(data=np.random.randint(0,100,size=(5,3)),columns=[\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;]) df2 = pd.DataFrame(data=np.random.randint(0,100,size=(5,3)),columns=[\u0026#39;A\u0026#39;,\u0026#39;D\u0026#39;,\u0026#39;C\u0026#39;]) pd.concat((df1,df1),axis=1) #行列索引都一致的级联叫做匹配级联 不匹配级联\n不匹配指的是级联的维度的索引不一致。例如纵向级联时列索引不一致，横向级联时行索引不一致\n有2种连接方式：\n外连接：补NaN（默认模式）\n内连接：只连接匹配的项\n如果想要保留数据的完整性必须使用outer（外连接）\npd.concat((df1,df2),axis=0) pd.concat((df1,df2),axis=0,join=\u0026#39;inner\u0026#39;) #inner直把可以级联的级联不能级联不处理 合并操作 #\rmerge与concat的区别在于，merge需要依据某一共同列来进行合并\n使用pd.merge()合并时，会自动根据两者相同column名称的那一列，作为key来进行合并。\n注意每一列元素的顺序不要求一致\ndf1 = DataFrame({\u0026#39;employee\u0026#39;:[\u0026#39;Bob\u0026#39;,\u0026#39;Jake\u0026#39;,\u0026#39;Lisa\u0026#39;], \u0026#39;group\u0026#39;:[\u0026#39;Accounting\u0026#39;,\u0026#39;Engineering\u0026#39;,\u0026#39;Engineering\u0026#39;], }) df1 df2 = DataFrame({\u0026#39;employee\u0026#39;:[\u0026#39;Lisa\u0026#39;,\u0026#39;Bob\u0026#39;,\u0026#39;Jake\u0026#39;], \u0026#39;hire_date\u0026#39;:[2004,2008,2012], }) df2 pd.merge(df1,df2,on=\u0026#39;employee\u0026#39;) 当两张表没有可进行连接的列时，可使用left_on和right_on手动指定merge中左右两边的哪一列列作为连接的列\ndf1 = DataFrame({\u0026#39;employee\u0026#39;:[\u0026#39;Bobs\u0026#39;,\u0026#39;Linda\u0026#39;,\u0026#39;Bill\u0026#39;], \u0026#39;group\u0026#39;:[\u0026#39;Accounting\u0026#39;,\u0026#39;Product\u0026#39;,\u0026#39;Marketing\u0026#39;], \u0026#39;hire_date\u0026#39;:[1998,2017,2018]}) df1 df5 = DataFrame({\u0026#39;name\u0026#39;:[\u0026#39;Lisa\u0026#39;,\u0026#39;Bobs\u0026#39;,\u0026#39;Bill\u0026#39;], \u0026#39;hire_dates\u0026#39;:[1998,2016,2007]}) df5 pd.merge(df1,df5,left_on=\u0026#39;employee\u0026#39;,right_on=\u0026#39;name\u0026#39;) 替换操作 #\r替换操作可以同步作用于Series和DataFrame中\n单值替换\n普通替换： 替换所有符合要求的元素:to_replace=15,value=\u0026lsquo;e\u0026rsquo;\n按列指定单值替换： to_replace={列标签：替换值} value=\u0026lsquo;value\u0026rsquo;\n多值替换\n列表替换: to_replace=[] value=[]\n字典替换（推荐） to_replace={to_replace:value,to_replace:value}\ndf = DataFrame(data=np.random.randint(0,100,size=(5,6))) df df.replace(to_replace=2,value=\u0026#39;Two\u0026#39;) df.replace(to_replace={1:\u0026#39;one\u0026#39;}) df.replace(to_replace={4:5},value=\u0026#39;five\u0026#39;) #将指定列的元素进行替换to_replase={列索引：被替换的值} 映射操作 #\r概念：创建一个映射关系列表，把values元素和一个特定的标签或者字符串绑定（给一个元素值提供不同的表现形式）\n创建一个df，两列分别是姓名和薪资，然后给其名字起对应的英文名\ndic = { \u0026#39;name\u0026#39;:[\u0026#39;张三\u0026#39;,\u0026#39;李四\u0026#39;,\u0026#39;张三\u0026#39;], \u0026#39;salary\u0026#39;:[15000,20000,15000] } df = DataFrame(data=dic) df #映射关系表 dic = { \u0026#39;张三\u0026#39;:\u0026#39;tom\u0026#39;, \u0026#39;李四\u0026#39;:\u0026#39;jack\u0026#39; } df[\u0026#39;e_name\u0026#39;] = df[\u0026#39;name\u0026#39;].map(dic) df 排序实现的随机抽样 #\rtake()\nnp.random.permutation()\n#生成乱序的随机序列 np.random.permutation(10) #将原始数据打乱 df.take([2,0,1],axis=1) df.take(np.random.permutation(3),axis=1) 数据的分类处理 #\r数据分类处理的核心：\ngroupby()函数\ngroups属性查看分组情况\n#想要水果的种类进行分析 df.groupby(by=\u0026#39;item\u0026#39;) #查看详细的分组情况 df.groupby(by=\u0026#39;item\u0026#39;).groups 分组聚合 #\r#计算出每一种水果的平均价格 df.groupby(by=\u0026#39;item\u0026#39;)[\u0026#39;price\u0026#39;].mean() #计算每一种颜色对应水果的平均重量 df.groupby(by=\u0026#39;color\u0026#39;)[\u0026#39;weight\u0026#39;].mean() dic = df.groupby(by=\u0026#39;color\u0026#39;)[\u0026#39;weight\u0026#39;].mean().to_dict() #将计算出的平均重量汇总到源数据 df[\u0026#39;mean_w\u0026#39;] = df[\u0026#39;color\u0026#39;].map(dic) df 高级数据聚合 #\r使用groupby分组后，也可以使用transform和apply提供自定义函数实现更多的运算\ndf.groupby(\u0026lsquo;item\u0026rsquo;)[\u0026lsquo;price\u0026rsquo;].sum() \u0026lt;==\u0026gt; df.groupby(\u0026lsquo;item\u0026rsquo;)[\u0026lsquo;price\u0026rsquo;].apply(sum)\ntransform和apply都会进行运算，在transform或者apply中传入函数即可\ntransform和apply也可以传入一个lambda表达式\ndef my_mean(s): m_sum = 0 for i in s: m_sum += i return m_sum / len(s) df.groupby(by=\u0026#39;item\u0026#39;)[\u0026#39;price\u0026#39;].transform(my_mean) df.groupby(by=\u0026#39;item\u0026#39;)[\u0026#39;price\u0026#39;].apply(my_mean) 数据加载 #\r读取type-.txt文件数据\ndf = pd.read_csv(\u0026#39;./data/type-.txt\u0026#39;) df pd.read_csv(\u0026#39;./data/type-.txt\u0026#39;,header=None,sep=\u0026#39;-\u0026#39;) #连接数据库，获取连接对象 import sqlite3 as sqlite3 conn = sqlite3.connect(\u0026#39;./data/weather_2012.sqlite\u0026#39;) #读取库表中的数据值 sql_df=pd.read_sql(\u0026#39;select * from weather_2012\u0026#39;,conn) sql_df #将一个df中的数据值写入存储到db df.to_sql(\u0026#39;sql_data456\u0026#39;,conn) 透视表 #\r透视表是一种可以对数据动态排布并且分类汇总的表格格式。或许大多数人都在Excel使用过数据透视表，也体会到它的强大功能，而在pandas中它被称作pivot_table。\n透视表的优点：\n灵活性高，可以随意定制你的分析计算要求\n脉络清晰易于理解数据\n操作性强，报表神器\npivot_table有四个最重要的参数index、values、columns、aggfunc\nindex参数：分类汇总的分类条件\n每个pivot_table必须拥有一个index。如果想查看哈登对阵每个队伍的得分则需要对每一个队进行分类并计算其各类得分的平均值：\n想看看哈登对阵同一对手在不同主客场下的数据，分类条件为对手和主客场\nvalues参数：需要对计算的数据进行筛选\n如果我们只需要哈登在主客场和不同胜负情况下的得分、篮板与助攻三项数据：\ndf.pivot_table(index=[\u0026#39;对手\u0026#39;,\u0026#39;主客场\u0026#39;]) df.pivot_table(index=[\u0026#39;主客场\u0026#39;,\u0026#39;胜负\u0026#39;],values=[\u0026#39;得分\u0026#39;,\u0026#39;篮板\u0026#39;,\u0026#39;助攻\u0026#39;]) Aggfunc参数：设置我们对数据聚合时进行的函数操作\n当我们未设置aggfunc时，它默认aggfunc=\u0026lsquo;mean\u0026rsquo;计算均值。\n","date":"2024-09-28","externalUrl":null,"permalink":"/python/pandas/","section":"Pythons","summary":"基于pandas的数据清洗 # 处理丢失数据 # 有两种丢失数据： None","title":"Pandas","type":"python"},{"content":"","date":"2024-09-28","externalUrl":null,"permalink":"/tags/python/","section":"Tags","summary":"","title":"Python","type":"tags"},{"content":"","date":"2024-09-28","externalUrl":null,"permalink":"/python/","section":"Pythons","summary":"","title":"Pythons","type":"python"},{"content":"","date":"2024-09-28","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2024-09-28","externalUrl":null,"permalink":"/","section":"欢迎来到 JohnnyBlog 的个人博客","summary":"","title":"欢迎来到 JohnnyBlog 的个人博客","type":"page"},{"content":"\rnumpy模块 #\rNumPy(Numerical Python) 是 Python 语言中做科学计算的基础库。重在于数值计算，\n也是大部分Python科学计算库的基础，多用于在大型、多维数组上执行的数值运算。\nnumpy的创建 #\r使用np.array()创建\n使用plt创建\n使用np的routines函数创建\n使用array()创建一个一维数组\nimport numpy as np arr=np.array([1,2,3]) arr array([1, 2, 3]) 使用array()创建一个多维数组\narr=np.array([[1,2,4],[2,4,5]]) arr array([[1, 2, 4], [2, 4, 5]]) 数组和列表的区别是什么？\n数组中存储的数据元素类型必须是统一类型\n优先级：\n字符串 \u0026gt; 浮点型 \u0026gt; 整数\narr = np.array([1,2.2,3]) arr array([1. , 2.2, 3. ]) 将外部的一张图片读取加载到numpy数组中，然后尝试改变数组元素的数值查看对原始图片的影响\nimport matplotlib.pyplot as plt img_arr=plt.imread(\u0026#39;./1.jpg\u0026#39;) #返回的数组,数组中装载的就是图片内容 plt.imshow(img_arr)#将numpy数组进行可视化展示 img_arr = img_arr - 100 #将每一个数组元素都减去100 plt.imshow(img_arr) np.ones(shape=(3,4)) np.linspace(0,100,num=20) #一维的等差数列数组 np.arange(10,50,step=2) #一维等差数列 np.random.randint(0,100,size=(5,3)) array([[19, 0, 17], [72, 29, 13], [69, 59, 68], [63, 54, 87], [70, 64, 0]]) numpy的常用属性 #\rshape\nndim\nsize\ndtype\narr = np.random.randint(0,100,size=(5,6)) arr arr.shape #返回的是数组的形状 (5, 6) arr.ndim #返回的是数组的维度 2 arr.size #返回数组元素的个数 30 arr.dtype #返回的是数组元素的类型 dtype(\u0026#39;int64\u0026#39;) type(arr) #数组的数据类型 numpy.ndarray numpy的数据类型 #\rarray(dtype=?):可以设定数据类型 arr.dtype = \u0026lsquo;?\u0026rsquo;:可以修改数据类型\narr = np.array([1,2,3]) arr.dtype dtype(\u0026#39;int64\u0026#39;) #创建一个数组，指定数组元素类型为int32 arr = np.array([1,2,3],dtype=\u0026#39;int32\u0026#39;) arr.dtype dtype(\u0026#39;int32\u0026#39;) arr.dtype = \u0026#39;uint8\u0026#39; #修改数组的元素类型 arr.dtype dtype(\u0026#39;uint8\u0026#39;) numpy的索引和切片操作（重点） #\r索引操作和列表同理\narr = np.random.randint(1,100,size=(5,6)) arr arr[1] #取出了numpy数组中的下标为1的行数据 array([37, 57, 26, 92, 91, 34]) arr[[1,3,4]] #取出多行 切片操作 #\r切出前两列数据\n切出前两行数据\n切出前两行的前两列的数据\n数组数据翻转\n#切出arr数组的前两行的数据 arr[0:2] #arr[行切片] #切出arr数组中的前两列 arr[:,0:2] #arr[行切片,列切片] #切出前两行的前两列的数据 arr[0:2,0:2] #将数组的行倒置 arr[::-1] #将数组的列倒置 arr[:,::-1] #所有元素倒置 arr[::-1,::-1] #将一张图片进行左右翻转 img_arr = plt.imread(\u0026#39;./1.jpg\u0026#39;) plt.imshow(img_arr) img_arr.shape (300, 450, 3) plt.imshow(img_arr[:,::-1,:]) #img_arr[行，列，颜色] #图片上下翻转 plt.imshow(img_arr[::-1,:,:]) #图片裁剪的功能 plt.imshow(img_arr[66:200,78:300,:]) 变形reshape #\r#将二维的数组变形成1维 arr_1 = arr.reshape((5,6)) #将一维变形成多维 arr_1.reshape((5,6)) arr2=np.random.randint(1,100,(4,6)) arr2 array([[ 1, 26, 42, 11, 24, 68], [22, 15, 38, 17, 32, 39], [52, 56, 32, 93, 45, 10], [ 4, 44, 32, 96, 47, 41]]) 级联操作 #\r将多个numpy数组进行横向或者纵向的拼接 axis轴向的理解 0:列 1:行 问题： 级联的两个数组维度一样，但是行列个数不一样会如何？ np.concatenate((arr,arr2),axis=0) arr_3 = np.concatenate((img_arr,img_arr,img_arr),axis=0) plt.imshow(arr_3) arr.sum(axis=1) array([321, 337, 297, 197, 330]) arr.max(axis=1) array([90, 92, 93, 66, 94]) 常用的数学函数 #\rNumPy 提供了标准的三角函数：sin()、cos()、tan() numpy.around(a,decimals) 函数返回指定数字的四舍五入值。 参数说明： a: 数组 decimals: 舍入的小数位数。 默认值为0。 如果为负，整数将四舍五入到小数点左侧的位置\nnp.sin(2.5) np.around(3.84,2) 常用的统计函数 #\rnumpy.amin() 和 numpy.amax()，用于计算数组中的元素沿指定轴的最小、最大值。\nnumpy.ptp():计算数组中元素最大值与最小值的差（最大值 - 最小值）。\nnumpy.median() 函数用于计算数组 a 中元素的中位数（中值）\n标准差std():标准差是一组数据平均值分散程度的一种度量。\n公式：std = sqrt(mean((x - x.mean())**2))\n如果数组是 [1，2，3，4]，则其平均值为 2.5。 因此，差的平方是 [2.25,0.25,0.25,2.25]，并且其平均值的平方根除以 4，即 sqrt(5/4) ，结果为 1.1180339887498949。\n方差var()：统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方值的平均数，即 mean((x - x.mean())** 2)。换句话说，标准差是方差的平方根。\narr[1].std() arr[1].var() 矩阵相关 #\rNumPy 中包含了一个矩阵库 numpy.matlib，该模块中的函数返回的是一个矩阵，而不是 ndarray 对象。\n一个 的矩阵是一个由行（row）列（column）元素排列成的矩形阵列。\nnumpy.matlib.identity() 函数返回给定大小的单位矩阵。单位矩阵是个方阵，\n从左上角到右下角的对角线（称为主对角线）上的元素均为 1，除此以外全都为 0。\n#eye返回一个标准的单位矩阵 np.eye(6) arr.T 矩阵相乘 #\rnumpy.dot(a, b, out=None) a : ndarray 数组 b : ndarray 数组\na1 = np.array([[2,1],[4,3]]) a2 = np.array([[1,2],[1,0]]) np.dot(a1,a2) array([[3, 4], [7, 8]]) ","date":"2024-09-25","externalUrl":null,"permalink":"/all/python/numpy/","section":"Alls","summary":"numpy模块 # NumPy(Numerical Python) 是 Python 语言中做科学计算的基础库。重在于数值","title":"numpy","type":"all"},{"content":"\rnumpy模块 #\rNumPy(Numerical Python) 是 Python 语言中做科学计算的基础库。重在于数值计算，\n也是大部分Python科学计算库的基础，多用于在大型、多维数组上执行的数值运算。\nnumpy的创建 #\r使用np.array()创建\n使用plt创建\n使用np的routines函数创建\n使用array()创建一个一维数组\nimport numpy as np arr=np.array([1,2,3]) arr array([1, 2, 3]) 使用array()创建一个多维数组\narr=np.array([[1,2,4],[2,4,5]]) arr array([[1, 2, 4], [2, 4, 5]]) 数组和列表的区别是什么？\n数组中存储的数据元素类型必须是统一类型\n优先级：\n字符串 \u0026gt; 浮点型 \u0026gt; 整数\narr = np.array([1,2.2,3]) arr array([1. , 2.2, 3. ]) 将外部的一张图片读取加载到numpy数组中，然后尝试改变数组元素的数值查看对原始图片的影响\nimport matplotlib.pyplot as plt img_arr=plt.imread(\u0026#39;./1.jpg\u0026#39;) #返回的数组,数组中装载的就是图片内容 plt.imshow(img_arr)#将numpy数组进行可视化展示 img_arr = img_arr - 100 #将每一个数组元素都减去100 plt.imshow(img_arr) np.ones(shape=(3,4)) np.linspace(0,100,num=20) #一维的等差数列数组 np.arange(10,50,step=2) #一维等差数列 np.random.randint(0,100,size=(5,3)) array([[19, 0, 17], [72, 29, 13], [69, 59, 68], [63, 54, 87], [70, 64, 0]]) numpy的常用属性 #\rshape\nndim\nsize\ndtype\narr = np.random.randint(0,100,size=(5,6)) arr arr.shape #返回的是数组的形状 (5, 6) arr.ndim #返回的是数组的维度 2 arr.size #返回数组元素的个数 30 arr.dtype #返回的是数组元素的类型 dtype(\u0026#39;int64\u0026#39;) type(arr) #数组的数据类型 numpy.ndarray numpy的数据类型 #\rarray(dtype=?):可以设定数据类型 arr.dtype = \u0026lsquo;?\u0026rsquo;:可以修改数据类型\narr = np.array([1,2,3]) arr.dtype dtype(\u0026#39;int64\u0026#39;) #创建一个数组，指定数组元素类型为int32 arr = np.array([1,2,3],dtype=\u0026#39;int32\u0026#39;) arr.dtype dtype(\u0026#39;int32\u0026#39;) arr.dtype = \u0026#39;uint8\u0026#39; #修改数组的元素类型 arr.dtype dtype(\u0026#39;uint8\u0026#39;) numpy的索引和切片操作（重点） #\r索引操作和列表同理\narr = np.random.randint(1,100,size=(5,6)) arr arr[1] #取出了numpy数组中的下标为1的行数据 array([37, 57, 26, 92, 91, 34]) arr[[1,3,4]] #取出多行 切片操作 #\r切出前两列数据\n切出前两行数据\n切出前两行的前两列的数据\n数组数据翻转\n#切出arr数组的前两行的数据 arr[0:2] #arr[行切片] #切出arr数组中的前两列 arr[:,0:2] #arr[行切片,列切片] #切出前两行的前两列的数据 arr[0:2,0:2] #将数组的行倒置 arr[::-1] #将数组的列倒置 arr[:,::-1] #所有元素倒置 arr[::-1,::-1] #将一张图片进行左右翻转 img_arr = plt.imread(\u0026#39;./1.jpg\u0026#39;) plt.imshow(img_arr) img_arr.shape (300, 450, 3) plt.imshow(img_arr[:,::-1,:]) #img_arr[行，列，颜色] #图片上下翻转 plt.imshow(img_arr[::-1,:,:]) #图片裁剪的功能 plt.imshow(img_arr[66:200,78:300,:]) 变形reshape #\r#将二维的数组变形成1维 arr_1 = arr.reshape((5,6)) #将一维变形成多维 arr_1.reshape((5,6)) arr2=np.random.randint(1,100,(4,6)) arr2 array([[ 1, 26, 42, 11, 24, 68], [22, 15, 38, 17, 32, 39], [52, 56, 32, 93, 45, 10], [ 4, 44, 32, 96, 47, 41]]) 级联操作 #\r将多个numpy数组进行横向或者纵向的拼接 axis轴向的理解 0:列 1:行 问题： 级联的两个数组维度一样，但是行列个数不一样会如何？ np.concatenate((arr,arr2),axis=0) arr_3 = np.concatenate((img_arr,img_arr,img_arr),axis=0) plt.imshow(arr_3) arr.sum(axis=1) array([321, 337, 297, 197, 330]) arr.max(axis=1) array([90, 92, 93, 66, 94]) 常用的数学函数 #\rNumPy 提供了标准的三角函数：sin()、cos()、tan() numpy.around(a,decimals) 函数返回指定数字的四舍五入值。 参数说明： a: 数组 decimals: 舍入的小数位数。 默认值为0。 如果为负，整数将四舍五入到小数点左侧的位置\nnp.sin(2.5) np.around(3.84,2) 常用的统计函数 #\rnumpy.amin() 和 numpy.amax()，用于计算数组中的元素沿指定轴的最小、最大值。\nnumpy.ptp():计算数组中元素最大值与最小值的差（最大值 - 最小值）。\nnumpy.median() 函数用于计算数组 a 中元素的中位数（中值）\n标准差std():标准差是一组数据平均值分散程度的一种度量。\n公式：std = sqrt(mean((x - x.mean())**2))\n如果数组是 [1，2，3，4]，则其平均值为 2.5。 因此，差的平方是 [2.25,0.25,0.25,2.25]，并且其平均值的平方根除以 4，即 sqrt(5/4) ，结果为 1.1180339887498949。\n方差var()：统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方值的平均数，即 mean((x - x.mean())** 2)。换句话说，标准差是方差的平方根。\narr[1].std() arr[1].var() 矩阵相关 #\rNumPy 中包含了一个矩阵库 numpy.matlib，该模块中的函数返回的是一个矩阵，而不是 ndarray 对象。\n一个 的矩阵是一个由行（row）列（column）元素排列成的矩形阵列。\nnumpy.matlib.identity() 函数返回给定大小的单位矩阵。单位矩阵是个方阵，\n从左上角到右下角的对角线（称为主对角线）上的元素均为 1，除此以外全都为 0。\n#eye返回一个标准的单位矩阵 np.eye(6) arr.T 矩阵相乘 #\rnumpy.dot(a, b, out=None) a : ndarray 数组 b : ndarray 数组\na1 = np.array([[2,1],[4,3]]) a2 = np.array([[1,2],[1,0]]) np.dot(a1,a2) array([[3, 4], [7, 8]]) ","date":"2024-09-25","externalUrl":null,"permalink":"/python/numpy/","section":"Pythons","summary":"numpy模块 # NumPy(Numerical Python) 是 Python 语言中做科学计算的基础库。重在于数值","title":"numpy","type":"python"},{"content":"\rSeries #\rSeries是一种类似与一维数组的对象，由下面两个部分组成：\nvalues：一组数据（ndarray类型）\nindex：相关的数据索引标签\nSeries的创建\n由列表或numpy数组创建\n由字典创建\nfrom pandas import Series s = Series(data=[1,2,3,\u0026#39;four\u0026#39;]) s import numpy as np s = Series(data=np.random.randint(0,100,size=(3,))) s #index用来指定显示索引 s = Series(data=[1,2,3,\u0026#39;four\u0026#39;],index=[\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;]) s #为什么需要有显示索引 # 显示索引可以增强Series的可读性 dic = { \u0026#39;语文\u0026#39;:100, \u0026#39;数学\u0026#39;:99, \u0026#39;理综\u0026#39;:250 } s = Series(data=dic) s Series的索引和切片 #\rs[0] s.语文 s[0:2] Series的常用属性 #\rs.shape s.size s.index #返回索引 s.values #返回值 s.dtype #元素的类型 s = Series(data=[1,2,3,\u0026#39;four\u0026#39;],index=[\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;]) s.dtype #数据类型O表示的是Object（字符串类型） Series的常用方法 #\rhead(),tail() unique() isnull(),notnull() add() sub() mul() div() s = Series(data=np.random.randint(60,100,size=(10,))) s.head(3) #显示前n个数据 s.tail(3) #显示后n个元素 s.unique() #去重 s.isnull() #用于判断每一个元素是否为空，为空返回True，否则返回False s.notnull() Series的算术运算 #\r法则：索引一致的元素进行算数运算否则补空\ns1 = Series(data=[1,2,3],index=[\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;]) s2 = Series(data=[1,2,3],index=[\u0026#39;a\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;c\u0026#39;]) s = s1 + s2 s DataFrame #\rDataFrame是一个【表格型】的数据结构。DataFrame由按一定顺序排列的多列数据组成。设计初衷是将Series的使用场景从一维拓展到多维。DataFrame既有行索引，也有列索引。\n行索引：index\n列索引：columns\n值：values\nDataFrame的创建 #\rndarray创建\n字典创建\nfrom pandas import DataFrame df = DataFrame(data=[[1,2,3],[4,5,6]]) df dic = { \u0026#39;name\u0026#39;:[\u0026#39;zhangsan\u0026#39;,\u0026#39;lisi\u0026#39;,\u0026#39;wanglaowu\u0026#39;], \u0026#39;salary\u0026#39;:[1000,2000,3000] } df = DataFrame(data=dic,index=[\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;]) df DataFrame索引操作 #\r对行进行索引\n队列进行索引\n对元素进行索引\ndf[\u0026#39;a\u0026#39;] #取单列，如果df有显示的索引，通过索引机制去行或者列的时候只可以使用显示索引 df[[\u0026#39;a\u0026#39;,\u0026#39;c\u0026#39;]] #取多列 iloc:通过隐式索引取行\nloc:通过显示索引取行\n#取单行 df.loc[0] #取多行 df.iloc[[0,3,5]] #取单个元素 df.iloc[0,2] df.loc[0,\u0026#39;a\u0026#39;] #取多个元素 df.iloc[[1,3,5],2] DataFrame的切片操作 #\r对行进行切片\n对列进行切片\n#切行 df[0:2] #切列 df.iloc[:,0:2] df索引和切片操作 #\r索引：\ndf[col]:取列\ndf.loc[index]:取行\ndf.iloc[index,col]:取元素\n切片：\ndf[index1:index3]:切行\ndf.iloc[:,col1:col3]:切列\n时间数据类型的转换 #\rpd.to_datetime(col)\n将某一列设置为行索引\ndf.set_index()\n#将time列的数据类型转换成时间序列类型 df[\u0026#39;time\u0026#39;] = pd.to_datetime(df[\u0026#39;time\u0026#39;]) df #将time列作为源数据的行索引 df.set_index(\u0026#39;time\u0026#39;,inplace=True) ","date":"2024-09-23","externalUrl":null,"permalink":"/all/python/series/","section":"Alls","summary":"Series # Series是一种类似与一维数组的对象，由下面两个部分组","title":"Series","type":"all"},{"content":"\rSeries #\rSeries是一种类似与一维数组的对象，由下面两个部分组成：\nvalues：一组数据（ndarray类型）\nindex：相关的数据索引标签\nSeries的创建\n由列表或numpy数组创建\n由字典创建\nfrom pandas import Series s = Series(data=[1,2,3,\u0026#39;four\u0026#39;]) s import numpy as np s = Series(data=np.random.randint(0,100,size=(3,))) s #index用来指定显示索引 s = Series(data=[1,2,3,\u0026#39;four\u0026#39;],index=[\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;]) s #为什么需要有显示索引 # 显示索引可以增强Series的可读性 dic = { \u0026#39;语文\u0026#39;:100, \u0026#39;数学\u0026#39;:99, \u0026#39;理综\u0026#39;:250 } s = Series(data=dic) s Series的索引和切片 #\rs[0] s.语文 s[0:2] Series的常用属性 #\rs.shape s.size s.index #返回索引 s.values #返回值 s.dtype #元素的类型 s = Series(data=[1,2,3,\u0026#39;four\u0026#39;],index=[\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;]) s.dtype #数据类型O表示的是Object（字符串类型） Series的常用方法 #\rhead(),tail() unique() isnull(),notnull() add() sub() mul() div() s = Series(data=np.random.randint(60,100,size=(10,))) s.head(3) #显示前n个数据 s.tail(3) #显示后n个元素 s.unique() #去重 s.isnull() #用于判断每一个元素是否为空，为空返回True，否则返回False s.notnull() Series的算术运算 #\r法则：索引一致的元素进行算数运算否则补空\ns1 = Series(data=[1,2,3],index=[\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;]) s2 = Series(data=[1,2,3],index=[\u0026#39;a\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;c\u0026#39;]) s = s1 + s2 s DataFrame #\rDataFrame是一个【表格型】的数据结构。DataFrame由按一定顺序排列的多列数据组成。设计初衷是将Series的使用场景从一维拓展到多维。DataFrame既有行索引，也有列索引。\n行索引：index\n列索引：columns\n值：values\nDataFrame的创建 #\rndarray创建\n字典创建\nfrom pandas import DataFrame df = DataFrame(data=[[1,2,3],[4,5,6]]) df dic = { \u0026#39;name\u0026#39;:[\u0026#39;zhangsan\u0026#39;,\u0026#39;lisi\u0026#39;,\u0026#39;wanglaowu\u0026#39;], \u0026#39;salary\u0026#39;:[1000,2000,3000] } df = DataFrame(data=dic,index=[\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;]) df DataFrame索引操作 #\r对行进行索引\n队列进行索引\n对元素进行索引\ndf[\u0026#39;a\u0026#39;] #取单列，如果df有显示的索引，通过索引机制去行或者列的时候只可以使用显示索引 df[[\u0026#39;a\u0026#39;,\u0026#39;c\u0026#39;]] #取多列 iloc:通过隐式索引取行\nloc:通过显示索引取行\n#取单行 df.loc[0] #取多行 df.iloc[[0,3,5]] #取单个元素 df.iloc[0,2] df.loc[0,\u0026#39;a\u0026#39;] #取多个元素 df.iloc[[1,3,5],2] DataFrame的切片操作 #\r对行进行切片\n对列进行切片\n#切行 df[0:2] #切列 df.iloc[:,0:2] df索引和切片操作 #\r索引：\ndf[col]:取列\ndf.loc[index]:取行\ndf.iloc[index,col]:取元素\n切片：\ndf[index1:index3]:切行\ndf.iloc[:,col1:col3]:切列\n时间数据类型的转换 #\rpd.to_datetime(col)\n将某一列设置为行索引\ndf.set_index()\n#将time列的数据类型转换成时间序列类型 df[\u0026#39;time\u0026#39;] = pd.to_datetime(df[\u0026#39;time\u0026#39;]) df #将time列作为源数据的行索引 df.set_index(\u0026#39;time\u0026#39;,inplace=True) ","date":"2024-09-23","externalUrl":null,"permalink":"/python/series/","section":"Pythons","summary":"Series # Series是一种类似与一维数组的对象，由下面两个部分组","title":"Series","type":"python"},{"content":"\r文件操作 #\r2.1 python操作⽂文件流程 #\rf=open(filename) # 打开⽂文件 f.write(\u0026#34;我是野⽣生程序员\u0026#34;) # 写操作 f.read() #读操作 f.close() #保存并关闭 文件打开模式（⽂文本模式）\nr 只读模式\nw 创建模式，若⽂文件已存在，则覆盖旧⽂文件\na 追加模式，新数据会写到⽂文件末尾\n2.2 创建⽂文件 #\rf = open(file=\u0026#39;D:/⼯工作⽇日常/staff.txt\u0026#39;,mode=\u0026#39;w\u0026#39;) # 若⽂文件已存在，则覆盖 f.write(\u0026#34;Alex CEO 600\\n\u0026#34;) f.write(\u0026#34;⿊黑姑娘 ⾏行行政 5000\\n\u0026#34;) f.close() 2.3 只读模式 #\rf = open(file=\u0026#39;兼职⽩白领学⽣生空姐模特护⼠士联系⽅方式.txt\u0026#39;,mode=\u0026#39;r\u0026#39;) print(f.readline()) # 读⼀一⾏行行 print(\u0026#39;------分隔符-------\u0026#39;) data = f.read() # 读所有，剩下的所有 print(data) f.close() 2.4 追加模式 #\rf = open(file=\u0026#39;兼职⽩白领学⽣生空姐模特护⼠士联系⽅方式.txt\u0026#39;,mode=\u0026#39;a\u0026#39;) f.write(\u0026#34;⿊黑姑娘 北北京 168 48\\n\u0026#34;) # 会追加到⽂文件尾部 f.close() 2.5 循环⽂文件 #\rf = open(file=\u0026#39;兼职⽩白领学⽣生空姐模特护⼠士联系⽅方式.txt\u0026#39;,mode=\u0026#39;r\u0026#39;) for line in f: line = line.split() name,addr,height,weight,phone = line height = int(height) weight = int(weight) if height \u0026gt; 170 and weight \u0026lt;= 50: # 只打印身⾼高\u0026gt;170 and 体重\u0026lt;=50的 print(line) f.close() 2.6 ⼆二进制模式操作⽂文件 #\r上⾯面操作的只是⽂文本⽂文件 ，但是如果遇到视频呀、图⽚片呀，你直接打开的话会报错\n如何处理理图⽚片、视频⽂文件呢？\n可以⽤用2进制模式打开⽂文件\nrb 2进制只读模式\nwb 2进制创建模式，若⽂文件已存在，则覆盖旧⽂文件\nab 2进制追加模式，新数据会写到⽂文件末尾\n这样，你读出来的数据，就是bytes字节类型了了，当然写进去的也必须是bytes格式了\nf = open(\u0026#34;gbk_file2\u0026#34;,\u0026#34;wb\u0026#34;) f.write(\u0026#34;哈\u0026#34;.encode(\u0026#34;gbk\u0026#34;) ) # 写⼊入的⽂文本要⽤用字节类型 def mode(self) -\u0026gt; str: 返回⽂文件•打开的模式 def name(self) -\u0026gt; str: 返回⽂文件名 def fileno(self, *args, **kwargs): # real signature unknown 返回⽂文件句句柄在内核中的索引值，以后做IO多路路复⽤用时可以⽤用到 def flush(self, *args, **kwargs): # real signature unknown 把⽂文件从内存buffer⾥里里强制刷新到硬盘 def readable(self, *args, **kwargs): # real signature unknown 判断是否可读 def readline(self, *args, **kwargs): # real signature unknown 只读⼀一⾏行行，遇到\\r or \\n为⽌止 def seek(self, *args, **kwargs): # real signature unknown 把操作⽂文件的光标移到指定位置 *注意seek的⻓长度是按字节算的， 字符编码存每个字符所占的字节⻓长度不不⼀一样。 如“路路⻜飞学城” ⽤用gbk存是2个字节⼀一个字，⽤用utf-8就是3个字节，因此以gbk打开时， seek(4) 就把光标切换到了了“⻜飞”和“学”两个字中间。 但如果是utf8,seek(4)会导致，拿到了了⻜飞这个字的⼀一部分字节，打印的话会报错，因为处理理剩 下的⽂文本时发现⽤用utf8处理理不不了了了了，因为编码对不不上了了。少了了⼀一个字节 def seekable(self, *args, **kwargs): # real signature unknown 判断⽂文件是否可进⾏行行seek操作 def tell(self, *args, **kwargs): # real signature unknown 返回当前⽂文件操作光标位置 def truncate(self, *args, **kwargs): # real signature unknown 按指定⻓长度截断⽂文件 *指定⻓长度的话，就从⽂文件开头开始截断指定⻓长度，不不指定⻓长度的话，就从当前位置到⽂文件尾部 的内容全去掉。 def writable(self, *args, **kwargs): # real signature unknown 判断⽂文件是否可写 2.8 ⽂文件打开模式（混合模式） #\rw+ 写读 , 这个功能基本没什什么意义，它会创建⼀一个新⽂文件 ，写⼀一段内容，可以再把写的内容读出来， 没什什么卵卵⽤用。\nr+ 读写，能读能写,但都是写在⽂文件最后，跟追加⼀一样\na+ 追加读,⽂文件 ⼀一打开时光标会在⽂文件尾部,写的数据全会是追加的形式\n一、模块和包 #\r1.1 什什么是模块 #\r在计算机程序的开发过程中，随着程序代码越写越多，在⼀一个⽂文件⾥里里代码就会越来越⻓长，越来越不不容易易 维护。\n为了了编写可维护的代码，我们把很多代码按功能分组，分别放到不不同的⽂文件⾥里里，这样，每个⽂文件包含的 代码就相对较少，很多编程语⾔言都采⽤用这种组织代码的⽅方式。在Python中，⼀一个.py⽂文件就可以称之为 ⼀\n一个模块（Module）。\n使⽤用模块有什什么好处？\n最⼤大的好处是⼤大⼤大提⾼高了了代码的可维护性。其次，编写代码不不必从零开始。当⼀一个模块编写完毕， 就可以被其他地⽅方引⽤用。我们在编写程序的时候，也经常引⽤用其他模块，包括Python内置的模块 和来⾃自第三⽅方的模块。\n使⽤用模块还可以避免函数名和变量量名冲突。每个模块有独⽴立的命名空间，因此相同名字的函数和变量 完全可以分别存在不不同的模块中，所以，我们⾃自⼰己在编写模块时，不不必考虑名字会与其他模块冲 突\n模块分类\n模块分为三种：\n内置标准模块（⼜又称标准库）执⾏行行help(‘modules’)查看所有python⾃自带模块列列表\n第三⽅方开源模块，可通过pip install 模块名 联⽹网安装\n自定义模块\n模块导⼊入\u0026amp;调⽤用\n导⼊入模块有以下⼏几种⽅方式：\nimport module_a #导⼊入 from module import xx # 导⼊入某个模块下的某个⽅方法 or ⼦子模块 from module.xx.xx import xx as rename #导⼊入后⼀一个⽅方法后重命令 from module.xx.xx import * #导⼊入⼀一个模块下的所有⽅方法，不不建议使⽤用 module_a.xxx #调⽤ 1.2 第3⽅方开源模块安装 #\rhttps://pypi.python.org/pypi是python的开源模块库，截⽌止2020年年5.26⽇日 ，已经收录了了236,269个来 自全世界python开发者贡献的模块,⼏几乎涵盖了了你想⽤用python做的任何事情。 事实上每个python开发 者，只要注册⼀一个账号就可以往这个平台上传你⾃自⼰己的模块，这样全世界的开发者都可以容易易的下载并 使⽤用你的模块。\n那如何从这个平台上下载代码呢？\n直接在上⾯面这个⻚页⾯面上点download,下载后，解压并进⼊入⽬目录，执⾏行行以下命令完成安装\n编译源码 python setup.py build 安装源码 python setup.py install 直接通过pip安装 pip3 install paramiko #paramiko 是模块名 pip命令默认会连接在国外的python官⽅方服务器器下载，速度⽐比较慢，你还可以使⽤用国内的⾖豆瓣源，数据 会定期同步国外官⽹网，速度快好多\npip install -i http://pypi.douban.com/simple/ alex_sayhi --trusted-host pypi.douban.com #alex_sayhi是模块名 下载后，直接导⼊入使⽤用就可以，跟⾃自带的模块调⽤用⽅方法⽆无差\n1.3 什什么是包（package) #\r若你写的项⽬目较复杂，有很多代码⽂文件的话，为了了⽅方便便管理理，可以⽤用包来管理理。 ⼀一个包其实就是⼀一个⽂文 件⽬目录，你可以把属于同⼀一个业务线的代码⽂文件都放在同⼀一个包⾥里里。\n如何创建⼀一个包？ 只需要在⽬目录下创建⼀一个空的__init__.py ⽂文件 ， 这个⽬目录就变成了了包。这个⽂文件叫包的初始化⽂文件 ，⼀一般为空，当然也可以写东⻄西，当你调⽤用这个包下及其任意⼦子包的的任意模块时， 这 个__init__.py⽂文件都会先执⾏行行。\n以下 有a、b 2个包，a2是a的⼦子包，b2是b的⼦子包\n二、⼏几个常⽤用Python模块 #\r2.1 系统调⽤用OS模块 #\ros 模块提供了了很多允许你的程序与操作系统直接交互的功能 time 模块 #\r在平常的代码中，我们常常需要与时间打交道。在Python中，与时间处理理有关的模块就包括：time， datetime,calendar(很少⽤用，不不讲)，下⾯面分别来介绍。\n我们写程序时对时间的处理理可以归为以下3种：\n时间的显示，在屏幕显示、记录⽇日志等 \u0026ldquo;2022-03-04\u0026rdquo;\n时间的转换，⽐比如把字符串串格式的⽇日期转成Python中的⽇日期类型\n时间的运算，计算两个⽇日期间的差值等\n在Python中，通常有这⼏几种⽅方式来表示时间：\n时间戳（timestamp）, 表示的是从1970年年1⽉月1⽇日00:00:00开始按秒计算的偏移量量。例例⼦子： 1554864776.161901\n格式化的时间字符串串，⽐比如“2020-10-03 17:54”\n元组（struct_time）共九个元素。由于Python的time模块实现主要调⽤用C库，所以各个平台可能 有所不不同，mac上：time.struct_time(tm_year=2020, tm_mon=4, tm_mday=10, tm_hour=2, tm_min=53, tm_sec=15, tm_wday=2, tm_yday=100, tm_isdst=0)\ntime模块的常⽤用⽅方法\ntime.localtime([secs]) ：将⼀一个时间戳转换为当前时区的struct_time。若secs参数未提供， 则以当前时间为准。\ntime.gmtime([secs]) ：和localtime()⽅方法类似，gmtime()⽅方法是将⼀一个时间戳转换为UTC时区 （0时区）的struct_time。\ntime.time() ：返回当前时间的时间戳。\ntime.mktime(t) ：将⼀一个struct_time转化为时间戳。\ntime.sleep(secs) ：线程推迟指定的时间运⾏行行,单位为秒。\ntime.strftime(format[, t]) ：把⼀一个代表时间的元组或者struct_time\ntime.localtime()和time.gmtime()返回）转化为格式化的时间字符串串。如果t未指定，将传⼊入 time.localtime()。\n举例例： time.strftime(“%Y-%m-%d %X”, time.localtime()) #输出’2017-10-01 12:14:23’\ntime.strptime(string[, format]) ：把⼀一个格式化时间字符串串转化为struct_time。实际上它 和strftime()是逆操作。\n2.3 datetime模块 #\r相⽐比于time模块，datetime模块的接⼝口则更更直观、更更容易易调⽤\n我们需要记住的⽅方法仅以下⼏几个： 1.d=datetime.datetime.now() 返回当前的datetime⽇日期类型, d.timestamp(),d.today(), d.year,d.timetuple()等⽅方法可以调⽤用\n2.datetime.date.fromtimestamp(322222) 把⼀一个时间戳转为datetime⽇日期类型\n时间运算 \u0026gt;\u0026gt;\u0026gt; datetime.datetime.now() datetime.datetime(2017, 10, 1, 12, 53, 11, 821218) \u0026gt;\u0026gt;\u0026gt; datetime.datetime.now() + datetime.timedelta(4) #当前时间 +4天 datetime.datetime(2017, 10, 5, 12, 53, 35, 276589) \u0026gt;\u0026gt;\u0026gt; datetime.datetime.now() + datetime.timedelta(hours=4) #当前时间+4⼩小时 datetime.datetime(2017, 10, 1, 16, 53, 42, 876275) 2.4 random随机数 #\r程序中有很多地⽅方需要⽤用到随机字符，⽐比如登录⽹网站的随机验证码，通过random模块可以很容易易⽣生成 随机字符串\n\u0026gt;\u0026gt;\u0026gt; random.randrange(1,10) #返回1-10之间的⼀一个随机数，不不包括10 \u0026gt;\u0026gt;\u0026gt; random.randint(1,10) #返回1-10之间的⼀一个随机数，包括10 \u0026gt;\u0026gt;\u0026gt; random.randrange(0, 100, 2) #随机选取0到100间的偶数 \u0026gt;\u0026gt;\u0026gt; random.random() #返回⼀一个随机浮点数 \u0026gt;\u0026gt;\u0026gt; random.choice(\u0026#39;abce3#$@1\u0026#39;) #返回⼀一个给定数据集合中的随机字符 \u0026#39;#\u0026#39; \u0026gt;\u0026gt;\u0026gt; random.sample(\u0026#39;abcdefghij\u0026#39;,3) #从多个字符中选取特定数量量的字符 [\u0026#39;a\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;b\u0026#39;] #⽣生成随机字符串串 \u0026gt;\u0026gt;\u0026gt; import string \u0026gt;\u0026gt;\u0026gt; \u0026#39;\u0026#39;.join(random.sample(string.ascii_lowercase + string.digits, 6)) \u0026#39;4fvda1\u0026#39; #洗牌 \u0026gt;\u0026gt;\u0026gt; a [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] \u0026gt;\u0026gt;\u0026gt; random.shuffle(a) \u0026gt;\u0026gt;\u0026gt; a [3, 0, 7, 2, 1, 6, 5, 8, 9, 4] 2.5 序列列化json模块 #\r什么是Json?\nJSON(JavaScriptObject Notation, JS 对象简谱) 是⼀一种轻量量级的数据交换格式。它采⽤用完全独⽴立于编程 语⾔言的⽂文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理理想的数据交换语⾔言。 易易于 人阅读和编写，同时也易易于机器器解析和⽣生成，并有效地提升⽹网络传输效率。\nJson的作⽤用是⽤用于不不同语⾔言接⼝口间的数据交换，⽐比如你把python的list、dict直接扔给javascript, 它是解 析不不了了的。2个语⾔言互相谁也不不认识。Json就像是计算机界的英语 ，可以帮各个语⾔言之间实现数据类型 的相互转换。\n什么是序列列化？\n序列列化是指把内存⾥里里的数据类型转变成字符串串，以使其能存储到硬盘或通过⽹网络传输到远程，因为硬盘 或⽹网络传输时只能接受bytes\n为什什么要序列列化？\n你打游戏过程中，打累了了，停下来，关掉游戏、想过2天再玩，2天之后，游戏⼜又从你上次停⽌止的地⽅方继 续运⾏行行，你上次游戏的进度肯定保存在硬盘上了了，是以何种形式呢？游戏过程中产⽣生的很多临时数据是 不规律律的，可能在你关掉游戏时正好有10个列列表，3个嵌套字典的数据集合在内存⾥里里，需要存下来？你 如何存？把列列表变成⽂文件⾥里里的多⾏行行多列列形式？那嵌套字典呢？根本没法存。所以，若是有种办法可以直 接把内存数据存到硬盘上，下次程序再启动，再从硬盘上读回来，还是原来的格式的话，那是极好的。\n用于序列列化的两个模块\njson，⽤用于字符串串 和 python数据类型间进⾏行行转换\npickle，⽤用于python特有的类型 和 python的数据类型间进⾏行行转换\njson\nJson模块也提供了了四个功能：dumps、dump、loads、load，⽤用法跟pickle⼀一致\nimport json # json.dumps 将数据通过特殊的形式转换位所有程序语⾔言都认识的字符串串 j_str = json.dumps(data) # 注意json dumps⽣生成的是字符串串，不不是bytes print(j_str) #dump⼊入⽂文件 with open(\u0026#39;result.json\u0026#39;,\u0026#39;w\u0026#39;) as fp: json.dump(data,fp) #从⽂文件⾥里里load with open(\u0026#34;result.json\u0026#34;) as f: d = json.load(f) print(d) 2.6 Excel处理理模块 #\r第3⽅方开源模块,安装 #\rpip install openpyxl 2.6.1 打开⽂文件 #\r一、创建\nfrom openpyxl import Workbook # 实例例化 wb = Workbook() # 获取当前active的sheet ws = wb.active print(sheet.title) # 打印sheet表名 sheet.title = \u0026#34;salary luffy\u0026#34; # 改sheet 名 二、打开已有文件\n\u0026gt;\u0026gt;\u0026gt; from openpyxl import load_workbook \u0026gt;\u0026gt;\u0026gt; wb2 = load_workbook(\u0026#39;⽂文件名称.xlsx\u0026#39;) Python openpyxl 读取 写⼊ 修改 操作Excel #\r在openpyxl中，主要⽤到三个概念：Workbooks，Sheets， Cells。 #\rfrom openpyxl import Workbook wb = Workbook() # 抓取活动⼯作表 ws = wb.active # 数据可以直接分配给单元格 ws[\u0026#39;A1\u0026#39;] = 42 # 下⼀⾏⾏每列添加元素 ws.append([1, 2, 3]) # Python类型将⾃动转换 import datetime ws[\u0026#39;A3\u0026#39;] = datetime.datetime.now() # Save the file wb.save(\u0026#34;sample.xlsx\u0026#34;) 4.1 openpyxl 基本操作 #\r1.安装 #\rpip install openpyxl 2.打开⽂件 #\r(1) 新建\nfrom openpyxl import Workbook # 实例化 wb = Workbook() # 激活 worksheet ws = wb.active (2) 打开已有\nfrom openpyxl import load_workbook wb = load_workbook(\u0026#39;⽂件名称.xlsx\u0026#39;) 3.写⼊数据 #\r# ⽅式⼀：数据可以直接分配到单元格中(可以输⼊公式) ws[\u0026#39;A1\u0026#39;] = 42 # ⽅式⼆：可以附加⾏，从第⼀列开始附加(从最下⽅空⽩ 处，最左开始)(可以输⼊多⾏) ws.append([1, 2, 3]) # ⽅式三：Python 类型会被⾃动转换 ws[\u0026#39;A3\u0026#39;] = datetime.datetime.now().strftime(\u0026#34;%Y-%m-%d\u0026#34;) 4.创建表(sheet) #\r# ⽅式⼀：插⼊到最后(default) ws1 = wb.create_sheet(\u0026#34;Mysheet\u0026#34;) # ⽅式⼆：插⼊到最开始的位置 ws2 = wb.create_sheet(\u0026#34;Mysheet\u0026#34;, 0) 5.选择表(sheet) #\rfrom openpyxl import Workbook # 实例化 wb = Workbook() ws1 = wb.create_sheet(\u0026#34;New Title\u0026#34;) # 激活 worksheet ws = wb.active # sheet 名称可以作为 key 进⾏索引 ws3 = wb[\u0026#34;New Title\u0026#34;] ws4 = wb.get_sheet_by_name(\u0026#34;New Title\u0026#34;) print(ws3) print(ws4) 6.查看表名(sheet) #\rfrom openpyxl import Workbook # 实例化 wb = Workbook() ws1 = wb.create_sheet(\u0026#34;New Title\u0026#34;) # 显示所有表名 print(wb.sheetnames) # 遍历所有表 for sheet in wb: print(sheet.title) 7.访问单元格(cell) #\rfrom openpyxl import Workbook # 实例化 wb = Workbook() # 激活 worksheet ws = wb.active # ⽅式⼀ ws[\u0026#39;A4\u0026#39;] = \u0026#39;lucky\u0026#39; wb.save(\u0026#34;sample.xlsx\u0026#34;) #方式二 from openpyxl import Workbook # 实例化 wb = Workbook() # 激活 worksheet ws = wb.active # ⽅式⼆ ws.cell(row=4, column=2, value=\u0026#39;lucky\u0026#39;) wb.save(\u0026#34;sample.xlsx\u0026#34;) #方式三 from openpyxl import Workbook # 实例化 wb = Workbook() # 激活 worksheet ws = wb.active # ⽅式三 for i in range(1,101): for j in range(1,101): ws.cell(row=i, column=j, value=\u0026#39;lucky\u0026#39;+str(i)) wb.save(\u0026#34;sample.xlsx\u0026#34;) 多个单元格访问 #\rfrom openpyxl import Workbook # 实例化 wb = Workbook() # 激活 worksheet ws = wb.active # 通过切⽚ cell_range = ws[\u0026#39;A1\u0026#39;:\u0026#39;C2\u0026#39;] print(cell_range) 通过⾏(列) #\r# 通过⾏(列) colC = ws[\u0026#39;C\u0026#39;] col_range = ws[\u0026#39;C:D\u0026#39;] row10 = ws[10] row_range = ws[5:10] print(row_range) 通过指定范围(⾏ → ⾏) #\r# 通过指定范围(⾏ → ⾏) for row in ws.iter_rows(min_row=1, max_col=3, max_row=2): for cell in row: print(cell) 通过指定范围(列 → 列) #\r# 通过指定范围(列 → 列) for col in ws.iter_cols(min_row=1, max_col=3, max_row=2): for row in col: print(row) 遍历所有 ⽅法⼀ #\r# 遍历所有 ⽅法⼀ ws[\u0026#39;C9\u0026#39;] = \u0026#39;hello world\u0026#39; print(tuple(ws.rows)) 遍历所有 ⽅法⼆ #\r# 遍历所有 ⽅法⼆ print(tuple(ws.columns)) 保存数据 #\rwb.save(\u0026#39;⽂件名称.xlsx\u0026#39;) 获取每⼀⾏每⼀列 #\rsheet.rows为⽣成器, ⾥⾯是每⼀⾏的数据，每⼀⾏⼜由⼀ 个tuple包裹。\nsheet.columns类似，不过⾥⾯是每个tuple是每⼀列的单元格。\nfrom openpyxl import load_workbook # 实例化 wb = load_workbook(\u0026#39;lucky.xlsx\u0026#39;) sheet = wb[\u0026#39;Sheet\u0026#39;] # 因为按⾏，所以返回A1, B1, C1这样的顺序 for row in sheet.rows: for cell in row: print(cell.value) sheet.columns\nfrom openpyxl import load_workbook # 实例化 wb = load_workbook(\u0026#39;lucky.xlsx\u0026#39;) sheet = wb[\u0026#39;Sheet\u0026#39;] # A1, A2, A3这样的顺序 for column in sheet.columns: for cell in column: print(cell.value) 根据数字得到字⺟，根据字⺟得到数字 #\rfrom openpyxl.utils import get_column_letter, column_index_from_string # 根据列的数字返回字⺟ print(get_column_letter(2)) # B # 根据字⺟返回列的数字 print(column_index_from_string(\u0026#39;D\u0026#39;)) # 4 删除⼯作表 #\r# ⽅式⼀ wb.remove(sheet) # ⽅式⼆ del wb[sheet] 10.设置单元格⻛格 #\r导入包 #\rfrom openpyxl.styles import Font, colors, Alignment 字体 #\r下⾯的代码指定了 等线24号，加粗斜体，字体颜⾊ 红⾊。直 接使⽤cell的 font属性，将Font对象赋值给它。\nfrom openpyxl import load_workbook from openpyxl.styles import Font, colors, Alignment wb = load_workbook(\u0026#39;lucky.xlsx\u0026#39;) sheet = wb[\u0026#39;Sheet\u0026#39;] bold_itatic_24_font = Font(name=\u0026#39;等线\u0026#39;, size=24, italic=True, color=colors.RED, bold=True) sheet[\u0026#39;A1\u0026#39;].font = bold_itatic_24_font wb.save(\u0026#39;lucky.xlsx\u0026#39;) 对⻬⽅式 #\r也是直接使⽤cell的属性 aligment，这⾥指定垂直居中和⽔ 平居中。除了center，还可以使⽤right、left等等参数\n# 设置B1中的数据垂直居中和⽔平居中 sheet[\u0026#39;B1\u0026#39;].alignment = Alignment(horizontal=\u0026#39;center\u0026#39;, vertical=\u0026#39;center\u0026#39;) 设置⾏⾼和列宽 #\r# 第2⾏⾏⾼ sheet.row_dimensions[2].height = 40 # C列列宽 sheet.column_dimensions[\u0026#39;C\u0026#39;].width = 30 合并和拆分单元格 #\r所谓合并单元格，即以合并区域的左上⻆的那个单元格为基 准，覆盖其他单元格使之称为⼀个⼤的单元格。 相反，拆分单元格后将这个⼤单元格的值返回到原来的左上⻆位置。\n# 合并单元格， 往左上⻆写⼊数据即可 sheet.merge_cells(\u0026#39;B1:G1\u0026#39;) # 合并⼀⾏中的⼏个单元 格 sheet.merge_cells(\u0026#39;A1:C3\u0026#39;) # 合并⼀个矩形区域中的 单元格 #拆分单元格 sheet.unmerge_cells(\u0026#39;A1:C3\u0026#39;) 4.2 openpyxl⽣成2D图表 #\rfrom openpyxl import Workbook\rfrom openpyxl.chart import BarChart, Series, Reference\rfrom copy import deepcopy\rwb = Workbook(write_only=True)\rws = wb.create_sheet()\rrows = [\r(\u0026#39;Number\u0026#39;, \u0026#39;Batch 1\u0026#39;, \u0026#39;Batch 2\u0026#39;),\r(2, 10, 30),\r(3, 40, 60),\r(4, 50, 70),\r(5, 20, 10),\r(6, 10, 40),\r(7, 50, 30),\r]\rfor row in rows:\rws.append(row)\r## 创建图表 柱形图表\rchart1 = BarChart()\r# 图表类型 竖着\rchart1.type = \u0026#34;col\u0026#34;\r# 使⽤ 1 到 48 的⼀个数字来设置图表样式。\rchart1.style = 48\r## 设置标题\rchart1.title = \u0026#34;Bar Chart\u0026#34;\r## Y轴描述\rchart1.y_axis.title = \u0026#39;Test number\u0026#39;\r## X轴描述\rchart1.x_axis.title = \u0026#39;Sample length (mm)\u0026#39;\r## 数据\r# 引⽤⼯作表的单元范围，⽤作图表添加数据\rdata = Reference(ws, min_col=2, min_row=1, max_row=7, max_col=3)\r# 引⽤⼯作表的单元范围，⽤作X轴标签使⽤\rlabels = Reference(ws, min_col=1, min_row=2, max_row=7)\r# 添加被引⽤的数据到 BarChart 对象\rchart1.add_data(data, titles_from_data=True)\r# 设置类别轴的标签(也就是x轴对应标注的值为Number列的\r数据)\rchart1.set_categories(labels)\r## 图表开始位置 A10\rws.add_chart(chart1, \u0026#34;A10\u0026#34;)\r## 复制图表\rchart2 = deepcopy(chart1)\r# 使⽤ 1 到 48 的⼀个数字来设置图表样式。\rchart2.style = 11\r# 图表类型 横着\rchart2.type = \u0026#34;bar\u0026#34;\r# 图表标题\rchart2.title = \u0026#34;Horizontal Bar Chart\u0026#34;\r## 图表开始位置 G10\rws.add_chart(chart2, \u0026#34;G10\u0026#34;)\rchart3 = deepcopy(chart1)\r# 图表类型\rchart3.type = \u0026#34;col\u0026#34;\r# 使⽤ 1 到 48 的⼀个数字来设置图表样式。\rchart3.style = 12\r# 堆积\rchart3.grouping = \u0026#34;stacked\u0026#34;\r# 指定位于列和栏的⽅式。 可以是介于1-100 和100之间\r的值。 仅适⽤于2D 横条图和2D 直条图。 可读写的 Long。\rchart3.overlap = 100\rchart3.title = \u0026#39;Stacked Chart\u0026#39;\r## 图表开始位置 A27\rws.add_chart(chart3, \u0026#34;A27\u0026#34;)\rchart4 = deepcopy(chart1)\r# 图表类型\rchart4.type = \u0026#34;bar\u0026#34;\r# 使⽤ 1 到 48 的⼀个数字来设置图表样式。\rchart4.style = 13\r# 堆积\rchart4.grouping = \u0026#34;percentStacked\u0026#34;\r# 会指定位于列和栏的⽅式。 可以是介于-100 和100之间\r的值。 仅适⽤于2D 横条图和2D 直条图。 可读写的Long。\rchart4.overlap = 100\rchart4.title = \u0026#39;Percent Stacked Chart\u0026#39;\rws.add_chart(chart4, \u0026#34;G27\u0026#34;)\rwb.save(\u0026#34;bar.xlsx\u0026#34;) 4.3 openpyxl⽣成3D图表 #\rfrom openpyxl import Workbook from openpyxl.chart import Reference, Series, BarChart3D wb = Workbook() ws = wb.active rows = [ (None, 2013, 2014), (\u0026#34;Apples\u0026#34;, 5, 4), (\u0026#34;Oranges\u0026#34;, 6s, 2), (\u0026#34;Pears\u0026#34;, 8, 3) ] for row in rows: ws.append(row) # 引⽤\u0026#34;表头部分\u0026#34;单元格范围 data = Reference(ws, min_col=2, min_row=1, max_col=3, max_row=4) titles = Reference(ws, min_col=1, min_row=2, max_row=4) chart = BarChart3D() # 设置标题 chart.title = \u0026#34;3D Bar Chart\u0026#34; # 添加被引⽤的数据到 BarChart3D 对象 chart.add_data(data=data, titles_from_data=True) # 设置类别轴的标签(也就是x轴对应标注的值为Number列的 数据) chart.set_categories(titles) # 图表开始位置 E5 ws.add_chart(chart, \u0026#34;E5\u0026#34;) wb.save(\u0026#34;bar3d.xlsx\u0026#34;) 五、Python xlswriter 写⼊ 操作Excel #\rXlsxWriter是⼀个⽤来写Excel2007和xlsx⽂件格式的python模块。 它可以⽤来写⽂本、数字、公式并⽀持单元格格式化、图⽚、图表、⽂档配置、⾃动过滤等特性\n优点：功能更多、⽂档⾼保真、扩展格式类型、更快并可配 置 缺点：不能⽤来读取和修改excel⽂件\n5.1 xlswriter基本操作 #\r1.安装 xlswriter 模块 #\rpip install XlsxWriter 2.创建excel⽂件 #\r# 创建⽂件 workbook = xlsxwriter.Workbook(\u0026#34;new_excel.xlsx\u0026#34;) 3.创建sheet #\r# 创建sheet worksheet = workbook.add_worksheet(\u0026#34;first_sheet\u0026#34;) 4.写⼊数据 #\r写入文本\n# 法⼀： worksheet.write(\u0026#39;A1\u0026#39;, \u0026#39;write something\u0026#39;) # 法⼆： worksheet.write(1, 0, \u0026#39;hello world\u0026#39;) 写⼊数字 #\r# 写⼊数字 worksheet.write(0, 1, 32) worksheet.write(1, 1, 32.3) 写⼊函数 #\rworksheet.write(2, 1, \u0026#39;=sum(B1:B2)\u0026#39;) 写⼊图⽚ #\r# 插⼊图⽚ worksheet.insert_image(0, 5, \u0026#39;test.png\u0026#39;) worksheet.insert_image(0, 5, \u0026#39;test.png\u0026#39;, {\u0026#39;url\u0026#39;: \u0026#39;http://httpbin.org/\u0026#39;}) 写⼊⽇期 #\r# 写⼊⽇期 d = workbook.add_format({\u0026#39;num_format\u0026#39;: \u0026#39;yyyy mm-dd\u0026#39;}) worksheet.write(0, 2, datetime.datetime.strptime(\u0026#39;2017-09-13\u0026#39;, \u0026#39;%Y %m-%d\u0026#39;), d) 设置⾏、列属性\n# 设置⾏属性，⾏⾼设置为40 worksheet.set_row(0, 40) # 设置列属性，把A到B列宽设置为20 worksheet.set_column(\u0026#39;A:B\u0026#39;, 20) 5.⾃定义格式常⽤格式： #\r字体颜⾊：color\n字体加粗：bold\n字体⼤⼩：font_site\n⽇期格式：num_format\n超链接：url\n下划线设置：underline\n单元格颜⾊：bg_color\n边框：border\n对⻬⽅式：align\n# ⾃定义格式 f = workbook.add_format({\u0026#39;border\u0026#39;: 1, \u0026#39;font_size\u0026#39;: 13, \u0026#39;bold\u0026#39;: True, \u0026#39;align\u0026#39;: \u0026#39;center\u0026#39;,\u0026#39;bg_color\u0026#39;: \u0026#39;cccccc\u0026#39;}) worksheet.write(\u0026#39;A3\u0026#39;, \u0026#34;python excel\u0026#34;, f) worksheet.set_row(0, 40, f) worksheet.set_column(\u0026#39;A:E\u0026#39;, 20, f) 6.批量往单元格写⼊数据 #\r# 批量往单元格写⼊数据 worksheet.write_column(\u0026#39;A15\u0026#39;, [1, 2, 3, 4, 5]) # 列写⼊，从A15开始 worksheet.write_row(\u0026#39;A12\u0026#39;, [6, 7, 8, 9]) # ⾏写⼊，从A12开始 7.合并单元格写⼊ #\r# 合并单元格写⼊ worksheet.merge_range(7,5, 11, 8, \u0026#39;merge_range\u0026#39;) 5.2 xlswriter ⽣成折线图 #\r# -*- coding:utf-8 -* import xlsxwriter # 创建⼀个excel workbook = xlsxwriter.Workbook(\u0026#34;chart_line.xlsx\u0026#34;) # 创建⼀个sheet worksheet = workbook.add_worksheet() # worksheet = workbook.add_worksheet(\u0026#34;bug_analysis\u0026#34;) # ⾃定义样式，加粗 bold = workbook.add_format({\u0026#39;bold\u0026#39;: 1}) # --------1、准备数据并写⼊excel-------------- # 向excel中写⼊数据，建⽴图标时要⽤到 headings = [\u0026#39;Number\u0026#39;, \u0026#39;testA\u0026#39;, \u0026#39;testB\u0026#39;] data = [ [\u0026#39;2017-9-1\u0026#39;, \u0026#39;2017-9-2\u0026#39;, \u0026#39;2017-9-3\u0026#39;, \u0026#39;2017-9-4\u0026#39;, \u0026#39;2017-9-5\u0026#39;, \u0026#39;2017-9-6\u0026#39;], [10, 40, 50, 20, 10, 50], [30, 60, 70, 50, 40, 30], ] # 写⼊表头 worksheet.write_row(\u0026#39;A1\u0026#39;, headings, bold) # 写⼊数据 worksheet.write_column(\u0026#39;A2\u0026#39;, data[0]) worksheet.write_column(\u0026#39;B2\u0026#39;, data[1]) worksheet.write_column(\u0026#39;C2\u0026#39;, data[2]) # --------2、⽣成图表并插⼊到excel--------------- # 创建⼀个柱状图(line chart) chart_col = workbook.add_chart({\u0026#39;type\u0026#39;: \u0026#39;line\u0026#39;}) # 配置第⼀个系列数据 chart_col.add_series({ # 这⾥的sheet1是默认的值，因为我们在新建sheet 时没有指定sheet名 # 如果我们新建sheet时设置了sheet名，这⾥就要设 置成相应的值 \u0026#39;name\u0026#39;: \u0026#39;=Sheet1!$B$1\u0026#39;, \u0026#39;categories\u0026#39;: \u0026#39;=Sheet1!$A$2:$A$7\u0026#39;, \u0026#39;values\u0026#39;: \u0026#39;=Sheet1!$B$2:$B$7\u0026#39;, \u0026#39;line\u0026#39;: {\u0026#39;color\u0026#39;: \u0026#39;red\u0026#39;}, # 配置第⼆个系列数据 chart_col.add_series({ \u0026#39;name\u0026#39;: \u0026#39;=Sheet1!$C$1\u0026#39;, \u0026#39;categories\u0026#39;: \u0026#39;=Sheet1!$A$2:$A$7\u0026#39;, \u0026#39;values\u0026#39;: \u0026#39;=Sheet1!$C$2:$C$7\u0026#39;, \u0026#39;line\u0026#39;: {\u0026#39;color\u0026#39;: \u0026#39;yellow\u0026#39;},}) # 设置图表的title 和 x，y轴信息 chart_col.set_title({\u0026#39;name\u0026#39;: \u0026#39;The xxx site Bug Analysis\u0026#39;}) chart_col.set_x_axis({\u0026#39;name\u0026#39;: \u0026#39;Test number\u0026#39;}) chart_col.set_y_axis({\u0026#39;name\u0026#39;: \u0026#39;Sample length (mm)\u0026#39;}) # 设置图表的⻛格 chart_col.set_style(1) # 把图表插⼊到worksheet并设置偏移 worksheet.insert_chart(\u0026#39;A10\u0026#39;, chart_col, {\u0026#39;x_offset\u0026#39;: 25, \u0026#39;y_offset\u0026#39;: 10}) workbook.close() 5.3 xlswriter ⽣成柱状图 #\r# -*- coding:utf-8 -* import xlsxwriter # 创建⼀个excel workbook = xlsxwriter.Workbook(\u0026#34;chart_column.xlsx\u0026#34;) # 创建⼀个sheet worksheet = workbook.add_worksheet() # worksheet = workbook.add_worksheet(\u0026#34;bug_analysis\u0026#34;) # ⾃定义样式，加粗 bold = workbook.add_format({\u0026#39;bold\u0026#39;: 1}) # --------1、准备数据并写⼊excel-------------- # 向excel中写⼊数据，建⽴图标时要⽤到 headings = [\u0026#39;Number\u0026#39;, \u0026#39;testA\u0026#39;, \u0026#39;testB\u0026#39;] data = [ [\u0026#39;2017-9-1\u0026#39;, \u0026#39;2017-9-2\u0026#39;, \u0026#39;2017-9-3\u0026#39;, \u0026#39;2017-9-4\u0026#39;, \u0026#39;2017-9-5\u0026#39;, \u0026#39;2017-9-6\u0026#39;], [10, 40, 50, 20, 10, 50], [30, 60, 70, 50, 40, 30], ] # 写⼊表头 worksheet.write_row(\u0026#39;A1\u0026#39;, headings, bold) # 写⼊数据 worksheet.write_column(\u0026#39;A2\u0026#39;, data[0]) worksheet.write_column(\u0026#39;B2\u0026#39;, data[1]) worksheet.write_column(\u0026#39;C2\u0026#39;, data[2]) # --------2、⽣成图表并插⼊到excel--------------- # 创建⼀个柱状图(column chart) chart_col = workbook.add_chart({\u0026#39;type\u0026#39;: \u0026#39;column\u0026#39;}) # 配置第⼀个系列数据 chart_col.add_series({ # 这⾥的sheet1是默认的值，因为我们在新建sheet 时没有指定sheet名 # 如果我们新建sheet时设置了sheet名，这⾥就要设 置成相应的值 \u0026#39;name\u0026#39;: \u0026#39;=Sheet1!$B$1\u0026#39;, \u0026#39;categories\u0026#39;: \u0026#39;=Sheet1!$A$2:$A$7\u0026#39;, \u0026#39;values\u0026#39;: \u0026#39;=Sheet1!$B$2:$B$7\u0026#39;, \u0026#39;line\u0026#39;: {\u0026#39;color\u0026#39;: \u0026#39;red\u0026#39;}, }) # 配置第⼆个系列数据(⽤了另⼀种语法) chart_col.add_series({ \u0026#39;name\u0026#39;: \u0026#39;=Sheet1!$C$1\u0026#39;, \u0026#39;categories\u0026#39;: \u0026#39;=Sheet1!$A$2:$A$7\u0026#39;, \u0026#39;values\u0026#39;: \u0026#39;=Sheet1!$C$2:$C$7\u0026#39;, \u0026#39;line\u0026#39;: {\u0026#39;color\u0026#39;: \u0026#39;yellow\u0026#39;}, }) # 设置图表的title 和 x，y轴信息 chart_col.set_title({\u0026#39;name\u0026#39;: \u0026#39;The xxx site Bug Analysis\u0026#39;}) chart_col.set_x_axis({\u0026#39;name\u0026#39;: \u0026#39;Test number\u0026#39;}) chart_col.set_y_axis({\u0026#39;name\u0026#39;: \u0026#39;Sample length (mm)\u0026#39;}) # 设置图表的⻛格 chart_col.set_style(1) # 把图表插⼊到worksheet以及偏移 worksheet.insert_chart(\u0026#39;A10\u0026#39;, chart_col, {\u0026#39;x_offset\u0026#39;: 25, \u0026#39;y_offset\u0026#39;: 10}) workbook.close() 5.4 xlswriter ⽣成饼图 #\r# -*- coding:utf-8 -* import xlsxwriter # 创建⼀个excel workbook = xlsxwriter.Workbook(\u0026#34;chart_pie.xlsx\u0026#34;) # 创建⼀个sheet worksheet = workbook.add_worksheet() # ⾃定义样式，加粗 bold = workbook.add_format({\u0026#39;bold\u0026#39;: 1}) # --------1、准备数据并写⼊excel-------------- # 向excel中写⼊数据，建⽴图标时要⽤到 data = [ [\u0026#39;closed\u0026#39;, \u0026#39;active\u0026#39;, \u0026#39;reopen\u0026#39;, \u0026#39;NT\u0026#39;], [1012, 109, 123, 131], ] # 写⼊数据 worksheet.write_row(\u0026#39;A1\u0026#39;, data[0], bold) worksheet.write_row(\u0026#39;A2\u0026#39;, data[1]) # --------2、⽣成图表并插⼊到excel--------------- # 创建⼀个柱状图(pie chart) chart_col = workbook.add_chart({\u0026#39;type\u0026#39;: \u0026#39;pie\u0026#39;}) # 配置第⼀个系列数据 chart_col.add_series({ \u0026#39;name\u0026#39;: \u0026#39;Bug Analysis\u0026#39;, \u0026#39;categories\u0026#39;: \u0026#39;=Sheet1!$A$1:$D$1\u0026#39;, \u0026#39;values\u0026#39;: \u0026#39;=Sheet1!$A$2:$D$2\u0026#39;, \u0026#39;points\u0026#39;: [ {\u0026#39;fill\u0026#39;: {\u0026#39;color\u0026#39;: \u0026#39;#00CD00\u0026#39;}}, {\u0026#39;fill\u0026#39;: {\u0026#39;color\u0026#39;: \u0026#39;red\u0026#39;}}, {\u0026#39;fill\u0026#39;: {\u0026#39;color\u0026#39;: \u0026#39;yellow\u0026#39;}}, {\u0026#39;fill\u0026#39;: {\u0026#39;color\u0026#39;: \u0026#39;gray\u0026#39;}}, ], # 设置图表的title 和 x，y轴信息 chart_col.set_title({\u0026#39;name\u0026#39;: \u0026#39;Bug Analysis\u0026#39;}) # 设置图表的⻛格 chart_col.set_style(10 # 把图表插⼊到worksheet以及偏移 worksheet.insert_chart(\u0026#39;B10\u0026#39;, chart_col, {\u0026#39;x_offset\u0026#39;: 25, \u0026#39;y_offset\u0026#39;: 10}) workbook.close() ","date":"2024-09-20","externalUrl":null,"permalink":"/all/python/excel%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%ACpython/","section":"Alls","summary":"文件操作 # 2.1 python操作⽂文件流程 # f=open(filename) # 打开⽂文件 f.w","title":"excel自动化办公","type":"all"},{"content":"\r文件操作 #\r2.1 python操作⽂文件流程 #\rf=open(filename) # 打开⽂文件 f.write(\u0026#34;我是野⽣生程序员\u0026#34;) # 写操作 f.read() #读操作 f.close() #保存并关闭 文件打开模式（⽂文本模式）\nr 只读模式\nw 创建模式，若⽂文件已存在，则覆盖旧⽂文件\na 追加模式，新数据会写到⽂文件末尾\n2.2 创建⽂文件 #\rf = open(file=\u0026#39;D:/⼯工作⽇日常/staff.txt\u0026#39;,mode=\u0026#39;w\u0026#39;) # 若⽂文件已存在，则覆盖 f.write(\u0026#34;Alex CEO 600\\n\u0026#34;) f.write(\u0026#34;⿊黑姑娘 ⾏行行政 5000\\n\u0026#34;) f.close() 2.3 只读模式 #\rf = open(file=\u0026#39;兼职⽩白领学⽣生空姐模特护⼠士联系⽅方式.txt\u0026#39;,mode=\u0026#39;r\u0026#39;) print(f.readline()) # 读⼀一⾏行行 print(\u0026#39;------分隔符-------\u0026#39;) data = f.read() # 读所有，剩下的所有 print(data) f.close() 2.4 追加模式 #\rf = open(file=\u0026#39;兼职⽩白领学⽣生空姐模特护⼠士联系⽅方式.txt\u0026#39;,mode=\u0026#39;a\u0026#39;) f.write(\u0026#34;⿊黑姑娘 北北京 168 48\\n\u0026#34;) # 会追加到⽂文件尾部 f.close() 2.5 循环⽂文件 #\rf = open(file=\u0026#39;兼职⽩白领学⽣生空姐模特护⼠士联系⽅方式.txt\u0026#39;,mode=\u0026#39;r\u0026#39;) for line in f: line = line.split() name,addr,height,weight,phone = line height = int(height) weight = int(weight) if height \u0026gt; 170 and weight \u0026lt;= 50: # 只打印身⾼高\u0026gt;170 and 体重\u0026lt;=50的 print(line) f.close() 2.6 ⼆二进制模式操作⽂文件 #\r上⾯面操作的只是⽂文本⽂文件 ，但是如果遇到视频呀、图⽚片呀，你直接打开的话会报错\n如何处理理图⽚片、视频⽂文件呢？\n可以⽤用2进制模式打开⽂文件\nrb 2进制只读模式\nwb 2进制创建模式，若⽂文件已存在，则覆盖旧⽂文件\nab 2进制追加模式，新数据会写到⽂文件末尾\n这样，你读出来的数据，就是bytes字节类型了了，当然写进去的也必须是bytes格式了\nf = open(\u0026#34;gbk_file2\u0026#34;,\u0026#34;wb\u0026#34;) f.write(\u0026#34;哈\u0026#34;.encode(\u0026#34;gbk\u0026#34;) ) # 写⼊入的⽂文本要⽤用字节类型 def mode(self) -\u0026gt; str: 返回⽂文件•打开的模式 def name(self) -\u0026gt; str: 返回⽂文件名 def fileno(self, *args, **kwargs): # real signature unknown 返回⽂文件句句柄在内核中的索引值，以后做IO多路路复⽤用时可以⽤用到 def flush(self, *args, **kwargs): # real signature unknown 把⽂文件从内存buffer⾥里里强制刷新到硬盘 def readable(self, *args, **kwargs): # real signature unknown 判断是否可读 def readline(self, *args, **kwargs): # real signature unknown 只读⼀一⾏行行，遇到\\r or \\n为⽌止 def seek(self, *args, **kwargs): # real signature unknown 把操作⽂文件的光标移到指定位置 *注意seek的⻓长度是按字节算的， 字符编码存每个字符所占的字节⻓长度不不⼀一样。 如“路路⻜飞学城” ⽤用gbk存是2个字节⼀一个字，⽤用utf-8就是3个字节，因此以gbk打开时， seek(4) 就把光标切换到了了“⻜飞”和“学”两个字中间。 但如果是utf8,seek(4)会导致，拿到了了⻜飞这个字的⼀一部分字节，打印的话会报错，因为处理理剩 下的⽂文本时发现⽤用utf8处理理不不了了了了，因为编码对不不上了了。少了了⼀一个字节 def seekable(self, *args, **kwargs): # real signature unknown 判断⽂文件是否可进⾏行行seek操作 def tell(self, *args, **kwargs): # real signature unknown 返回当前⽂文件操作光标位置 def truncate(self, *args, **kwargs): # real signature unknown 按指定⻓长度截断⽂文件 *指定⻓长度的话，就从⽂文件开头开始截断指定⻓长度，不不指定⻓长度的话，就从当前位置到⽂文件尾部 的内容全去掉。 def writable(self, *args, **kwargs): # real signature unknown 判断⽂文件是否可写 2.8 ⽂文件打开模式（混合模式） #\rw+ 写读 , 这个功能基本没什什么意义，它会创建⼀一个新⽂文件 ，写⼀一段内容，可以再把写的内容读出来， 没什什么卵卵⽤用。\nr+ 读写，能读能写,但都是写在⽂文件最后，跟追加⼀一样\na+ 追加读,⽂文件 ⼀一打开时光标会在⽂文件尾部,写的数据全会是追加的形式\n一、模块和包 #\r1.1 什什么是模块 #\r在计算机程序的开发过程中，随着程序代码越写越多，在⼀一个⽂文件⾥里里代码就会越来越⻓长，越来越不不容易易 维护。\n为了了编写可维护的代码，我们把很多代码按功能分组，分别放到不不同的⽂文件⾥里里，这样，每个⽂文件包含的 代码就相对较少，很多编程语⾔言都采⽤用这种组织代码的⽅方式。在Python中，⼀一个.py⽂文件就可以称之为 ⼀\n一个模块（Module）。\n使⽤用模块有什什么好处？\n最⼤大的好处是⼤大⼤大提⾼高了了代码的可维护性。其次，编写代码不不必从零开始。当⼀一个模块编写完毕， 就可以被其他地⽅方引⽤用。我们在编写程序的时候，也经常引⽤用其他模块，包括Python内置的模块 和来⾃自第三⽅方的模块。\n使⽤用模块还可以避免函数名和变量量名冲突。每个模块有独⽴立的命名空间，因此相同名字的函数和变量 完全可以分别存在不不同的模块中，所以，我们⾃自⼰己在编写模块时，不不必考虑名字会与其他模块冲 突\n模块分类\n模块分为三种：\n内置标准模块（⼜又称标准库）执⾏行行help(‘modules’)查看所有python⾃自带模块列列表\n第三⽅方开源模块，可通过pip install 模块名 联⽹网安装\n自定义模块\n模块导⼊入\u0026amp;调⽤用\n导⼊入模块有以下⼏几种⽅方式：\nimport module_a #导⼊入 from module import xx # 导⼊入某个模块下的某个⽅方法 or ⼦子模块 from module.xx.xx import xx as rename #导⼊入后⼀一个⽅方法后重命令 from module.xx.xx import * #导⼊入⼀一个模块下的所有⽅方法，不不建议使⽤用 module_a.xxx #调⽤ 1.2 第3⽅方开源模块安装 #\rhttps://pypi.python.org/pypi是python的开源模块库，截⽌止2020年年5.26⽇日 ，已经收录了了236,269个来 自全世界python开发者贡献的模块,⼏几乎涵盖了了你想⽤用python做的任何事情。 事实上每个python开发 者，只要注册⼀一个账号就可以往这个平台上传你⾃自⼰己的模块，这样全世界的开发者都可以容易易的下载并 使⽤用你的模块。\n那如何从这个平台上下载代码呢？\n直接在上⾯面这个⻚页⾯面上点download,下载后，解压并进⼊入⽬目录，执⾏行行以下命令完成安装\n编译源码 python setup.py build 安装源码 python setup.py install 直接通过pip安装 pip3 install paramiko #paramiko 是模块名 pip命令默认会连接在国外的python官⽅方服务器器下载，速度⽐比较慢，你还可以使⽤用国内的⾖豆瓣源，数据 会定期同步国外官⽹网，速度快好多\npip install -i http://pypi.douban.com/simple/ alex_sayhi --trusted-host pypi.douban.com #alex_sayhi是模块名 下载后，直接导⼊入使⽤用就可以，跟⾃自带的模块调⽤用⽅方法⽆无差\n1.3 什什么是包（package) #\r若你写的项⽬目较复杂，有很多代码⽂文件的话，为了了⽅方便便管理理，可以⽤用包来管理理。 ⼀一个包其实就是⼀一个⽂文 件⽬目录，你可以把属于同⼀一个业务线的代码⽂文件都放在同⼀一个包⾥里里。\n如何创建⼀一个包？ 只需要在⽬目录下创建⼀一个空的__init__.py ⽂文件 ， 这个⽬目录就变成了了包。这个⽂文件叫包的初始化⽂文件 ，⼀一般为空，当然也可以写东⻄西，当你调⽤用这个包下及其任意⼦子包的的任意模块时， 这 个__init__.py⽂文件都会先执⾏行行。\n以下 有a、b 2个包，a2是a的⼦子包，b2是b的⼦子包\n二、⼏几个常⽤用Python模块 #\r2.1 系统调⽤用OS模块 #\ros 模块提供了了很多允许你的程序与操作系统直接交互的功能 time 模块 #\r在平常的代码中，我们常常需要与时间打交道。在Python中，与时间处理理有关的模块就包括：time， datetime,calendar(很少⽤用，不不讲)，下⾯面分别来介绍。\n我们写程序时对时间的处理理可以归为以下3种：\n时间的显示，在屏幕显示、记录⽇日志等 \u0026ldquo;2022-03-04\u0026rdquo;\n时间的转换，⽐比如把字符串串格式的⽇日期转成Python中的⽇日期类型\n时间的运算，计算两个⽇日期间的差值等\n在Python中，通常有这⼏几种⽅方式来表示时间：\n时间戳（timestamp）, 表示的是从1970年年1⽉月1⽇日00:00:00开始按秒计算的偏移量量。例例⼦子： 1554864776.161901\n格式化的时间字符串串，⽐比如“2020-10-03 17:54”\n元组（struct_time）共九个元素。由于Python的time模块实现主要调⽤用C库，所以各个平台可能 有所不不同，mac上：time.struct_time(tm_year=2020, tm_mon=4, tm_mday=10, tm_hour=2, tm_min=53, tm_sec=15, tm_wday=2, tm_yday=100, tm_isdst=0)\ntime模块的常⽤用⽅方法\ntime.localtime([secs]) ：将⼀一个时间戳转换为当前时区的struct_time。若secs参数未提供， 则以当前时间为准。\ntime.gmtime([secs]) ：和localtime()⽅方法类似，gmtime()⽅方法是将⼀一个时间戳转换为UTC时区 （0时区）的struct_time。\ntime.time() ：返回当前时间的时间戳。\ntime.mktime(t) ：将⼀一个struct_time转化为时间戳。\ntime.sleep(secs) ：线程推迟指定的时间运⾏行行,单位为秒。\ntime.strftime(format[, t]) ：把⼀一个代表时间的元组或者struct_time\ntime.localtime()和time.gmtime()返回）转化为格式化的时间字符串串。如果t未指定，将传⼊入 time.localtime()。\n举例例： time.strftime(“%Y-%m-%d %X”, time.localtime()) #输出’2017-10-01 12:14:23’\ntime.strptime(string[, format]) ：把⼀一个格式化时间字符串串转化为struct_time。实际上它 和strftime()是逆操作。\n2.3 datetime模块 #\r相⽐比于time模块，datetime模块的接⼝口则更更直观、更更容易易调⽤\n我们需要记住的⽅方法仅以下⼏几个： 1.d=datetime.datetime.now() 返回当前的datetime⽇日期类型, d.timestamp(),d.today(), d.year,d.timetuple()等⽅方法可以调⽤用\n2.datetime.date.fromtimestamp(322222) 把⼀一个时间戳转为datetime⽇日期类型\n时间运算 \u0026gt;\u0026gt;\u0026gt; datetime.datetime.now() datetime.datetime(2017, 10, 1, 12, 53, 11, 821218) \u0026gt;\u0026gt;\u0026gt; datetime.datetime.now() + datetime.timedelta(4) #当前时间 +4天 datetime.datetime(2017, 10, 5, 12, 53, 35, 276589) \u0026gt;\u0026gt;\u0026gt; datetime.datetime.now() + datetime.timedelta(hours=4) #当前时间+4⼩小时 datetime.datetime(2017, 10, 1, 16, 53, 42, 876275) 2.4 random随机数 #\r程序中有很多地⽅方需要⽤用到随机字符，⽐比如登录⽹网站的随机验证码，通过random模块可以很容易易⽣生成 随机字符串\n\u0026gt;\u0026gt;\u0026gt; random.randrange(1,10) #返回1-10之间的⼀一个随机数，不不包括10 \u0026gt;\u0026gt;\u0026gt; random.randint(1,10) #返回1-10之间的⼀一个随机数，包括10 \u0026gt;\u0026gt;\u0026gt; random.randrange(0, 100, 2) #随机选取0到100间的偶数 \u0026gt;\u0026gt;\u0026gt; random.random() #返回⼀一个随机浮点数 \u0026gt;\u0026gt;\u0026gt; random.choice(\u0026#39;abce3#$@1\u0026#39;) #返回⼀一个给定数据集合中的随机字符 \u0026#39;#\u0026#39; \u0026gt;\u0026gt;\u0026gt; random.sample(\u0026#39;abcdefghij\u0026#39;,3) #从多个字符中选取特定数量量的字符 [\u0026#39;a\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;b\u0026#39;] #⽣生成随机字符串串 \u0026gt;\u0026gt;\u0026gt; import string \u0026gt;\u0026gt;\u0026gt; \u0026#39;\u0026#39;.join(random.sample(string.ascii_lowercase + string.digits, 6)) \u0026#39;4fvda1\u0026#39; #洗牌 \u0026gt;\u0026gt;\u0026gt; a [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] \u0026gt;\u0026gt;\u0026gt; random.shuffle(a) \u0026gt;\u0026gt;\u0026gt; a [3, 0, 7, 2, 1, 6, 5, 8, 9, 4] 2.5 序列列化json模块 #\r什么是Json?\nJSON(JavaScriptObject Notation, JS 对象简谱) 是⼀一种轻量量级的数据交换格式。它采⽤用完全独⽴立于编程 语⾔言的⽂文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理理想的数据交换语⾔言。 易易于 人阅读和编写，同时也易易于机器器解析和⽣生成，并有效地提升⽹网络传输效率。\nJson的作⽤用是⽤用于不不同语⾔言接⼝口间的数据交换，⽐比如你把python的list、dict直接扔给javascript, 它是解 析不不了了的。2个语⾔言互相谁也不不认识。Json就像是计算机界的英语 ，可以帮各个语⾔言之间实现数据类型 的相互转换。\n什么是序列列化？\n序列列化是指把内存⾥里里的数据类型转变成字符串串，以使其能存储到硬盘或通过⽹网络传输到远程，因为硬盘 或⽹网络传输时只能接受bytes\n为什什么要序列列化？\n你打游戏过程中，打累了了，停下来，关掉游戏、想过2天再玩，2天之后，游戏⼜又从你上次停⽌止的地⽅方继 续运⾏行行，你上次游戏的进度肯定保存在硬盘上了了，是以何种形式呢？游戏过程中产⽣生的很多临时数据是 不规律律的，可能在你关掉游戏时正好有10个列列表，3个嵌套字典的数据集合在内存⾥里里，需要存下来？你 如何存？把列列表变成⽂文件⾥里里的多⾏行行多列列形式？那嵌套字典呢？根本没法存。所以，若是有种办法可以直 接把内存数据存到硬盘上，下次程序再启动，再从硬盘上读回来，还是原来的格式的话，那是极好的。\n用于序列列化的两个模块\njson，⽤用于字符串串 和 python数据类型间进⾏行行转换\npickle，⽤用于python特有的类型 和 python的数据类型间进⾏行行转换\njson\nJson模块也提供了了四个功能：dumps、dump、loads、load，⽤用法跟pickle⼀一致\nimport json # json.dumps 将数据通过特殊的形式转换位所有程序语⾔言都认识的字符串串 j_str = json.dumps(data) # 注意json dumps⽣生成的是字符串串，不不是bytes print(j_str) #dump⼊入⽂文件 with open(\u0026#39;result.json\u0026#39;,\u0026#39;w\u0026#39;) as fp: json.dump(data,fp) #从⽂文件⾥里里load with open(\u0026#34;result.json\u0026#34;) as f: d = json.load(f) print(d) 2.6 Excel处理理模块 #\r第3⽅方开源模块,安装 #\rpip install openpyxl 2.6.1 打开⽂文件 #\r一、创建\nfrom openpyxl import Workbook # 实例例化 wb = Workbook() # 获取当前active的sheet ws = wb.active print(sheet.title) # 打印sheet表名 sheet.title = \u0026#34;salary luffy\u0026#34; # 改sheet 名 二、打开已有文件\n\u0026gt;\u0026gt;\u0026gt; from openpyxl import load_workbook \u0026gt;\u0026gt;\u0026gt; wb2 = load_workbook(\u0026#39;⽂文件名称.xlsx\u0026#39;) Python openpyxl 读取 写⼊ 修改 操作Excel #\r在openpyxl中，主要⽤到三个概念：Workbooks，Sheets， Cells。 #\rfrom openpyxl import Workbook wb = Workbook() # 抓取活动⼯作表 ws = wb.active # 数据可以直接分配给单元格 ws[\u0026#39;A1\u0026#39;] = 42 # 下⼀⾏⾏每列添加元素 ws.append([1, 2, 3]) # Python类型将⾃动转换 import datetime ws[\u0026#39;A3\u0026#39;] = datetime.datetime.now() # Save the file wb.save(\u0026#34;sample.xlsx\u0026#34;) 4.1 openpyxl 基本操作 #\r1.安装 #\rpip install openpyxl 2.打开⽂件 #\r(1) 新建\nfrom openpyxl import Workbook # 实例化 wb = Workbook() # 激活 worksheet ws = wb.active (2) 打开已有\nfrom openpyxl import load_workbook wb = load_workbook(\u0026#39;⽂件名称.xlsx\u0026#39;) 3.写⼊数据 #\r# ⽅式⼀：数据可以直接分配到单元格中(可以输⼊公式) ws[\u0026#39;A1\u0026#39;] = 42 # ⽅式⼆：可以附加⾏，从第⼀列开始附加(从最下⽅空⽩ 处，最左开始)(可以输⼊多⾏) ws.append([1, 2, 3]) # ⽅式三：Python 类型会被⾃动转换 ws[\u0026#39;A3\u0026#39;] = datetime.datetime.now().strftime(\u0026#34;%Y-%m-%d\u0026#34;) 4.创建表(sheet) #\r# ⽅式⼀：插⼊到最后(default) ws1 = wb.create_sheet(\u0026#34;Mysheet\u0026#34;) # ⽅式⼆：插⼊到最开始的位置 ws2 = wb.create_sheet(\u0026#34;Mysheet\u0026#34;, 0) 5.选择表(sheet) #\rfrom openpyxl import Workbook # 实例化 wb = Workbook() ws1 = wb.create_sheet(\u0026#34;New Title\u0026#34;) # 激活 worksheet ws = wb.active # sheet 名称可以作为 key 进⾏索引 ws3 = wb[\u0026#34;New Title\u0026#34;] ws4 = wb.get_sheet_by_name(\u0026#34;New Title\u0026#34;) print(ws3) print(ws4) 6.查看表名(sheet) #\rfrom openpyxl import Workbook # 实例化 wb = Workbook() ws1 = wb.create_sheet(\u0026#34;New Title\u0026#34;) # 显示所有表名 print(wb.sheetnames) # 遍历所有表 for sheet in wb: print(sheet.title) 7.访问单元格(cell) #\rfrom openpyxl import Workbook # 实例化 wb = Workbook() # 激活 worksheet ws = wb.active # ⽅式⼀ ws[\u0026#39;A4\u0026#39;] = \u0026#39;lucky\u0026#39; wb.save(\u0026#34;sample.xlsx\u0026#34;) #方式二 from openpyxl import Workbook # 实例化 wb = Workbook() # 激活 worksheet ws = wb.active # ⽅式⼆ ws.cell(row=4, column=2, value=\u0026#39;lucky\u0026#39;) wb.save(\u0026#34;sample.xlsx\u0026#34;) #方式三 from openpyxl import Workbook # 实例化 wb = Workbook() # 激活 worksheet ws = wb.active # ⽅式三 for i in range(1,101): for j in range(1,101): ws.cell(row=i, column=j, value=\u0026#39;lucky\u0026#39;+str(i)) wb.save(\u0026#34;sample.xlsx\u0026#34;) 多个单元格访问 #\rfrom openpyxl import Workbook # 实例化 wb = Workbook() # 激活 worksheet ws = wb.active # 通过切⽚ cell_range = ws[\u0026#39;A1\u0026#39;:\u0026#39;C2\u0026#39;] print(cell_range) 通过⾏(列) #\r# 通过⾏(列) colC = ws[\u0026#39;C\u0026#39;] col_range = ws[\u0026#39;C:D\u0026#39;] row10 = ws[10] row_range = ws[5:10] print(row_range) 通过指定范围(⾏ → ⾏) #\r# 通过指定范围(⾏ → ⾏) for row in ws.iter_rows(min_row=1, max_col=3, max_row=2): for cell in row: print(cell) 通过指定范围(列 → 列) #\r# 通过指定范围(列 → 列) for col in ws.iter_cols(min_row=1, max_col=3, max_row=2): for row in col: print(row) 遍历所有 ⽅法⼀ #\r# 遍历所有 ⽅法⼀ ws[\u0026#39;C9\u0026#39;] = \u0026#39;hello world\u0026#39; print(tuple(ws.rows)) 遍历所有 ⽅法⼆ #\r# 遍历所有 ⽅法⼆ print(tuple(ws.columns)) 保存数据 #\rwb.save(\u0026#39;⽂件名称.xlsx\u0026#39;) 获取每⼀⾏每⼀列 #\rsheet.rows为⽣成器, ⾥⾯是每⼀⾏的数据，每⼀⾏⼜由⼀ 个tuple包裹。\nsheet.columns类似，不过⾥⾯是每个tuple是每⼀列的单元格。\nfrom openpyxl import load_workbook # 实例化 wb = load_workbook(\u0026#39;lucky.xlsx\u0026#39;) sheet = wb[\u0026#39;Sheet\u0026#39;] # 因为按⾏，所以返回A1, B1, C1这样的顺序 for row in sheet.rows: for cell in row: print(cell.value) sheet.columns\nfrom openpyxl import load_workbook # 实例化 wb = load_workbook(\u0026#39;lucky.xlsx\u0026#39;) sheet = wb[\u0026#39;Sheet\u0026#39;] # A1, A2, A3这样的顺序 for column in sheet.columns: for cell in column: print(cell.value) 根据数字得到字⺟，根据字⺟得到数字 #\rfrom openpyxl.utils import get_column_letter, column_index_from_string # 根据列的数字返回字⺟ print(get_column_letter(2)) # B # 根据字⺟返回列的数字 print(column_index_from_string(\u0026#39;D\u0026#39;)) # 4 删除⼯作表 #\r# ⽅式⼀ wb.remove(sheet) # ⽅式⼆ del wb[sheet] 10.设置单元格⻛格 #\r导入包 #\rfrom openpyxl.styles import Font, colors, Alignment 字体 #\r下⾯的代码指定了 等线24号，加粗斜体，字体颜⾊ 红⾊。直 接使⽤cell的 font属性，将Font对象赋值给它。\nfrom openpyxl import load_workbook from openpyxl.styles import Font, colors, Alignment wb = load_workbook(\u0026#39;lucky.xlsx\u0026#39;) sheet = wb[\u0026#39;Sheet\u0026#39;] bold_itatic_24_font = Font(name=\u0026#39;等线\u0026#39;, size=24, italic=True, color=colors.RED, bold=True) sheet[\u0026#39;A1\u0026#39;].font = bold_itatic_24_font wb.save(\u0026#39;lucky.xlsx\u0026#39;) 对⻬⽅式 #\r也是直接使⽤cell的属性 aligment，这⾥指定垂直居中和⽔ 平居中。除了center，还可以使⽤right、left等等参数\n# 设置B1中的数据垂直居中和⽔平居中 sheet[\u0026#39;B1\u0026#39;].alignment = Alignment(horizontal=\u0026#39;center\u0026#39;, vertical=\u0026#39;center\u0026#39;) 设置⾏⾼和列宽 #\r# 第2⾏⾏⾼ sheet.row_dimensions[2].height = 40 # C列列宽 sheet.column_dimensions[\u0026#39;C\u0026#39;].width = 30 合并和拆分单元格 #\r所谓合并单元格，即以合并区域的左上⻆的那个单元格为基 准，覆盖其他单元格使之称为⼀个⼤的单元格。 相反，拆分单元格后将这个⼤单元格的值返回到原来的左上⻆位置。\n# 合并单元格， 往左上⻆写⼊数据即可 sheet.merge_cells(\u0026#39;B1:G1\u0026#39;) # 合并⼀⾏中的⼏个单元 格 sheet.merge_cells(\u0026#39;A1:C3\u0026#39;) # 合并⼀个矩形区域中的 单元格 #拆分单元格 sheet.unmerge_cells(\u0026#39;A1:C3\u0026#39;) 4.2 openpyxl⽣成2D图表 #\rfrom openpyxl import Workbook\rfrom openpyxl.chart import BarChart, Series, Reference\rfrom copy import deepcopy\rwb = Workbook(write_only=True)\rws = wb.create_sheet()\rrows = [\r(\u0026#39;Number\u0026#39;, \u0026#39;Batch 1\u0026#39;, \u0026#39;Batch 2\u0026#39;),\r(2, 10, 30),\r(3, 40, 60),\r(4, 50, 70),\r(5, 20, 10),\r(6, 10, 40),\r(7, 50, 30),\r]\rfor row in rows:\rws.append(row)\r## 创建图表 柱形图表\rchart1 = BarChart()\r# 图表类型 竖着\rchart1.type = \u0026#34;col\u0026#34;\r# 使⽤ 1 到 48 的⼀个数字来设置图表样式。\rchart1.style = 48\r## 设置标题\rchart1.title = \u0026#34;Bar Chart\u0026#34;\r## Y轴描述\rchart1.y_axis.title = \u0026#39;Test number\u0026#39;\r## X轴描述\rchart1.x_axis.title = \u0026#39;Sample length (mm)\u0026#39;\r## 数据\r# 引⽤⼯作表的单元范围，⽤作图表添加数据\rdata = Reference(ws, min_col=2, min_row=1, max_row=7, max_col=3)\r# 引⽤⼯作表的单元范围，⽤作X轴标签使⽤\rlabels = Reference(ws, min_col=1, min_row=2, max_row=7)\r# 添加被引⽤的数据到 BarChart 对象\rchart1.add_data(data, titles_from_data=True)\r# 设置类别轴的标签(也就是x轴对应标注的值为Number列的\r数据)\rchart1.set_categories(labels)\r## 图表开始位置 A10\rws.add_chart(chart1, \u0026#34;A10\u0026#34;)\r## 复制图表\rchart2 = deepcopy(chart1)\r# 使⽤ 1 到 48 的⼀个数字来设置图表样式。\rchart2.style = 11\r# 图表类型 横着\rchart2.type = \u0026#34;bar\u0026#34;\r# 图表标题\rchart2.title = \u0026#34;Horizontal Bar Chart\u0026#34;\r## 图表开始位置 G10\rws.add_chart(chart2, \u0026#34;G10\u0026#34;)\rchart3 = deepcopy(chart1)\r# 图表类型\rchart3.type = \u0026#34;col\u0026#34;\r# 使⽤ 1 到 48 的⼀个数字来设置图表样式。\rchart3.style = 12\r# 堆积\rchart3.grouping = \u0026#34;stacked\u0026#34;\r# 指定位于列和栏的⽅式。 可以是介于1-100 和100之间\r的值。 仅适⽤于2D 横条图和2D 直条图。 可读写的 Long。\rchart3.overlap = 100\rchart3.title = \u0026#39;Stacked Chart\u0026#39;\r## 图表开始位置 A27\rws.add_chart(chart3, \u0026#34;A27\u0026#34;)\rchart4 = deepcopy(chart1)\r# 图表类型\rchart4.type = \u0026#34;bar\u0026#34;\r# 使⽤ 1 到 48 的⼀个数字来设置图表样式。\rchart4.style = 13\r# 堆积\rchart4.grouping = \u0026#34;percentStacked\u0026#34;\r# 会指定位于列和栏的⽅式。 可以是介于-100 和100之间\r的值。 仅适⽤于2D 横条图和2D 直条图。 可读写的Long。\rchart4.overlap = 100\rchart4.title = \u0026#39;Percent Stacked Chart\u0026#39;\rws.add_chart(chart4, \u0026#34;G27\u0026#34;)\rwb.save(\u0026#34;bar.xlsx\u0026#34;) 4.3 openpyxl⽣成3D图表 #\rfrom openpyxl import Workbook from openpyxl.chart import Reference, Series, BarChart3D wb = Workbook() ws = wb.active rows = [ (None, 2013, 2014), (\u0026#34;Apples\u0026#34;, 5, 4), (\u0026#34;Oranges\u0026#34;, 6s, 2), (\u0026#34;Pears\u0026#34;, 8, 3) ] for row in rows: ws.append(row) # 引⽤\u0026#34;表头部分\u0026#34;单元格范围 data = Reference(ws, min_col=2, min_row=1, max_col=3, max_row=4) titles = Reference(ws, min_col=1, min_row=2, max_row=4) chart = BarChart3D() # 设置标题 chart.title = \u0026#34;3D Bar Chart\u0026#34; # 添加被引⽤的数据到 BarChart3D 对象 chart.add_data(data=data, titles_from_data=True) # 设置类别轴的标签(也就是x轴对应标注的值为Number列的 数据) chart.set_categories(titles) # 图表开始位置 E5 ws.add_chart(chart, \u0026#34;E5\u0026#34;) wb.save(\u0026#34;bar3d.xlsx\u0026#34;) 五、Python xlswriter 写⼊ 操作Excel #\rXlsxWriter是⼀个⽤来写Excel2007和xlsx⽂件格式的python模块。 它可以⽤来写⽂本、数字、公式并⽀持单元格格式化、图⽚、图表、⽂档配置、⾃动过滤等特性\n优点：功能更多、⽂档⾼保真、扩展格式类型、更快并可配 置 缺点：不能⽤来读取和修改excel⽂件\n5.1 xlswriter基本操作 #\r1.安装 xlswriter 模块 #\rpip install XlsxWriter 2.创建excel⽂件 #\r# 创建⽂件 workbook = xlsxwriter.Workbook(\u0026#34;new_excel.xlsx\u0026#34;) 3.创建sheet #\r# 创建sheet worksheet = workbook.add_worksheet(\u0026#34;first_sheet\u0026#34;) 4.写⼊数据 #\r写入文本\n# 法⼀： worksheet.write(\u0026#39;A1\u0026#39;, \u0026#39;write something\u0026#39;) # 法⼆： worksheet.write(1, 0, \u0026#39;hello world\u0026#39;) 写⼊数字 #\r# 写⼊数字 worksheet.write(0, 1, 32) worksheet.write(1, 1, 32.3) 写⼊函数 #\rworksheet.write(2, 1, \u0026#39;=sum(B1:B2)\u0026#39;) 写⼊图⽚ #\r# 插⼊图⽚ worksheet.insert_image(0, 5, \u0026#39;test.png\u0026#39;) worksheet.insert_image(0, 5, \u0026#39;test.png\u0026#39;, {\u0026#39;url\u0026#39;: \u0026#39;http://httpbin.org/\u0026#39;}) 写⼊⽇期 #\r# 写⼊⽇期 d = workbook.add_format({\u0026#39;num_format\u0026#39;: \u0026#39;yyyy mm-dd\u0026#39;}) worksheet.write(0, 2, datetime.datetime.strptime(\u0026#39;2017-09-13\u0026#39;, \u0026#39;%Y %m-%d\u0026#39;), d) 设置⾏、列属性\n# 设置⾏属性，⾏⾼设置为40 worksheet.set_row(0, 40) # 设置列属性，把A到B列宽设置为20 worksheet.set_column(\u0026#39;A:B\u0026#39;, 20) 5.⾃定义格式常⽤格式： #\r字体颜⾊：color\n字体加粗：bold\n字体⼤⼩：font_site\n⽇期格式：num_format\n超链接：url\n下划线设置：underline\n单元格颜⾊：bg_color\n边框：border\n对⻬⽅式：align\n# ⾃定义格式 f = workbook.add_format({\u0026#39;border\u0026#39;: 1, \u0026#39;font_size\u0026#39;: 13, \u0026#39;bold\u0026#39;: True, \u0026#39;align\u0026#39;: \u0026#39;center\u0026#39;,\u0026#39;bg_color\u0026#39;: \u0026#39;cccccc\u0026#39;}) worksheet.write(\u0026#39;A3\u0026#39;, \u0026#34;python excel\u0026#34;, f) worksheet.set_row(0, 40, f) worksheet.set_column(\u0026#39;A:E\u0026#39;, 20, f) 6.批量往单元格写⼊数据 #\r# 批量往单元格写⼊数据 worksheet.write_column(\u0026#39;A15\u0026#39;, [1, 2, 3, 4, 5]) # 列写⼊，从A15开始 worksheet.write_row(\u0026#39;A12\u0026#39;, [6, 7, 8, 9]) # ⾏写⼊，从A12开始 7.合并单元格写⼊ #\r# 合并单元格写⼊ worksheet.merge_range(7,5, 11, 8, \u0026#39;merge_range\u0026#39;) 5.2 xlswriter ⽣成折线图 #\r# -*- coding:utf-8 -* import xlsxwriter # 创建⼀个excel workbook = xlsxwriter.Workbook(\u0026#34;chart_line.xlsx\u0026#34;) # 创建⼀个sheet worksheet = workbook.add_worksheet() # worksheet = workbook.add_worksheet(\u0026#34;bug_analysis\u0026#34;) # ⾃定义样式，加粗 bold = workbook.add_format({\u0026#39;bold\u0026#39;: 1}) # --------1、准备数据并写⼊excel-------------- # 向excel中写⼊数据，建⽴图标时要⽤到 headings = [\u0026#39;Number\u0026#39;, \u0026#39;testA\u0026#39;, \u0026#39;testB\u0026#39;] data = [ [\u0026#39;2017-9-1\u0026#39;, \u0026#39;2017-9-2\u0026#39;, \u0026#39;2017-9-3\u0026#39;, \u0026#39;2017-9-4\u0026#39;, \u0026#39;2017-9-5\u0026#39;, \u0026#39;2017-9-6\u0026#39;], [10, 40, 50, 20, 10, 50], [30, 60, 70, 50, 40, 30], ] # 写⼊表头 worksheet.write_row(\u0026#39;A1\u0026#39;, headings, bold) # 写⼊数据 worksheet.write_column(\u0026#39;A2\u0026#39;, data[0]) worksheet.write_column(\u0026#39;B2\u0026#39;, data[1]) worksheet.write_column(\u0026#39;C2\u0026#39;, data[2]) # --------2、⽣成图表并插⼊到excel--------------- # 创建⼀个柱状图(line chart) chart_col = workbook.add_chart({\u0026#39;type\u0026#39;: \u0026#39;line\u0026#39;}) # 配置第⼀个系列数据 chart_col.add_series({ # 这⾥的sheet1是默认的值，因为我们在新建sheet 时没有指定sheet名 # 如果我们新建sheet时设置了sheet名，这⾥就要设 置成相应的值 \u0026#39;name\u0026#39;: \u0026#39;=Sheet1!$B$1\u0026#39;, \u0026#39;categories\u0026#39;: \u0026#39;=Sheet1!$A$2:$A$7\u0026#39;, \u0026#39;values\u0026#39;: \u0026#39;=Sheet1!$B$2:$B$7\u0026#39;, \u0026#39;line\u0026#39;: {\u0026#39;color\u0026#39;: \u0026#39;red\u0026#39;}, # 配置第⼆个系列数据 chart_col.add_series({ \u0026#39;name\u0026#39;: \u0026#39;=Sheet1!$C$1\u0026#39;, \u0026#39;categories\u0026#39;: \u0026#39;=Sheet1!$A$2:$A$7\u0026#39;, \u0026#39;values\u0026#39;: \u0026#39;=Sheet1!$C$2:$C$7\u0026#39;, \u0026#39;line\u0026#39;: {\u0026#39;color\u0026#39;: \u0026#39;yellow\u0026#39;},}) # 设置图表的title 和 x，y轴信息 chart_col.set_title({\u0026#39;name\u0026#39;: \u0026#39;The xxx site Bug Analysis\u0026#39;}) chart_col.set_x_axis({\u0026#39;name\u0026#39;: \u0026#39;Test number\u0026#39;}) chart_col.set_y_axis({\u0026#39;name\u0026#39;: \u0026#39;Sample length (mm)\u0026#39;}) # 设置图表的⻛格 chart_col.set_style(1) # 把图表插⼊到worksheet并设置偏移 worksheet.insert_chart(\u0026#39;A10\u0026#39;, chart_col, {\u0026#39;x_offset\u0026#39;: 25, \u0026#39;y_offset\u0026#39;: 10}) workbook.close() 5.3 xlswriter ⽣成柱状图 #\r# -*- coding:utf-8 -* import xlsxwriter # 创建⼀个excel workbook = xlsxwriter.Workbook(\u0026#34;chart_column.xlsx\u0026#34;) # 创建⼀个sheet worksheet = workbook.add_worksheet() # worksheet = workbook.add_worksheet(\u0026#34;bug_analysis\u0026#34;) # ⾃定义样式，加粗 bold = workbook.add_format({\u0026#39;bold\u0026#39;: 1}) # --------1、准备数据并写⼊excel-------------- # 向excel中写⼊数据，建⽴图标时要⽤到 headings = [\u0026#39;Number\u0026#39;, \u0026#39;testA\u0026#39;, \u0026#39;testB\u0026#39;] data = [ [\u0026#39;2017-9-1\u0026#39;, \u0026#39;2017-9-2\u0026#39;, \u0026#39;2017-9-3\u0026#39;, \u0026#39;2017-9-4\u0026#39;, \u0026#39;2017-9-5\u0026#39;, \u0026#39;2017-9-6\u0026#39;], [10, 40, 50, 20, 10, 50], [30, 60, 70, 50, 40, 30], ] # 写⼊表头 worksheet.write_row(\u0026#39;A1\u0026#39;, headings, bold) # 写⼊数据 worksheet.write_column(\u0026#39;A2\u0026#39;, data[0]) worksheet.write_column(\u0026#39;B2\u0026#39;, data[1]) worksheet.write_column(\u0026#39;C2\u0026#39;, data[2]) # --------2、⽣成图表并插⼊到excel--------------- # 创建⼀个柱状图(column chart) chart_col = workbook.add_chart({\u0026#39;type\u0026#39;: \u0026#39;column\u0026#39;}) # 配置第⼀个系列数据 chart_col.add_series({ # 这⾥的sheet1是默认的值，因为我们在新建sheet 时没有指定sheet名 # 如果我们新建sheet时设置了sheet名，这⾥就要设 置成相应的值 \u0026#39;name\u0026#39;: \u0026#39;=Sheet1!$B$1\u0026#39;, \u0026#39;categories\u0026#39;: \u0026#39;=Sheet1!$A$2:$A$7\u0026#39;, \u0026#39;values\u0026#39;: \u0026#39;=Sheet1!$B$2:$B$7\u0026#39;, \u0026#39;line\u0026#39;: {\u0026#39;color\u0026#39;: \u0026#39;red\u0026#39;}, }) # 配置第⼆个系列数据(⽤了另⼀种语法) chart_col.add_series({ \u0026#39;name\u0026#39;: \u0026#39;=Sheet1!$C$1\u0026#39;, \u0026#39;categories\u0026#39;: \u0026#39;=Sheet1!$A$2:$A$7\u0026#39;, \u0026#39;values\u0026#39;: \u0026#39;=Sheet1!$C$2:$C$7\u0026#39;, \u0026#39;line\u0026#39;: {\u0026#39;color\u0026#39;: \u0026#39;yellow\u0026#39;}, }) # 设置图表的title 和 x，y轴信息 chart_col.set_title({\u0026#39;name\u0026#39;: \u0026#39;The xxx site Bug Analysis\u0026#39;}) chart_col.set_x_axis({\u0026#39;name\u0026#39;: \u0026#39;Test number\u0026#39;}) chart_col.set_y_axis({\u0026#39;name\u0026#39;: \u0026#39;Sample length (mm)\u0026#39;}) # 设置图表的⻛格 chart_col.set_style(1) # 把图表插⼊到worksheet以及偏移 worksheet.insert_chart(\u0026#39;A10\u0026#39;, chart_col, {\u0026#39;x_offset\u0026#39;: 25, \u0026#39;y_offset\u0026#39;: 10}) workbook.close() 5.4 xlswriter ⽣成饼图 #\r# -*- coding:utf-8 -* import xlsxwriter # 创建⼀个excel workbook = xlsxwriter.Workbook(\u0026#34;chart_pie.xlsx\u0026#34;) # 创建⼀个sheet worksheet = workbook.add_worksheet() # ⾃定义样式，加粗 bold = workbook.add_format({\u0026#39;bold\u0026#39;: 1}) # --------1、准备数据并写⼊excel-------------- # 向excel中写⼊数据，建⽴图标时要⽤到 data = [ [\u0026#39;closed\u0026#39;, \u0026#39;active\u0026#39;, \u0026#39;reopen\u0026#39;, \u0026#39;NT\u0026#39;], [1012, 109, 123, 131], ] # 写⼊数据 worksheet.write_row(\u0026#39;A1\u0026#39;, data[0], bold) worksheet.write_row(\u0026#39;A2\u0026#39;, data[1]) # --------2、⽣成图表并插⼊到excel--------------- # 创建⼀个柱状图(pie chart) chart_col = workbook.add_chart({\u0026#39;type\u0026#39;: \u0026#39;pie\u0026#39;}) # 配置第⼀个系列数据 chart_col.add_series({ \u0026#39;name\u0026#39;: \u0026#39;Bug Analysis\u0026#39;, \u0026#39;categories\u0026#39;: \u0026#39;=Sheet1!$A$1:$D$1\u0026#39;, \u0026#39;values\u0026#39;: \u0026#39;=Sheet1!$A$2:$D$2\u0026#39;, \u0026#39;points\u0026#39;: [ {\u0026#39;fill\u0026#39;: {\u0026#39;color\u0026#39;: \u0026#39;#00CD00\u0026#39;}}, {\u0026#39;fill\u0026#39;: {\u0026#39;color\u0026#39;: \u0026#39;red\u0026#39;}}, {\u0026#39;fill\u0026#39;: {\u0026#39;color\u0026#39;: \u0026#39;yellow\u0026#39;}}, {\u0026#39;fill\u0026#39;: {\u0026#39;color\u0026#39;: \u0026#39;gray\u0026#39;}}, ], # 设置图表的title 和 x，y轴信息 chart_col.set_title({\u0026#39;name\u0026#39;: \u0026#39;Bug Analysis\u0026#39;}) # 设置图表的⻛格 chart_col.set_style(10 # 把图表插⼊到worksheet以及偏移 worksheet.insert_chart(\u0026#39;B10\u0026#39;, chart_col, {\u0026#39;x_offset\u0026#39;: 25, \u0026#39;y_offset\u0026#39;: 10}) workbook.close() ","date":"2024-09-20","externalUrl":null,"permalink":"/python/excel%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%ACpython/","section":"Pythons","summary":"文件操作 # 2.1 python操作⽂文件流程 # f=open(filename) # 打开⽂文件 f.w","title":"excel自动化办公","type":"python"},{"content":"","date":"2024-09-15","externalUrl":null,"permalink":"/tags/mysql/","section":"Tags","summary":"","title":"Mysql","type":"tags"},{"content":"","date":"2024-09-15","externalUrl":null,"permalink":"/mysql/","section":"MySQLs","summary":"","title":"MySQLs","type":"mysql"},{"content":"\rsql执行顺序 #\rSQL 中，查询中子句的执行顺序通常如下：\nFROM 子句：指定从中检索数据的表。\nWHERE 子句：根据指定的条件筛选行。\nGROUP BY 子句：根据指定的列或表达式对行进行分组。\nHAVING 子句：根据条件筛选分组的行。\nSELECT 子句：选择将在结果集中返回的列或表达式。\nORDER BY 子句：根据指定的列或表达式对结果集进行排序。\nLIMIT/OFFSET 子句：限制结果集中返回的行数。\n#\r（思考：left join连接两个图表，因为左边ALLEN在address表中city和state是null） select t1.firstName,t1.lastName,t2.city,t2.state from Person as t1 left join Address as t2 on t1.personId=t2.personId; 第二高的薪水 #\r(思考：offset用法：offset n 去掉几个值 offset去掉最大值，limit 1 选取第二个值作为第二高薪 select 200 as salary ) select (select distinct Salary from Employee order by Salary desc limit 1 offset 1)AS SecondHighestSalary; 第N高的薪水 #\r（思考：distinct去重重复的salary，方便查找唯一值，order by 薪资，降序排列结合limit获取第n条数据， limit 3 ：只有一个参数，表示获取前三条数据， limit 3，2；limit有两个参数，第一个参数表示从第几行数据开始查，第二个参数表示查几条数据， “limit 3,2”表示从第四行数据开始，取两条数据。 ） CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT BEGIN DECLARE M INT; SET M=N-1; RETURN ( select distinct salary from Employee order by salary desc limit M, 1 ); END 分数排名 #\rselect score, (select count(distinct s2.score) from Scores s2 where s2.score\u0026gt;=s1.score)as \u0026#39;rank\u0026#39; from Scores s1 order by s1.score desc 可回收且低脂产品 #\rselect product_id from Products where low_fats=\u0026#39;Y\u0026#39; and recyclable=\u0026#39;Y\u0026#39; ###寻找用户推荐人 MySQL 使用三值逻辑 —— TRUE, FALSE 和 UNKNOWN。任何与 NULL 值进行的比较都会与第三种值 UNKNOWN 做比较。这个“任何值”包括 NULL 本身！这就是为什么 MySQL 提供 IS NULL 和 IS NOT NULL 两种操作来对 NULL 特殊判断。 因此，在 WHERE 语句中我们需要做一个额外的条件判断 `referee_id IS NULL\u0026#39;。） select name from Customer where referee_Id !=2 or referee_Id IS NULL; 大的国家 #\rselect name,population,area from World where area\u0026gt;=3000000 or population \u0026gt;=25000000 文章浏览 #\rselect distinct viewer_id as id from Views where Views.viewer_id = Views.author_id order by id asc ###无效的推文 length：长度 select tweet_id from Tweets where length(content)\u0026gt;15 使用唯一标识码替换用户id #\r用left join连接，因为有些用户没有unique_id select name, unique_id from Employees left join EmployeeUNI on Employees.id = EmployeeUNI.id ###产品销售分析一 select product_name,year,price from Product inner join Sales on Sales.product_id = Product.product_id 进店却未消费的顾客 #\r左外连接，没有交易的顾客transaction_id为null，在where语句中用 is null筛选 select customer_id,count(customer_id) as count_no_trans from Visits left join Transactions on Visits.visit_id = Transactions.visit_id where transaction_id is null group by customer_id 上升的温度 #\r方法一：笛卡尔积 获取所有比前一天温度高的记录并记录其id 找相关联表 题干涉及到的表只有单表Weather 分析： 我们想要拿记录的温度与前一天进行相对比，那必然需要将前一天的记录放到一行中，不然单纯的select是无法进行比较的；所以想到用笛卡儿积，然后再通过前置知识进去过滤+温度条件 三、写SQL 将1步骤对应条件拼接到步骤2后面即可得到SQL 假设集合A={a, b}，集合B={0, 1, 2}，则两个集合的笛卡尔积为{(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)}。 inner join(等值连接) 只返回两个表中联结字段相等的行on表示链接条件 DATEDIFF() 函数返回两个日期之间的时间 select b.Id from weather a inner join weather b where DATEDIFF(b.recordDate,a.recordDate)=1 and b.Temperature \u0026gt; a.Temperature; 方法二： ADDDATE()函数用于将指定的时间间隔添加到日期值date是表示日期的值，它可以是 String、DATE（YEAR、MONTH 和 DAY）、DATETIME（HOURS、MINUTES 或 SECONDS）或 TIMESTAMP 类型。 ADDDATE( date , INTERVAL value addunit ) ADDDATE( date , days ) select a.id from Weather a inner join Weather b on (a.recordDate = adddate(b.recordDate,INTERVAL 1 day)) where a.temperature \u0026gt; b.temperature 每台机器运行的时间 #\r保留小数点后三位，用round()函数， select a.machine_Id, round(avg(b.timestamp - a.timestamp),3) as processing_time from Activity as a join Activity as b on a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type=\u0026#39;start\u0026#39; and b.activity_type=\u0026#39;end\u0026#39; group by machine_id 员工奖金 #\r判断是否为空不能用b.bonus = null 要用 b.bonus is null select e.name,b.bonus from Employee as e left join Bonus as b on e.empId = b.empId where b.bonus \u0026lt; 1000 or b.bonus is null 学生们参加各科测试的次数 #\r1.根据examinations表查询出每个考生每门科目的考试次数 2.students表和subject表连接获取全部可能性（相当于做笛卡儿积），再和步骤一表左外连接，没有考试的考生考试次数为null 3.IFNULL函数IFNULL(grouped.attended_exams, 0),如果为null，则设置为0 select s.student_id, s.student_name, sub.subject_name, IFNULL(grouped.attended_exams, 0) AS attended_exams from Students s join Subjects sub left join( select student_id, subject_name,count(*) as attended_exams from Examinations group by student_id,subject_name ) grouped on s.student_id = grouped.student_id and sub.subject_name = grouped.subject_name order by s.student_id, sub.subject_name 至少有5名下属员工 #\r首先要让managerId和id映射在一起，所以要用join连接 groupby函数分组，根据managerId分组后用聚合函数统计个数 最后返回员工大于5个的经理名字即可 select manager.name from Employee manager join Employee Employ on manager.id = Employ.managerId group by Employ.managerId having count(Employ.managerId)\u0026gt;=5 ###确认率 1.IFNULL函数，当为空时设置为0 2.round函数保留两位小数 3.使用AVG函数计算action = \u0026#39;confirmed\u0026#39;的平均值 select s.user_id, round(IFNUll(avg(c.action = \u0026#39;confirmed\u0026#39;),0),2) confirmation_rate from Signups s left join Confirmations c on s.user_id = c.user_id group by s.user_id; group by #\r","date":"2024-09-15","externalUrl":null,"permalink":"/all/mysql/%E9%AB%98%E9%A2%91sql50%E9%A2%98/","section":"Alls","summary":"sql执行顺序 # SQL 中，查询中子句的执行顺序通常如下： FROM 子句：","title":"mysql基础50题","type":"all"},{"content":"\rsql执行顺序 #\rSQL 中，查询中子句的执行顺序通常如下：\nFROM 子句：指定从中检索数据的表。\nWHERE 子句：根据指定的条件筛选行。\nGROUP BY 子句：根据指定的列或表达式对行进行分组。\nHAVING 子句：根据条件筛选分组的行。\nSELECT 子句：选择将在结果集中返回的列或表达式。\nORDER BY 子句：根据指定的列或表达式对结果集进行排序。\nLIMIT/OFFSET 子句：限制结果集中返回的行数。\n#\r（思考：left join连接两个图表，因为左边ALLEN在address表中city和state是null） select t1.firstName,t1.lastName,t2.city,t2.state from Person as t1 left join Address as t2 on t1.personId=t2.personId; 第二高的薪水 #\r(思考：offset用法：offset n 去掉几个值 offset去掉最大值，limit 1 选取第二个值作为第二高薪 select 200 as salary ) select (select distinct Salary from Employee order by Salary desc limit 1 offset 1)AS SecondHighestSalary; 第N高的薪水 #\r（思考：distinct去重重复的salary，方便查找唯一值，order by 薪资，降序排列结合limit获取第n条数据， limit 3 ：只有一个参数，表示获取前三条数据， limit 3，2；limit有两个参数，第一个参数表示从第几行数据开始查，第二个参数表示查几条数据， “limit 3,2”表示从第四行数据开始，取两条数据。 ） CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT BEGIN DECLARE M INT; SET M=N-1; RETURN ( select distinct salary from Employee order by salary desc limit M, 1 ); END 分数排名 #\rselect score, (select count(distinct s2.score) from Scores s2 where s2.score\u0026gt;=s1.score)as \u0026#39;rank\u0026#39; from Scores s1 order by s1.score desc 可回收且低脂产品 #\rselect product_id from Products where low_fats=\u0026#39;Y\u0026#39; and recyclable=\u0026#39;Y\u0026#39; ###寻找用户推荐人 MySQL 使用三值逻辑 —— TRUE, FALSE 和 UNKNOWN。任何与 NULL 值进行的比较都会与第三种值 UNKNOWN 做比较。这个“任何值”包括 NULL 本身！这就是为什么 MySQL 提供 IS NULL 和 IS NOT NULL 两种操作来对 NULL 特殊判断。 因此，在 WHERE 语句中我们需要做一个额外的条件判断 `referee_id IS NULL\u0026#39;。） select name from Customer where referee_Id !=2 or referee_Id IS NULL; 大的国家 #\rselect name,population,area from World where area\u0026gt;=3000000 or population \u0026gt;=25000000 文章浏览 #\rselect distinct viewer_id as id from Views where Views.viewer_id = Views.author_id order by id asc ###无效的推文 length：长度 select tweet_id from Tweets where length(content)\u0026gt;15 使用唯一标识码替换用户id #\r用left join连接，因为有些用户没有unique_id select name, unique_id from Employees left join EmployeeUNI on Employees.id = EmployeeUNI.id ###产品销售分析一 select product_name,year,price from Product inner join Sales on Sales.product_id = Product.product_id 进店却未消费的顾客 #\r左外连接，没有交易的顾客transaction_id为null，在where语句中用 is null筛选 select customer_id,count(customer_id) as count_no_trans from Visits left join Transactions on Visits.visit_id = Transactions.visit_id where transaction_id is null group by customer_id 上升的温度 #\r方法一：笛卡尔积 获取所有比前一天温度高的记录并记录其id 找相关联表 题干涉及到的表只有单表Weather 分析： 我们想要拿记录的温度与前一天进行相对比，那必然需要将前一天的记录放到一行中，不然单纯的select是无法进行比较的；所以想到用笛卡儿积，然后再通过前置知识进去过滤+温度条件 三、写SQL 将1步骤对应条件拼接到步骤2后面即可得到SQL 假设集合A={a, b}，集合B={0, 1, 2}，则两个集合的笛卡尔积为{(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)}。 inner join(等值连接) 只返回两个表中联结字段相等的行on表示链接条件 DATEDIFF() 函数返回两个日期之间的时间 select b.Id from weather a inner join weather b where DATEDIFF(b.recordDate,a.recordDate)=1 and b.Temperature \u0026gt; a.Temperature; 方法二： ADDDATE()函数用于将指定的时间间隔添加到日期值date是表示日期的值，它可以是 String、DATE（YEAR、MONTH 和 DAY）、DATETIME（HOURS、MINUTES 或 SECONDS）或 TIMESTAMP 类型。 ADDDATE( date , INTERVAL value addunit ) ADDDATE( date , days ) select a.id from Weather a inner join Weather b on (a.recordDate = adddate(b.recordDate,INTERVAL 1 day)) where a.temperature \u0026gt; b.temperature 每台机器运行的时间 #\r保留小数点后三位，用round()函数， select a.machine_Id, round(avg(b.timestamp - a.timestamp),3) as processing_time from Activity as a join Activity as b on a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type=\u0026#39;start\u0026#39; and b.activity_type=\u0026#39;end\u0026#39; group by machine_id 员工奖金 #\r判断是否为空不能用b.bonus = null 要用 b.bonus is null select e.name,b.bonus from Employee as e left join Bonus as b on e.empId = b.empId where b.bonus \u0026lt; 1000 or b.bonus is null 学生们参加各科测试的次数 #\r1.根据examinations表查询出每个考生每门科目的考试次数 2.students表和subject表连接获取全部可能性（相当于做笛卡儿积），再和步骤一表左外连接，没有考试的考生考试次数为null 3.IFNULL函数IFNULL(grouped.attended_exams, 0),如果为null，则设置为0 select s.student_id, s.student_name, sub.subject_name, IFNULL(grouped.attended_exams, 0) AS attended_exams from Students s join Subjects sub left join( select student_id, subject_name,count(*) as attended_exams from Examinations group by student_id,subject_name ) grouped on s.student_id = grouped.student_id and sub.subject_name = grouped.subject_name order by s.student_id, sub.subject_name 至少有5名下属员工 #\r首先要让managerId和id映射在一起，所以要用join连接 groupby函数分组，根据managerId分组后用聚合函数统计个数 最后返回员工大于5个的经理名字即可 select manager.name from Employee manager join Employee Employ on manager.id = Employ.managerId group by Employ.managerId having count(Employ.managerId)\u0026gt;=5 ###确认率 1.IFNULL函数，当为空时设置为0 2.round函数保留两位小数 3.使用AVG函数计算action = \u0026#39;confirmed\u0026#39;的平均值 select s.user_id, round(IFNUll(avg(c.action = \u0026#39;confirmed\u0026#39;),0),2) confirmation_rate from Signups s left join Confirmations c on s.user_id = c.user_id group by s.user_id; group by #\r","date":"2024-09-15","externalUrl":null,"permalink":"/mysql/%E9%AB%98%E9%A2%91sql50%E9%A2%98/","section":"MySQLs","summary":"sql执行顺序 # SQL 中，查询中子句的执行顺序通常如下： FROM 子句：","title":"mysql基础50题","type":"mysql"},{"content":"\rDVWA暴力破解攻略 #\r一、\t靶场考核点 #\r弱口令(weak password) 没有严格和准确的定义，通常认为容易被别人（他们有可能对你很了解）猜测到或被破解工具破解的口令均为弱口令。 弱口令指的是仅包含简单数字和字母的口令，例如“123”、“abc”等，因为这样的口令很容易被别人破解，从而使用户的互联网账号受到他人控制，因此不推荐用户使用。\n二、\t靶场复现 #\r等级：LOW #\r1、开启代理，输入账号密码 2、打开抓包工具抓包 3、点击Acktion,点击send to Intruder,进入Intruder模块 4、快速设置，开启攻击，得到长度不同的情况极大可能是账号密码 暴力破解medium步骤跟low一样 #\r等级： high #\r1、 开启抓包，发现多了个token，发送至intruder模块positions设置为pitchfork 2、Option线程设置为1，grep-extract打勾，点击add 3、进行如下设置，复制好value的值，点击Ok,然后找到redirections设置为Always 4、最后进行payloads设置，第二个设置为recursive grep模式 5、最后进行攻击，破解成功 三、\t漏洞分析 #\r1、未设计安全的验证码； 2、未对认证错误的提交进行计数并给出限制； 3、未使用双因素认证；\nbasic knowledage and tools to get debugs #\r⽬录遍历漏洞 #\r⽬录扫描 #\r什么是⽬录？ url的组成： https://blog.mo60.cn/index.php/archiv1s/2024-HeiDun.html -\u0026gt; http服务 提供⽹⻚服务的 https://blog.mo60.cn:443/index.php/archiv1s/2024-HeiDun.html :80 :443 端⼝与服务有对应关系\nhttp服务 -\u0026gt; 80\nhttp -\u0026gt; tcp/80\nhttps -\u0026gt; tcp/443\nhttp:// / https:// protocol://(sub)domain:port/path1/path2/path3\nport -\u0026gt; 端⼝65535端⼝ tcp/ip协议\n端⼝：提供服务的\nhttp：明⽂传输\nhttps：加密传输\nftp：⽂件传输协议 file tralation protocol 明⽂ -\u0026gt; 传输流量是明⽂ 是可读的 可能会泄露敏感 信息\nsftp: 加密版本的ftp s -\u0026gt; ssl tls 加密协议\ndirsearch #\rpython3 -m pip install -r requirements.txt\nxxxx package exsting 版本⾼于requirement中要求的版本\npip uninstall -\u0026gt; pip卸载⾼版本的y -\u0026gt; cannot uninstall the package the package has\ninstalled by debian\napt\napt-get\napt list|grep termcolora\npython3-temcolora\napt remove python3-termcolora -\u0026gt;\n什么是debian？\nlinux最早 林纳斯·xxx ,linux：开源 源代码开放 ,允许任何个⼈或组织基于linux进⾏⼆次开发 ,开源协议要求使⽤这个程序⼆次开发的应⽤ 也需要开源 ubuntu centos readhat debian 就都是linux的发⾏版\nunix -\u0026gt; 闭源 -\u0026gt; macos 基于unix进⾏⼆次开发 -\u0026gt; macos就也闭源 linux命名 linux is not unix\n原理 #\rhttp协议基础\ntcp/ip协议 有状态性\n应⽤层 http协议\n表示层\n会话层\n传输层\n⽹络层\n数据链路层 arp协议\n物理层 ⽹线 光纤\nhttp协议 -\u0026gt; tcp/ip ⽆状态性\n服务端在默认情况下并不知道哪个请求来源于哪个客户端\n在http协议中 有7种请求⽅式 最常⻅的就是get / post\nget使⽤url传值:\nhttp://112.124.71.224:18080/vulnerabilities/brute/?username=admin\u0026amp;pa\nssword=admin\u0026amp;Login=Login#\n浏览器对于url的⻓度有限制\n?name1=value1\u0026amp;name2=value2 安全性⽐较低\n请求包： #\rGET /login?username=admin\u0026amp;password=admin HTTP/1.1 Host: mbinvest.tebon.com.cn Connection: close Content-Length: 358 Pragma: no-cache Cache-Control: no-cache tztWebdataEncrypt: 1 X-Requested-With: XMLHttpRequest User-Agent: Mozilla/5.0 (Linux; Android 6.0.1; MuMu Build/V417IR; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/91.0.4472.114 Mobile Safari/537.36;/dbzq Content-Type: application/x-www-form-urlencoded; Accept: */* Origin: https://mbinvest.tebon.com.cn Sec-Fetch-Site: same-origin Sec-Fetch-Mode: cors Sec-Fetch-Dest: empty Referer: https://mbinvest.tebon.com.cn/h5_vue/news/wealth-app/index.html Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 Cookie: sajssdk_2015_cross_new_user=1; sensorsdata2015jssdkcross=%7B%22distinct_id%22%3A%221919cdf8e18175 0bdab4c7be43008-20331d51-557200 1919cdf8e19227%22%2C%22first_id%22%3A%22%22%2C%22props%22%3A%7B%22%24late st_traffic_source_type%22%3A%22%E7%9B%B4%E6%8E%A5%E6%B5%81%E9%87%8F%22%2C %22%24latest_search_keyword%22%3A%22%E6%9C%AA%E5%8F%96%E5%88%B0%E5%80%BC_ %E7%9B%B4%E6%8E%A5%E6%89%93%E5%BC%80%22%2C%22%24latest_referrer%22%3A%22% 22%7D%2C%22identities%22%3A%22eyIkaWRlbnRpdHlfY29va2llX2lkIjoiMTkxOWNkZjh lMTgxNzUtMGJkYWI0YzdiZTQzMDA4LTIwMzMxZDUxLTU1NzIwMC0xOTE5Y2RmOGUxOTIyNyJ9 %22%2C%22history_login_id%22%3A%7B%22name%22%3A%22%22%2C%22value%22%3A%22 %22%7D%2C%22%24device_id%22%3A%221919cdf8e18175-0bdab4c7be43008-20331d51 557200-1919cdf8e19227%22%7D; t1=DEB48BC37658EAC11885AA1DFE8F8632CA2B49294C51C1BACC post传值 在body中传值 #\rPOST /login HTTP/1.1 Host: mbinvest.tebon.com.cn Connection: close Content-Length: 358 Pragma: no-cache Cache-Control: no-cache tztWebdataEncrypt: 1 X-Requested-With: XMLHttpRequest User-Agent: Mozilla/5.0 (Linux; Android 6.0.1; MuMu Build/V417IR; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/91.0.4472.114 Mobile Safari/537.36;/dbzq Content-Type: application/x-www-form-urlencoded; Accept: */* Origin: https://mbinvest.tebon.com.cn Sec-Fetch-Site: same-origin Sec-Fetch-Mode: cors Sec-Fetch-Dest: empty Referer: https://mbinvest.tebon.com.cn/h5_vue/news/wealth-app/index.html Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 Cookie: sajssdk_2015_cross_new_user=1; sensorsdata2015jssdkcross=%7B%22distinct_id%22%3A%221919cdf8e18175 0bdab4c7be43008-20331d51-557200 1919cdf8e19227%22%2C%22first_id%22%3A%22%22%2C%22props%22%3A%7B%22%24late st_traffic_source_type%22%3A%22%E7%9B%B4%E6%8E%A5%E6%B5%81%E9%87%8F%22%2C %22%24latest_search_keyword%22%3A%22%E6%9C%AA%E5%8F%96%E5%88%B0%E5%80%BC_ %E7%9B%B4%E6%8E%A5%E6%89%93%E5%BC%80%22%2C%22%24latest_referrer%22%3A%22% 22%7D%2C%22identities%22%3A%22eyIkaWRlbnRpdHlfY29va2llX2lkIjoiMTkxOWNkZjh lMTgxNzUtMGJkYWI0YzdiZTQzMDA4LTIwMzMxZDUxLTU1NzIwMC0xOTE5Y2RmOGUxOTIyNyJ9 %22%2C%22history_login_id%22%3A%7B%22name%22%3A%22%22%2C%22value%22%3A%22 %22%7D%2C%22%24device_id%22%3A%221919cdf8e18175-0bdab4c7be43008-20331d51 557200-1919cdf8e19227%22%7D; t1=DEB48BC37658EAC11885AA1DFE8F8632CA2B49294C51C1BACC username=admin\u0026amp;password=admin request header请求头： #\rHost: mbinvest.tebon.com.cn Connection: close Content-Length: 358 Pragma: no-cache Cache-Control: no-cache tztWebdataEncrypt: 1 X-Requested-With: XMLHttpRequest User-Agent: Mozilla/5.0 (Linux; Android 6.0.1; MuMu Build/V417IR; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/91.0.4472.114 Mobile Safari/537.36;/dbzq Content-Type: application/x-www-form-urlencoded; Accept: */* Origin: https://mbinvest.tebon.com.cn Sec-Fetch-Site: same-origin Sec-Fetch-Mode: cors Sec-Fetch-Dest: empty Referer: https://mbinvest.tebon.com.cn/h5_vue/news/wealth-app/index.html Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 Cookie: username=guest; sensorsdata2015jssdkcross=%7B%22distinct_id%22%3A%221919cdf8e18175 0bdab4c7be43008-20331d51-557200 1919cdf8e19227%22%2C%22first_id%22%3A%22%22%2C%22props%22%3A%7B%22%24late st_traffic_source_type%22%3A%22%E7%9B%B4%E6%8E%A5%E6%B5%81%E9%87%8F%22%2C %22%24latest_search_keyword%22%3A%22%E6%9C%AA%E5%8F%96%E5%88%B0%E5%80%BC_ %E7%9B%B4%E6%8E%A5%E6%89%93%E5%BC%80%22%2C%22%24latest_referrer%22%3A%22% 22%7D%2C%22identities%22%3A%22eyIkaWRlbnRpdHlfY29va2llX2lkIjoiMTkxOWNkZjh lMTgxNzUtMGJkYWI0YzdiZTQzMDA4LTIwMzMxZDUxLTU1NzIwMC0xOTE5Y2RmOGUxOTIyNyJ9 %22%2C%22history_login_id%22%3A%7B%22name%22%3A%22%22%2C%22value%22%3A%22 %22%7D%2C%22%24device_id%22%3A%221919cdf8e18175-0bdab4c7be43008-20331d51 557200-1919cdf8e19227%22%7D; t1=DEB48BC37658EAC11885AA1DFE8F8632CA2B49294C51C1BACC 响应包： #\r状态码 #\r100-299 -\u0026gt; 响应正常\n30x -\u0026gt; 301 ⽹⻚发⽣了跳转\n40x -\u0026gt; 404 not found -\u0026gt; 请求的路径不存在 4开头的状态码代表请求的错误 包括但不限于权 限问题、请求路径问题 404 请求路径问题\n401 un auth -\u0026gt; 权限不够\n5xx \u0026gt; 501 internel error -\u0026gt; 5开头的状态码⼀般意味着服务器有内部错误\nHTTP/1.1 200 OK 状态码 Server: nginx/1.20.1 Date: Wed, 11 Sep 2024 08:37:06 GMT Content-Type: application/json;charset=utf-8 Connection: close Cache-Control: no-cache X-Content-Type-Options: nosniff X-Frame-Options: SAMEORIGIN X-XSS-Protection: 1; mode=block Access-Control-Allow-Credentials: true Content-Length: 235 { } \u0026#34;ACTION\u0026#34;: \u0026#34;46116\u0026#34;, \u0026#34;MAXCOUNT\u0026#34;: \u0026#34;10\u0026#34;, \u0026#34;ERRORNO\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;ERRORMESSAGE\u0026#34;: \u0026#34;未找到资讯信息\u0026#34;, \u0026#34;IDINDEX\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;INFOTITLEINDEX\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;DATESINDEX\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;MEDIAINDEX\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;FLAGINDEX\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;STOCKCODEINDEX\u0026#34;: \u0026#34;5\u0026#34; response header 响应头 #\rServer: nginx/1.20.1 Date: Wed, 11 Sep 2024 08:37:06 GMT Content-Type: application/json;charset=utf-8 -\u0026gt; 响应类型 Connection: close Cache-Control: no-cache X-Content-Type-Options: nosniff X-Frame-Options: SAMEORIGIN X-XSS-Protection: 1; mode=block Access-Control-Allow-Credentials: true Content-Length: 235 -\u0026gt; 响应⻓度 dirsearch 可以根据扫描得到的response的状态码来判断⽬标路径、⽂件 是否存在\n404 -\u0026gt; 不存在\n200 -\u0026gt; 存在\n301 -\u0026gt; 该路径不直接存在 -\u0026gt; 被重定向到另⼀个路径\n⼆级⽬录扫描 #\rTarget: http://112.124.71.224:18080/ [16:48:49] Starting: game/ [16:49:07] 200 - 158B - /game/www [16:49:25] 403 - 300B - /game/.ht_wsr.txt [16:49:25] 403 - 303B - /game/.htaccess.bak1 [16:49:25] 403 - 304B - /game/.htaccess_extra [16:49:25] 403 - 303B - /game/.htaccess.orig [16:49:25] 403 - 305B - /game/.htaccess.sample [16:49:25] 403 - 303B - /game/.htaccess_orig [16:49:25] 403 - 301B - /game/.htaccessOLD [16:49:25] 403 - 299B - /game/.htpasswds [16:49:25] 403 - 302B - /game/.htaccessOLD2 [16:49:26] 403 - 303B - /game/.htpasswd_test [16:49:25] 403 - 301B - /game/.htaccessBAK [16:49:25] 403 - 303B - /game/.htaccess.save [16:49:26] 403 - 300B - /game/.httr-oauth [16:49:25] 403 - 301B - /game/.htaccess_sc [16:50:34] 200 - 158B - /game/www.zip 得到了www.zip 备份⽂件\n端⼝扫描 #\rip : 112.124.71.224\n通过浏览器正常访问 发现返回空响应\n能说这个ip地址（服务器）没有任何的对外服务吗？\n1-65535个端⼝\n浏览器访问112.124.71.224 只探测了80\nhttps://112.124.71.224 -\u0026gt; 443\nnmap #\r使⽤nmap对112.124.71.224扫描了80端⼝\nnmap 112.124.71.224 -p 80 Starting Nmap 7.95 ( https://nmap.org ) at 2024-09-11 10:29 CST Nmap scan report for 112.124.71.224 Host is up (0.052s latency). PORT STATE SERVICE 80/tcp closed http Nmap done: 1 IP address (1 host up) scanned in 0.20 seconds 想让nmap帮我们扫描这台主机的所有端⼝? tcp三次握⼿\n第⼀次握⼿：\nclient(nmap) -\u0026gt; server(112.124.71.224:80) : syn 请求包\nserver -\u0026gt; client : ack 确认包\n如果只根据上⾯两个包就判定端⼝是否开放 在nmap属于半开扫描\n半开扫描的结果不⼀定准确\nclient -\u0026gt; 决定建⽴连接 -\u0026gt; syn+ack\nserver -\u0026gt; client -\u0026gt; ack\nnmap在默认情况下都是全连接扫描 -\u0026gt; 三次握⼿+ 四次挥⼿-sS -\u0026gt; 指定nmap进⾏半开扫描 2次握⼿ 提升速度 牺牲的精度\n特洛伊⽊⻢ -\u0026gt; 1个特征 -\u0026gt; ⽤过⼀次就⾃我销毁\n⽤过1次 取决于有没有完整的建⽴过1次tcp三次握⼿\nCTF解题模式、AWD局域⽹攻防竞赛\n靶机不会给你初始权限 提供低权限⽤户\n出题⼈会在靶机中放置⼀个特洛伊⽊⻢\nnc连接端⼝ 就可以得到⼀个shell\nnetcat 瑞⼠军⼑\nnc ip port nc 112.124.71.224 1445 -\u0026gt; $\u0026gt;id -\u0026gt; root\nnmap 112.124.71.224 -p 1-65535 -\u0026gt; ⽐赛的时候 如果直接nmap 会导致特洛伊⽊⻢⾃我销毁 -\u0026gt; -sS半开扫描可以解决这个问题\ntcp三次握⼿ 四次挥⼿\n只⽤了两次握⼿就判断了端⼝是否开放\nnmap收到ack的回复 ⽬标端⼝开放\nclient(nmap) -\u0026gt; server(112.124.71.224:80) : syn 请求包\nserver -\u0026gt; RST/FIN : ack 确认包\nnmap收到rst/fin回复 判定端⼝未开放\n为什么说端⼝未开放 有可能会回复 有可能不会回复？\n取决于端⼝是怎样的不开放\n1.112.124.71.224的确没有http服务\nnmap扫描 80/443 -\u0026gt; 不会回应\n2.防⽕墙 #\r112.124.71.224开放了http服务 但是限制了源ip地址\nnmap扫描80/443 -\u0026gt; 会回应 -\u0026gt; FIN/RST\n80/tcp close/open/filtered(过滤的)\n全端⼝扫描 #\rHost is up (0.051s latency). Not shown: 65521 closed tcp ports (conn-refused) PORT STATE 21/tcp 22/tcp 135/tcp open open SERVICE ftp ssh filtered msrpc 136/tcp 137/tcp filtered profile -\u0026gt; ⽂件传输协议 -\u0026gt; ssh远程连接linux服务器 filtered netbios-ns 138/tcp 139/tcp 445/tcp filtered netbios-dgm filtered netbios-ssn filtered microsoft-ds 135-139 445端⼝ 都是windows特有的端⼝ netbios samba服务 ⽂件共享 17010永恒之蓝漏洞 就是基于445端⼝的samba服务进⾏的攻击 政企的安全建设中 ⼀般认为445端⼝是⾼危端⼝ windowes 7 -\u0026gt; 永恒之蓝漏洞 导致全球千万台pc机 感染了勒索病毒 windows 10 -\u0026gt; 永恒之⿊ 影响⾯不如永恒之蓝⼴泛 593/tcp filtered http-rpc-epmap 4444/tcp filtered krb524 filtered -\u0026gt; 已过滤状态 阿⾥云防⽕墙默认不启⽤445端⼝ 系统⾃带的防⽕墙 5003/tcp open filemaker 5355/tcp filtered llmnr 18080/tcp open unknown -\u0026gt; unkown就是nmap没有匹配到指纹 80 -\u0026gt; http -\u0026gt; 实际建站不会使⽤默认80 -\u0026gt; tomcat / nginx -\u0026gt; 8080 服务器 和web应⽤ 是⼀⽐⼀的关系吗？ 不是 80 -\u0026gt; ⽹站A 8080 8081 18080 18081 使⽤⾼位端⼝启⽤web服务 40301/tcp open unknown Nmap done: 1 IP address (1 host up) scanned in 4063.19 seconds 扫描： 对112.124.71.224发起端⼝扫描\n我们的流量 是从当前主机直接到达了⽬标主机吗\n使⽤校园⽹：⽹络出⼝就是学校的公⽹IP（⽹关） -\u0026gt; ⽹关可能部署⼀些流量清洗的设备\n使⽤浏览器访问18080端⼝ 可以正常访问 这是因为浏览器访问的流量合法 不存在扫描器的特 征\nnmap特征明显 可能被校园⽹的流量清洗设备捕获 扫描结果被劫持\nQuestion and Answer #\r⽹络问题\n⽹卡NAT模式：· 安全问题如果虚拟机部署了靶场可能导致被其他⼈攻击对虚拟机造成损坏\n校园⽹问题 上游的校园⽹服务器 只会对1个校园⽹账号下发1个ip地址导致使⽤桥接模式的虚拟机获取不到ip地址 没⽹\npip问题 什么是pip?\npip是python官⽅的⽤于管理（安装、更新、卸载）python依赖（库、包）\npython3 -m pip install -r requirement.txt -\u0026gt; no moudule name pip\npython3安装pip -\u0026gt; curl bootstrap.com/get-pip.py -\u0026gt; python3 get-pip.py\n运⾏问题 域名 -\u0026gt; dns\n顶级域：.com .cn（中国特⾊顶级域） .gov政府 .gov.cn（中国政府的顶级域） .gov(美 国政府)\n.org 组织\n⼦域名 -\u0026gt; 在主域名之下 -\u0026gt; mo60.cn -\u0026gt; blog.mo60.cn / tools.mo60.cn\n爆破 #\rkali⾃带字典 #\r/usr/share/wordlists/rockyou.tar.gz -\u0026gt; rockyou是美国情报机构\n$\u0026gt; zcat rockyou.txt.gz \u0026gt; /root/password.txt $\u0026gt; head -n 10 /root/password.txt /usr/share/wordlists/ -\u0026gt; kali存放字典的⽬录\n靶场 #\rhttp://112.124.71.224:18080/login.php\nhtml #\rhyper text mark language -\u0026gt; 超⽂本标记语⾔\n以标签的⽅式进⾏编写 标签是成对的\n\u0026lt;!DOCTYPE html PUBLIC \u0026#34;-//W3C//DTD XHTML 1.0 Strict//EN\u0026#34; \u0026#34;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\u0026#34;\u0026gt; -\u0026gt; 指代了html的 标准 \u0026lt;html\u0026gt; ... html代码会被浏览器渲染 呈现出画⾯给⽤户 \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;⽹⻚标题\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; ... -\u0026gt; ⽹⻚的主体内容 \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; body -\u0026gt; 表单 -\u0026gt; 表单是html⽹⻚前端与后端交互的介质\n表单\n\u0026lt;form action=\u0026#34;#\u0026#34; method=\u0026#34;GET\u0026#34;\u0026gt; Username:\u0026lt;br\u0026gt; 控件 \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34;\u0026gt;\u0026lt;br\u0026gt; Password:\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; autocomplete=\u0026#34;off\u0026#34; name=\u0026#34;password\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; name=\u0026#34;Login\u0026#34;\u0026gt; 控件最重要的属性 就是name值 \u0026lt;/form\u0026gt; 前端：浏览器中看到的⻚⾯ 统⼀都是前端\n后端：逻辑处理 ⽐如百度热搜 热搜榜单 后端做的逻辑处理\n账号：admin\n密码：password\n前端：在浏览器中能看到的⻚⾯ 全都属于前端 /admin/index.php -》 后台管理界⾯ -\u0026gt;\n前端\n后端：逻辑代码\n后端会接收前端的传值 -\u0026gt; 前端就是我们⽤户操作过程中会传值\ncookie 饼⼲\ncookie -》 session 会话\ncookie session机制 就是为了解决http⽆状态性\n⽹站的注册登录功能\n登录之后 服务器就会向浏览器写⼊cookie\n浏览器发起的每个请求 都会携带cookie\ncookie 会存储在浏览器\nsession 存储在服务器\ncsrf漏洞 -\u0026gt; 跨站请求伪造\nhttp://112.124.71.224:18080/vulnerabilities/csrf/?password_new=password\u0026amp;password_\nconf=password\u0026amp;Change=Change#\nadmin ⽤户 改密码\nmay -\u0026gt;http://112.124.71.224:18080/vulnerabilities/csrf/?password_new=password\u0026amp;pas\nsword_conf=password\u0026amp;Change=Change#\nmay在不知情况的情况下 修改了密码\n密码 参数也会加密\n短链接\nsession cookie这⼀套机制导致的\ncookie 记录当前⽤户的身份\n本质上要解决的是 服务器\ntoken -\u0026gt; 令牌\ntoken 1个token对应1次⽹络请求\nadmin:http://112.124.71.224:18080/vulnerabilities/csrf/?password_new=password\u0026amp;pas\nsword_conf=password\u0026amp;Change=Change\u0026amp;token=fdjaf84384u83ruf3483\nmay：http://112.124.71.224:18080/vulnerabilities/csrf/?password_new=password\u0026amp;pass\nword_conf=password\u0026amp;Change=Change\u0026amp;token=fdjaf84384u83ruf3483\ntoken⻛险\n是在当前请求的响应中把下⼀次请求要给⽤户的token直接展示了\ntcp/ip -\u0026gt; 有状态性\n应⽤层 http -\u0026gt; ⽆状态性\n表示层\n会话层\n传输层\n⽹络层\n数据链路层\n物理层\n响应\n200 OK -\u0026gt; http状态码\n100-299 -\u0026gt; 请求是没有发⽣错误\n300 -\u0026gt; 399 -\u0026gt; 服务器发⽣了重定向\n400 -\u0026gt; 499 404 -\u0026gt; 404 not found -\u0026gt; 请求路径、资源不存在 401 权限不够 4xx状态码就是\n请求有问题\n500 -\u0026gt; 599 5xx⼀般是服务器内部出问题 501 http 501 interl error 内部错误\nHTTP/1.1 200 OK Date: Thu, 12 Sep 2024 08:33:37 GMT Server: Apache/2.4.7 (Ubuntu) X-Powered-By: PHP/5.5.9-1ubuntu4.20 Expires: Tue, 23 Jun 2009 12:00:00 GMT Cache-Control: no-cache, must-revalidate Pragma: no-cache Vary: Accept-Encoding Content-Length: 4943 -\u0026gt; 响应体⼤⼩ Connection: close Content-Type: text/html;charset=utf-8 -\u0026gt; 响应类型 response header 响应头 \u0026lt;!DOCTYPE html PUBLIC \u0026#34;-//W3C//DTD XHTML 1.0 Strict//EN\u0026#34; \u0026#34;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\u0026#34;\u0026gt; \u0026lt;html xmlns=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html; charset=UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Vulnerability: Brute Force :: Damn Vulnerable Web Application (DVWA) v1.9\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;../../dvwa/css/main.css\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;\\image/ico\u0026#34; href=\u0026#34;../../favicon.ico\u0026#34; /\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;../../dvwa/js/dvwaPage.js\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body class=\u0026#34;home\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;header\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;../../dvwa/images/logo.png\u0026#34; alt=\u0026#34;Damn Vulnerable Web Application\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;main_menu\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;main_menu_padded\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;menuBlocks\u0026#34;\u0026gt;\u0026lt;li onclick=\u0026#34;window.location=\u0026#39;../../.\u0026#39;\u0026#34; class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;../../.\u0026#34;\u0026gt;Home\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li onclick=\u0026#34;window.location=\u0026#39;../../instructions.php\u0026#39;\u0026#34; class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;../../instructions.php\u0026#34;\u0026gt;Instructions\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li onclick=\u0026#34;window.location=\u0026#39;../../setup.php\u0026#39;\u0026#34; class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;../../setup.php\u0026#34;\u0026gt;Setup / Reset DB\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;\u0026lt;ul class=\u0026#34;menuBlocks\u0026#34;\u0026gt;\u0026lt;li onclick=\u0026#34;window.location=\u0026#39;../../vulnerabilities/brute/\u0026#39;\u0026#34; class=\u0026#34;selected\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;../../vulnerabilities/brute/\u0026#34;\u0026gt;Brute Force\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li onclick=\u0026#34;window.location=\u0026#39;../../vulnerabilities/exec/\u0026#39;\u0026#34; class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;../../vulnerabilities/exec/\u0026#34;\u0026gt;Command Injection\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li onclick=\u0026#34;window.location=\u0026#39;../../vulnerabilities/csrf/\u0026#39;\u0026#34; class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;../../vulnerabilities/csrf/\u0026#34;\u0026gt;CSRF\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li onclick=\u0026#34;window.location=\u0026#39;../../vulnerabilities/fi/.? page=include.php\u0026#39;\u0026#34; class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;../../vulnerabilities/fi/.? page=include.php\u0026#34;\u0026gt;File Inclusion\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li onclick=\u0026#34;window.location=\u0026#39;../../vulnerabilities/upload/\u0026#39;\u0026#34; class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;../../vulnerabilities/upload/\u0026#34;\u0026gt;File Upload\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li onclick=\u0026#34;window.location=\u0026#39;../../vulnerabilities/captcha/\u0026#39;\u0026#34; class=\u0026#34;\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;../../vulnerabilities/captcha/\u0026#34;\u0026gt;Insecure CAPTCHA\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li onclick=\u0026#34;window.location=\u0026#39;../../vulnerabilities/sqli/\u0026#39;\u0026#34; class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;../../vulnerabilities/sqli/\u0026#34;\u0026gt;SQL Injection\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li onclick=\u0026#34;window.location=\u0026#39;../../vulnerabilities/sqli_blind/\u0026#39;\u0026#34; class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;../../vulnerabilities/sqli_blind/\u0026#34;\u0026gt;SQL Injection (Blind)\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li onclick=\u0026#34;window.location=\u0026#39;../../vulnerabilities/xss_r/\u0026#39;\u0026#34; class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;../../vulnerabilities/xss_r/\u0026#34;\u0026gt;XSS (Reflected)\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li onclick=\u0026#34;window.location=\u0026#39;../../vulnerabilities/xss_s/\u0026#39;\u0026#34; class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;../../vulnerabilities/xss_s/\u0026#34;\u0026gt;XSS (Stored)\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;\u0026lt;ul class=\u0026#34;menuBlocks\u0026#34;\u0026gt;\u0026lt;li onclick=\u0026#34;window.location=\u0026#39;../../security.php\u0026#39;\u0026#34; class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;../../security.php\u0026#34;\u0026gt;DVWA Security\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li onclick=\u0026#34;window.location=\u0026#39;../../phpinfo.php\u0026#39;\u0026#34; class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;../../phpinfo.php\u0026#34;\u0026gt;PHP Info\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li onclick=\u0026#34;window.location=\u0026#39;../../about.php\u0026#39;\u0026#34; class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;../../about.php\u0026#34;\u0026gt;About\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;\u0026lt;ul class=\u0026#34;menuBlocks\u0026#34;\u0026gt;\u0026lt;li onclick=\u0026#34;window.location=\u0026#39;../../logout.php\u0026#39;\u0026#34; class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;../../logout.php\u0026#34;\u0026gt;Logout\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;main_body\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;body_padded\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Vulnerability: Brute Force\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;vulnerable_code_area\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;Login\u0026lt;/h2\u0026gt; \u0026lt;form action=\u0026#34;#\u0026#34; method=\u0026#34;GET\u0026#34;\u0026gt; Username:\u0026lt;br /\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34;\u0026gt;\u0026lt;br /\u0026gt; Password:\u0026lt;br /\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; AUTOCOMPLETE=\u0026#34;off\u0026#34; name=\u0026#34;password\u0026#34;\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; name=\u0026#34;Login\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;pre\u0026gt;\u0026lt;br /\u0026gt;Username and/or password incorrect.\u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;h2\u0026gt;More Information\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;http://hiderefer.com/? https://www.owasp.org/index.php/Testing_for_Brute_Force_(OWASP-AT-004)\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;https://www.owasp.org/index.php/Testing_for_Brute_Force_( OWASP-AT-004)\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;http://hiderefer.com/? http://www.symantec.com/connect/articles/password-crackers-ensuring security-your-password\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;http://www.symantec.com/connect/articles/password crackers-ensuring-security-your-password\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;http://hiderefer.com/? http://www.sillychicken.co.nz/Security/how-to-brute-force-http-forms-in windows.html\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;http://www.sillychicken.co.nz/Security/how to-brute-force-http-forms-in-windows.html\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;br /\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;clear\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;system_info\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;View Help\u0026#34; class=\u0026#34;popup_button\u0026#34; onClick=\u0026#34;javascript:popUp( \u0026#39;../../vulnerabilities/view_help.php? id=brute\u0026amp;security=low\u0026#39; )\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;View Source\u0026#34; class=\u0026#34;popup_button\u0026#34; onClick=\u0026#34;javascript:popUp( \u0026#39;../../vulnerabilities/view_source.php?id=brute\u0026amp;security=low\u0026#39; )\u0026#34;\u0026gt; \u0026lt;div align=\u0026#34;left\u0026#34;\u0026gt;\u0026lt;em\u0026gt;Username:\u0026lt;/em\u0026gt; admin\u0026lt;br /\u0026gt;\u0026lt;em\u0026gt;Security Level:\u0026lt;/em\u0026gt; low\u0026lt;br /\u0026gt;\u0026lt;em\u0026gt;PHPIDS:\u0026lt;/em\u0026gt; disabled\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;footer\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Damn Vulnerable Web Application (DVWA) v1.9\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","date":"2024-09-10","externalUrl":null,"permalink":"/all/networkengineering/penetrationtesting/","section":"Alls","summary":"DVWA暴力破解攻略 # 一、 靶场考核点 # 弱口令(weak password) 没有","title":"DVWA暴力破解攻略","type":"all"},{"content":"\rDVWA暴力破解攻略 #\r一、\t靶场考核点 #\r弱口令(weak password) 没有严格和准确的定义，通常认为容易被别人（他们有可能对你很了解）猜测到或被破解工具破解的口令均为弱口令。 弱口令指的是仅包含简单数字和字母的口令，例如“123”、“abc”等，因为这样的口令很容易被别人破解，从而使用户的互联网账号受到他人控制，因此不推荐用户使用。\n二、\t靶场复现 #\r等级：LOW #\r1、开启代理，输入账号密码 2、打开抓包工具抓包 3、点击Acktion,点击send to Intruder,进入Intruder模块 4、快速设置，开启攻击，得到长度不同的情况极大可能是账号密码 暴力破解medium步骤跟low一样 #\r等级： high #\r1、 开启抓包，发现多了个token，发送至intruder模块positions设置为pitchfork 2、Option线程设置为1，grep-extract打勾，点击add 3、进行如下设置，复制好value的值，点击Ok,然后找到redirections设置为Always 4、最后进行payloads设置，第二个设置为recursive grep模式 5、最后进行攻击，破解成功 三、\t漏洞分析 #\r1、未设计安全的验证码； 2、未对认证错误的提交进行计数并给出限制； 3、未使用双因素认证；\nbasic knowledage and tools to get debugs #\r⽬录遍历漏洞 #\r⽬录扫描 #\r什么是⽬录？ url的组成： https://blog.mo60.cn/index.php/archiv1s/2024-HeiDun.html -\u0026gt; http服务 提供⽹⻚服务的 https://blog.mo60.cn:443/index.php/archiv1s/2024-HeiDun.html :80 :443 端⼝与服务有对应关系\nhttp服务 -\u0026gt; 80\nhttp -\u0026gt; tcp/80\nhttps -\u0026gt; tcp/443\nhttp:// / https:// protocol://(sub)domain:port/path1/path2/path3\nport -\u0026gt; 端⼝65535端⼝ tcp/ip协议\n端⼝：提供服务的\nhttp：明⽂传输\nhttps：加密传输\nftp：⽂件传输协议 file tralation protocol 明⽂ -\u0026gt; 传输流量是明⽂ 是可读的 可能会泄露敏感 信息\nsftp: 加密版本的ftp s -\u0026gt; ssl tls 加密协议\ndirsearch #\rpython3 -m pip install -r requirements.txt\nxxxx package exsting 版本⾼于requirement中要求的版本\npip uninstall -\u0026gt; pip卸载⾼版本的y -\u0026gt; cannot uninstall the package the package has\ninstalled by debian\napt\napt-get\napt list|grep termcolora\npython3-temcolora\napt remove python3-termcolora -\u0026gt;\n什么是debian？\nlinux最早 林纳斯·xxx ,linux：开源 源代码开放 ,允许任何个⼈或组织基于linux进⾏⼆次开发 ,开源协议要求使⽤这个程序⼆次开发的应⽤ 也需要开源 ubuntu centos readhat debian 就都是linux的发⾏版\nunix -\u0026gt; 闭源 -\u0026gt; macos 基于unix进⾏⼆次开发 -\u0026gt; macos就也闭源 linux命名 linux is not unix\n原理 #\rhttp协议基础\ntcp/ip协议 有状态性\n应⽤层 http协议\n表示层\n会话层\n传输层\n⽹络层\n数据链路层 arp协议\n物理层 ⽹线 光纤\nhttp协议 -\u0026gt; tcp/ip ⽆状态性\n服务端在默认情况下并不知道哪个请求来源于哪个客户端\n在http协议中 有7种请求⽅式 最常⻅的就是get / post\nget使⽤url传值:\nhttp://112.124.71.224:18080/vulnerabilities/brute/?username=admin\u0026amp;pa\nssword=admin\u0026amp;Login=Login#\n浏览器对于url的⻓度有限制\n?name1=value1\u0026amp;name2=value2 安全性⽐较低\n请求包： #\rGET /login?username=admin\u0026amp;password=admin HTTP/1.1 Host: mbinvest.tebon.com.cn Connection: close Content-Length: 358 Pragma: no-cache Cache-Control: no-cache tztWebdataEncrypt: 1 X-Requested-With: XMLHttpRequest User-Agent: Mozilla/5.0 (Linux; Android 6.0.1; MuMu Build/V417IR; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/91.0.4472.114 Mobile Safari/537.36;/dbzq Content-Type: application/x-www-form-urlencoded; Accept: */* Origin: https://mbinvest.tebon.com.cn Sec-Fetch-Site: same-origin Sec-Fetch-Mode: cors Sec-Fetch-Dest: empty Referer: https://mbinvest.tebon.com.cn/h5_vue/news/wealth-app/index.html Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 Cookie: sajssdk_2015_cross_new_user=1; sensorsdata2015jssdkcross=%7B%22distinct_id%22%3A%221919cdf8e18175 0bdab4c7be43008-20331d51-557200 1919cdf8e19227%22%2C%22first_id%22%3A%22%22%2C%22props%22%3A%7B%22%24late st_traffic_source_type%22%3A%22%E7%9B%B4%E6%8E%A5%E6%B5%81%E9%87%8F%22%2C %22%24latest_search_keyword%22%3A%22%E6%9C%AA%E5%8F%96%E5%88%B0%E5%80%BC_ %E7%9B%B4%E6%8E%A5%E6%89%93%E5%BC%80%22%2C%22%24latest_referrer%22%3A%22% 22%7D%2C%22identities%22%3A%22eyIkaWRlbnRpdHlfY29va2llX2lkIjoiMTkxOWNkZjh lMTgxNzUtMGJkYWI0YzdiZTQzMDA4LTIwMzMxZDUxLTU1NzIwMC0xOTE5Y2RmOGUxOTIyNyJ9 %22%2C%22history_login_id%22%3A%7B%22name%22%3A%22%22%2C%22value%22%3A%22 %22%7D%2C%22%24device_id%22%3A%221919cdf8e18175-0bdab4c7be43008-20331d51 557200-1919cdf8e19227%22%7D; t1=DEB48BC37658EAC11885AA1DFE8F8632CA2B49294C51C1BACC post传值 在body中传值 #\rPOST /login HTTP/1.1 Host: mbinvest.tebon.com.cn Connection: close Content-Length: 358 Pragma: no-cache Cache-Control: no-cache tztWebdataEncrypt: 1 X-Requested-With: XMLHttpRequest User-Agent: Mozilla/5.0 (Linux; Android 6.0.1; MuMu Build/V417IR; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/91.0.4472.114 Mobile Safari/537.36;/dbzq Content-Type: application/x-www-form-urlencoded; Accept: */* Origin: https://mbinvest.tebon.com.cn Sec-Fetch-Site: same-origin Sec-Fetch-Mode: cors Sec-Fetch-Dest: empty Referer: https://mbinvest.tebon.com.cn/h5_vue/news/wealth-app/index.html Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 Cookie: sajssdk_2015_cross_new_user=1; sensorsdata2015jssdkcross=%7B%22distinct_id%22%3A%221919cdf8e18175 0bdab4c7be43008-20331d51-557200 1919cdf8e19227%22%2C%22first_id%22%3A%22%22%2C%22props%22%3A%7B%22%24late st_traffic_source_type%22%3A%22%E7%9B%B4%E6%8E%A5%E6%B5%81%E9%87%8F%22%2C %22%24latest_search_keyword%22%3A%22%E6%9C%AA%E5%8F%96%E5%88%B0%E5%80%BC_ %E7%9B%B4%E6%8E%A5%E6%89%93%E5%BC%80%22%2C%22%24latest_referrer%22%3A%22% 22%7D%2C%22identities%22%3A%22eyIkaWRlbnRpdHlfY29va2llX2lkIjoiMTkxOWNkZjh lMTgxNzUtMGJkYWI0YzdiZTQzMDA4LTIwMzMxZDUxLTU1NzIwMC0xOTE5Y2RmOGUxOTIyNyJ9 %22%2C%22history_login_id%22%3A%7B%22name%22%3A%22%22%2C%22value%22%3A%22 %22%7D%2C%22%24device_id%22%3A%221919cdf8e18175-0bdab4c7be43008-20331d51 557200-1919cdf8e19227%22%7D; t1=DEB48BC37658EAC11885AA1DFE8F8632CA2B49294C51C1BACC username=admin\u0026amp;password=admin request header请求头： #\rHost: mbinvest.tebon.com.cn Connection: close Content-Length: 358 Pragma: no-cache Cache-Control: no-cache tztWebdataEncrypt: 1 X-Requested-With: XMLHttpRequest User-Agent: Mozilla/5.0 (Linux; Android 6.0.1; MuMu Build/V417IR; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/91.0.4472.114 Mobile Safari/537.36;/dbzq Content-Type: application/x-www-form-urlencoded; Accept: */* Origin: https://mbinvest.tebon.com.cn Sec-Fetch-Site: same-origin Sec-Fetch-Mode: cors Sec-Fetch-Dest: empty Referer: https://mbinvest.tebon.com.cn/h5_vue/news/wealth-app/index.html Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 Cookie: username=guest; sensorsdata2015jssdkcross=%7B%22distinct_id%22%3A%221919cdf8e18175 0bdab4c7be43008-20331d51-557200 1919cdf8e19227%22%2C%22first_id%22%3A%22%22%2C%22props%22%3A%7B%22%24late st_traffic_source_type%22%3A%22%E7%9B%B4%E6%8E%A5%E6%B5%81%E9%87%8F%22%2C %22%24latest_search_keyword%22%3A%22%E6%9C%AA%E5%8F%96%E5%88%B0%E5%80%BC_ %E7%9B%B4%E6%8E%A5%E6%89%93%E5%BC%80%22%2C%22%24latest_referrer%22%3A%22% 22%7D%2C%22identities%22%3A%22eyIkaWRlbnRpdHlfY29va2llX2lkIjoiMTkxOWNkZjh lMTgxNzUtMGJkYWI0YzdiZTQzMDA4LTIwMzMxZDUxLTU1NzIwMC0xOTE5Y2RmOGUxOTIyNyJ9 %22%2C%22history_login_id%22%3A%7B%22name%22%3A%22%22%2C%22value%22%3A%22 %22%7D%2C%22%24device_id%22%3A%221919cdf8e18175-0bdab4c7be43008-20331d51 557200-1919cdf8e19227%22%7D; t1=DEB48BC37658EAC11885AA1DFE8F8632CA2B49294C51C1BACC 响应包： #\r状态码 #\r100-299 -\u0026gt; 响应正常\n30x -\u0026gt; 301 ⽹⻚发⽣了跳转\n40x -\u0026gt; 404 not found -\u0026gt; 请求的路径不存在 4开头的状态码代表请求的错误 包括但不限于权 限问题、请求路径问题 404 请求路径问题\n401 un auth -\u0026gt; 权限不够\n5xx \u0026gt; 501 internel error -\u0026gt; 5开头的状态码⼀般意味着服务器有内部错误\nHTTP/1.1 200 OK 状态码 Server: nginx/1.20.1 Date: Wed, 11 Sep 2024 08:37:06 GMT Content-Type: application/json;charset=utf-8 Connection: close Cache-Control: no-cache X-Content-Type-Options: nosniff X-Frame-Options: SAMEORIGIN X-XSS-Protection: 1; mode=block Access-Control-Allow-Credentials: true Content-Length: 235 { } \u0026#34;ACTION\u0026#34;: \u0026#34;46116\u0026#34;, \u0026#34;MAXCOUNT\u0026#34;: \u0026#34;10\u0026#34;, \u0026#34;ERRORNO\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;ERRORMESSAGE\u0026#34;: \u0026#34;未找到资讯信息\u0026#34;, \u0026#34;IDINDEX\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;INFOTITLEINDEX\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;DATESINDEX\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;MEDIAINDEX\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;FLAGINDEX\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;STOCKCODEINDEX\u0026#34;: \u0026#34;5\u0026#34; response header 响应头 #\rServer: nginx/1.20.1 Date: Wed, 11 Sep 2024 08:37:06 GMT Content-Type: application/json;charset=utf-8 -\u0026gt; 响应类型 Connection: close Cache-Control: no-cache X-Content-Type-Options: nosniff X-Frame-Options: SAMEORIGIN X-XSS-Protection: 1; mode=block Access-Control-Allow-Credentials: true Content-Length: 235 -\u0026gt; 响应⻓度 dirsearch 可以根据扫描得到的response的状态码来判断⽬标路径、⽂件 是否存在\n404 -\u0026gt; 不存在\n200 -\u0026gt; 存在\n301 -\u0026gt; 该路径不直接存在 -\u0026gt; 被重定向到另⼀个路径\n⼆级⽬录扫描 #\rTarget: http://112.124.71.224:18080/ [16:48:49] Starting: game/ [16:49:07] 200 - 158B - /game/www [16:49:25] 403 - 300B - /game/.ht_wsr.txt [16:49:25] 403 - 303B - /game/.htaccess.bak1 [16:49:25] 403 - 304B - /game/.htaccess_extra [16:49:25] 403 - 303B - /game/.htaccess.orig [16:49:25] 403 - 305B - /game/.htaccess.sample [16:49:25] 403 - 303B - /game/.htaccess_orig [16:49:25] 403 - 301B - /game/.htaccessOLD [16:49:25] 403 - 299B - /game/.htpasswds [16:49:25] 403 - 302B - /game/.htaccessOLD2 [16:49:26] 403 - 303B - /game/.htpasswd_test [16:49:25] 403 - 301B - /game/.htaccessBAK [16:49:25] 403 - 303B - /game/.htaccess.save [16:49:26] 403 - 300B - /game/.httr-oauth [16:49:25] 403 - 301B - /game/.htaccess_sc [16:50:34] 200 - 158B - /game/www.zip 得到了www.zip 备份⽂件\n端⼝扫描 #\rip : 112.124.71.224\n通过浏览器正常访问 发现返回空响应\n能说这个ip地址（服务器）没有任何的对外服务吗？\n1-65535个端⼝\n浏览器访问112.124.71.224 只探测了80\nhttps://112.124.71.224 -\u0026gt; 443\nnmap #\r使⽤nmap对112.124.71.224扫描了80端⼝\nnmap 112.124.71.224 -p 80 Starting Nmap 7.95 ( https://nmap.org ) at 2024-09-11 10:29 CST Nmap scan report for 112.124.71.224 Host is up (0.052s latency). PORT STATE SERVICE 80/tcp closed http Nmap done: 1 IP address (1 host up) scanned in 0.20 seconds 想让nmap帮我们扫描这台主机的所有端⼝? tcp三次握⼿\n第⼀次握⼿：\nclient(nmap) -\u0026gt; server(112.124.71.224:80) : syn 请求包\nserver -\u0026gt; client : ack 确认包\n如果只根据上⾯两个包就判定端⼝是否开放 在nmap属于半开扫描\n半开扫描的结果不⼀定准确\nclient -\u0026gt; 决定建⽴连接 -\u0026gt; syn+ack\nserver -\u0026gt; client -\u0026gt; ack\nnmap在默认情况下都是全连接扫描 -\u0026gt; 三次握⼿+ 四次挥⼿-sS -\u0026gt; 指定nmap进⾏半开扫描 2次握⼿ 提升速度 牺牲的精度\n特洛伊⽊⻢ -\u0026gt; 1个特征 -\u0026gt; ⽤过⼀次就⾃我销毁\n⽤过1次 取决于有没有完整的建⽴过1次tcp三次握⼿\nCTF解题模式、AWD局域⽹攻防竞赛\n靶机不会给你初始权限 提供低权限⽤户\n出题⼈会在靶机中放置⼀个特洛伊⽊⻢\nnc连接端⼝ 就可以得到⼀个shell\nnetcat 瑞⼠军⼑\nnc ip port nc 112.124.71.224 1445 -\u0026gt; $\u0026gt;id -\u0026gt; root\nnmap 112.124.71.224 -p 1-65535 -\u0026gt; ⽐赛的时候 如果直接nmap 会导致特洛伊⽊⻢⾃我销毁 -\u0026gt; -sS半开扫描可以解决这个问题\ntcp三次握⼿ 四次挥⼿\n只⽤了两次握⼿就判断了端⼝是否开放\nnmap收到ack的回复 ⽬标端⼝开放\nclient(nmap) -\u0026gt; server(112.124.71.224:80) : syn 请求包\nserver -\u0026gt; RST/FIN : ack 确认包\nnmap收到rst/fin回复 判定端⼝未开放\n为什么说端⼝未开放 有可能会回复 有可能不会回复？\n取决于端⼝是怎样的不开放\n1.112.124.71.224的确没有http服务\nnmap扫描 80/443 -\u0026gt; 不会回应\n2.防⽕墙 #\r112.124.71.224开放了http服务 但是限制了源ip地址\nnmap扫描80/443 -\u0026gt; 会回应 -\u0026gt; FIN/RST\n80/tcp close/open/filtered(过滤的)\n全端⼝扫描 #\rHost is up (0.051s latency). Not shown: 65521 closed tcp ports (conn-refused) PORT STATE 21/tcp 22/tcp 135/tcp open open SERVICE ftp ssh filtered msrpc 136/tcp 137/tcp filtered profile -\u0026gt; ⽂件传输协议 -\u0026gt; ssh远程连接linux服务器 filtered netbios-ns 138/tcp 139/tcp 445/tcp filtered netbios-dgm filtered netbios-ssn filtered microsoft-ds 135-139 445端⼝ 都是windows特有的端⼝ netbios samba服务 ⽂件共享 17010永恒之蓝漏洞 就是基于445端⼝的samba服务进⾏的攻击 政企的安全建设中 ⼀般认为445端⼝是⾼危端⼝ windowes 7 -\u0026gt; 永恒之蓝漏洞 导致全球千万台pc机 感染了勒索病毒 windows 10 -\u0026gt; 永恒之⿊ 影响⾯不如永恒之蓝⼴泛 593/tcp filtered http-rpc-epmap 4444/tcp filtered krb524 filtered -\u0026gt; 已过滤状态 阿⾥云防⽕墙默认不启⽤445端⼝ 系统⾃带的防⽕墙 5003/tcp open filemaker 5355/tcp filtered llmnr 18080/tcp open unknown -\u0026gt; unkown就是nmap没有匹配到指纹 80 -\u0026gt; http -\u0026gt; 实际建站不会使⽤默认80 -\u0026gt; tomcat / nginx -\u0026gt; 8080 服务器 和web应⽤ 是⼀⽐⼀的关系吗？ 不是 80 -\u0026gt; ⽹站A 8080 8081 18080 18081 使⽤⾼位端⼝启⽤web服务 40301/tcp open unknown Nmap done: 1 IP address (1 host up) scanned in 4063.19 seconds 扫描： 对112.124.71.224发起端⼝扫描\n我们的流量 是从当前主机直接到达了⽬标主机吗\n使⽤校园⽹：⽹络出⼝就是学校的公⽹IP（⽹关） -\u0026gt; ⽹关可能部署⼀些流量清洗的设备\n使⽤浏览器访问18080端⼝ 可以正常访问 这是因为浏览器访问的流量合法 不存在扫描器的特 征\nnmap特征明显 可能被校园⽹的流量清洗设备捕获 扫描结果被劫持\nQuestion and Answer #\r⽹络问题\n⽹卡NAT模式：· 安全问题如果虚拟机部署了靶场可能导致被其他⼈攻击对虚拟机造成损坏\n校园⽹问题 上游的校园⽹服务器 只会对1个校园⽹账号下发1个ip地址导致使⽤桥接模式的虚拟机获取不到ip地址 没⽹\npip问题 什么是pip?\npip是python官⽅的⽤于管理（安装、更新、卸载）python依赖（库、包）\npython3 -m pip install -r requirement.txt -\u0026gt; no moudule name pip\npython3安装pip -\u0026gt; curl bootstrap.com/get-pip.py -\u0026gt; python3 get-pip.py\n运⾏问题 域名 -\u0026gt; dns\n顶级域：.com .cn（中国特⾊顶级域） .gov政府 .gov.cn（中国政府的顶级域） .gov(美 国政府)\n.org 组织\n⼦域名 -\u0026gt; 在主域名之下 -\u0026gt; mo60.cn -\u0026gt; blog.mo60.cn / tools.mo60.cn\n爆破 #\rkali⾃带字典 #\r/usr/share/wordlists/rockyou.tar.gz -\u0026gt; rockyou是美国情报机构\n$\u0026gt; zcat rockyou.txt.gz \u0026gt; /root/password.txt $\u0026gt; head -n 10 /root/password.txt /usr/share/wordlists/ -\u0026gt; kali存放字典的⽬录\n靶场 #\rhttp://112.124.71.224:18080/login.php\nhtml #\rhyper text mark language -\u0026gt; 超⽂本标记语⾔\n以标签的⽅式进⾏编写 标签是成对的\n\u0026lt;!DOCTYPE html PUBLIC \u0026#34;-//W3C//DTD XHTML 1.0 Strict//EN\u0026#34; \u0026#34;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\u0026#34;\u0026gt; -\u0026gt; 指代了html的 标准 \u0026lt;html\u0026gt; ... html代码会被浏览器渲染 呈现出画⾯给⽤户 \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;⽹⻚标题\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; ... -\u0026gt; ⽹⻚的主体内容 \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; body -\u0026gt; 表单 -\u0026gt; 表单是html⽹⻚前端与后端交互的介质\n表单\n\u0026lt;form action=\u0026#34;#\u0026#34; method=\u0026#34;GET\u0026#34;\u0026gt; Username:\u0026lt;br\u0026gt; 控件 \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34;\u0026gt;\u0026lt;br\u0026gt; Password:\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; autocomplete=\u0026#34;off\u0026#34; name=\u0026#34;password\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; name=\u0026#34;Login\u0026#34;\u0026gt; 控件最重要的属性 就是name值 \u0026lt;/form\u0026gt; 前端：浏览器中看到的⻚⾯ 统⼀都是前端\n后端：逻辑处理 ⽐如百度热搜 热搜榜单 后端做的逻辑处理\n账号：admin\n密码：password\n前端：在浏览器中能看到的⻚⾯ 全都属于前端 /admin/index.php -》 后台管理界⾯ -\u0026gt;\n前端\n后端：逻辑代码\n后端会接收前端的传值 -\u0026gt; 前端就是我们⽤户操作过程中会传值\ncookie 饼⼲\ncookie -》 session 会话\ncookie session机制 就是为了解决http⽆状态性\n⽹站的注册登录功能\n登录之后 服务器就会向浏览器写⼊cookie\n浏览器发起的每个请求 都会携带cookie\ncookie 会存储在浏览器\nsession 存储在服务器\ncsrf漏洞 -\u0026gt; 跨站请求伪造\nhttp://112.124.71.224:18080/vulnerabilities/csrf/?password_new=password\u0026amp;password_\nconf=password\u0026amp;Change=Change#\nadmin ⽤户 改密码\nmay -\u0026gt;http://112.124.71.224:18080/vulnerabilities/csrf/?password_new=password\u0026amp;pas\nsword_conf=password\u0026amp;Change=Change#\nmay在不知情况的情况下 修改了密码\n密码 参数也会加密\n短链接\nsession cookie这⼀套机制导致的\ncookie 记录当前⽤户的身份\n本质上要解决的是 服务器\ntoken -\u0026gt; 令牌\ntoken 1个token对应1次⽹络请求\nadmin:http://112.124.71.224:18080/vulnerabilities/csrf/?password_new=password\u0026amp;pas\nsword_conf=password\u0026amp;Change=Change\u0026amp;token=fdjaf84384u83ruf3483\nmay：http://112.124.71.224:18080/vulnerabilities/csrf/?password_new=password\u0026amp;pass\nword_conf=password\u0026amp;Change=Change\u0026amp;token=fdjaf84384u83ruf3483\ntoken⻛险\n是在当前请求的响应中把下⼀次请求要给⽤户的token直接展示了\ntcp/ip -\u0026gt; 有状态性\n应⽤层 http -\u0026gt; ⽆状态性\n表示层\n会话层\n传输层\n⽹络层\n数据链路层\n物理层\n响应\n200 OK -\u0026gt; http状态码\n100-299 -\u0026gt; 请求是没有发⽣错误\n300 -\u0026gt; 399 -\u0026gt; 服务器发⽣了重定向\n400 -\u0026gt; 499 404 -\u0026gt; 404 not found -\u0026gt; 请求路径、资源不存在 401 权限不够 4xx状态码就是\n请求有问题\n500 -\u0026gt; 599 5xx⼀般是服务器内部出问题 501 http 501 interl error 内部错误\nHTTP/1.1 200 OK Date: Thu, 12 Sep 2024 08:33:37 GMT Server: Apache/2.4.7 (Ubuntu) X-Powered-By: PHP/5.5.9-1ubuntu4.20 Expires: Tue, 23 Jun 2009 12:00:00 GMT Cache-Control: no-cache, must-revalidate Pragma: no-cache Vary: Accept-Encoding Content-Length: 4943 -\u0026gt; 响应体⼤⼩ Connection: close Content-Type: text/html;charset=utf-8 -\u0026gt; 响应类型 response header 响应头 \u0026lt;!DOCTYPE html PUBLIC \u0026#34;-//W3C//DTD XHTML 1.0 Strict//EN\u0026#34; \u0026#34;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\u0026#34;\u0026gt; \u0026lt;html xmlns=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html; charset=UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Vulnerability: Brute Force :: Damn Vulnerable Web Application (DVWA) v1.9\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;../../dvwa/css/main.css\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;\\image/ico\u0026#34; href=\u0026#34;../../favicon.ico\u0026#34; /\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;../../dvwa/js/dvwaPage.js\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body class=\u0026#34;home\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;header\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;../../dvwa/images/logo.png\u0026#34; alt=\u0026#34;Damn Vulnerable Web Application\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;main_menu\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;main_menu_padded\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;menuBlocks\u0026#34;\u0026gt;\u0026lt;li onclick=\u0026#34;window.location=\u0026#39;../../.\u0026#39;\u0026#34; class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;../../.\u0026#34;\u0026gt;Home\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li onclick=\u0026#34;window.location=\u0026#39;../../instructions.php\u0026#39;\u0026#34; class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;../../instructions.php\u0026#34;\u0026gt;Instructions\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li onclick=\u0026#34;window.location=\u0026#39;../../setup.php\u0026#39;\u0026#34; class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;../../setup.php\u0026#34;\u0026gt;Setup / Reset DB\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;\u0026lt;ul class=\u0026#34;menuBlocks\u0026#34;\u0026gt;\u0026lt;li onclick=\u0026#34;window.location=\u0026#39;../../vulnerabilities/brute/\u0026#39;\u0026#34; class=\u0026#34;selected\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;../../vulnerabilities/brute/\u0026#34;\u0026gt;Brute Force\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li onclick=\u0026#34;window.location=\u0026#39;../../vulnerabilities/exec/\u0026#39;\u0026#34; class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;../../vulnerabilities/exec/\u0026#34;\u0026gt;Command Injection\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li onclick=\u0026#34;window.location=\u0026#39;../../vulnerabilities/csrf/\u0026#39;\u0026#34; class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;../../vulnerabilities/csrf/\u0026#34;\u0026gt;CSRF\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li onclick=\u0026#34;window.location=\u0026#39;../../vulnerabilities/fi/.? page=include.php\u0026#39;\u0026#34; class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;../../vulnerabilities/fi/.? page=include.php\u0026#34;\u0026gt;File Inclusion\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li onclick=\u0026#34;window.location=\u0026#39;../../vulnerabilities/upload/\u0026#39;\u0026#34; class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;../../vulnerabilities/upload/\u0026#34;\u0026gt;File Upload\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li onclick=\u0026#34;window.location=\u0026#39;../../vulnerabilities/captcha/\u0026#39;\u0026#34; class=\u0026#34;\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;../../vulnerabilities/captcha/\u0026#34;\u0026gt;Insecure CAPTCHA\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li onclick=\u0026#34;window.location=\u0026#39;../../vulnerabilities/sqli/\u0026#39;\u0026#34; class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;../../vulnerabilities/sqli/\u0026#34;\u0026gt;SQL Injection\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li onclick=\u0026#34;window.location=\u0026#39;../../vulnerabilities/sqli_blind/\u0026#39;\u0026#34; class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;../../vulnerabilities/sqli_blind/\u0026#34;\u0026gt;SQL Injection (Blind)\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li onclick=\u0026#34;window.location=\u0026#39;../../vulnerabilities/xss_r/\u0026#39;\u0026#34; class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;../../vulnerabilities/xss_r/\u0026#34;\u0026gt;XSS (Reflected)\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li onclick=\u0026#34;window.location=\u0026#39;../../vulnerabilities/xss_s/\u0026#39;\u0026#34; class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;../../vulnerabilities/xss_s/\u0026#34;\u0026gt;XSS (Stored)\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;\u0026lt;ul class=\u0026#34;menuBlocks\u0026#34;\u0026gt;\u0026lt;li onclick=\u0026#34;window.location=\u0026#39;../../security.php\u0026#39;\u0026#34; class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;../../security.php\u0026#34;\u0026gt;DVWA Security\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li onclick=\u0026#34;window.location=\u0026#39;../../phpinfo.php\u0026#39;\u0026#34; class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;../../phpinfo.php\u0026#34;\u0026gt;PHP Info\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li onclick=\u0026#34;window.location=\u0026#39;../../about.php\u0026#39;\u0026#34; class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;../../about.php\u0026#34;\u0026gt;About\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;\u0026lt;ul class=\u0026#34;menuBlocks\u0026#34;\u0026gt;\u0026lt;li onclick=\u0026#34;window.location=\u0026#39;../../logout.php\u0026#39;\u0026#34; class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;../../logout.php\u0026#34;\u0026gt;Logout\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;main_body\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;body_padded\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Vulnerability: Brute Force\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;vulnerable_code_area\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;Login\u0026lt;/h2\u0026gt; \u0026lt;form action=\u0026#34;#\u0026#34; method=\u0026#34;GET\u0026#34;\u0026gt; Username:\u0026lt;br /\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34;\u0026gt;\u0026lt;br /\u0026gt; Password:\u0026lt;br /\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; AUTOCOMPLETE=\u0026#34;off\u0026#34; name=\u0026#34;password\u0026#34;\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; name=\u0026#34;Login\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;pre\u0026gt;\u0026lt;br /\u0026gt;Username and/or password incorrect.\u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;h2\u0026gt;More Information\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;http://hiderefer.com/? https://www.owasp.org/index.php/Testing_for_Brute_Force_(OWASP-AT-004)\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;https://www.owasp.org/index.php/Testing_for_Brute_Force_( OWASP-AT-004)\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;http://hiderefer.com/? http://www.symantec.com/connect/articles/password-crackers-ensuring security-your-password\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;http://www.symantec.com/connect/articles/password crackers-ensuring-security-your-password\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;http://hiderefer.com/? http://www.sillychicken.co.nz/Security/how-to-brute-force-http-forms-in windows.html\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;http://www.sillychicken.co.nz/Security/how to-brute-force-http-forms-in-windows.html\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;br /\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;clear\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;system_info\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;View Help\u0026#34; class=\u0026#34;popup_button\u0026#34; onClick=\u0026#34;javascript:popUp( \u0026#39;../../vulnerabilities/view_help.php? id=brute\u0026amp;security=low\u0026#39; )\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;View Source\u0026#34; class=\u0026#34;popup_button\u0026#34; onClick=\u0026#34;javascript:popUp( \u0026#39;../../vulnerabilities/view_source.php?id=brute\u0026amp;security=low\u0026#39; )\u0026#34;\u0026gt; \u0026lt;div align=\u0026#34;left\u0026#34;\u0026gt;\u0026lt;em\u0026gt;Username:\u0026lt;/em\u0026gt; admin\u0026lt;br /\u0026gt;\u0026lt;em\u0026gt;Security Level:\u0026lt;/em\u0026gt; low\u0026lt;br /\u0026gt;\u0026lt;em\u0026gt;PHPIDS:\u0026lt;/em\u0026gt; disabled\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;footer\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Damn Vulnerable Web Application (DVWA) v1.9\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","date":"2024-09-10","externalUrl":null,"permalink":"/networkengineering/penetrationtesting/","section":"NetworkEngineerings","summary":"DVWA暴力破解攻略 # 一、 靶场考核点 # 弱口令(weak password) 没有","title":"DVWA暴力破解攻略","type":"networkengineering"},{"content":"","date":"2024-09-10","externalUrl":null,"permalink":"/tags/network-engineering/","section":"Tags","summary":"","title":"Network Engineering","type":"tags"},{"content":"","date":"2024-09-10","externalUrl":null,"permalink":"/networkengineering/","section":"NetworkEngineerings","summary":"","title":"NetworkEngineerings","type":"networkengineering"},{"content":"","date":"2024-08-23","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"2024-08-23","externalUrl":null,"permalink":"/algorithm/","section":"Algorithms","summary":"","title":"Algorithms","type":"algorithm"},{"content":"\r二叉树理论基础篇 #\r递归查找 #\r递归算法的三个要素\n1.确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。\n2.确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。\n3.确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。\n前序遍历 #\r1.确定递归函数的参数和返回值：因为要打印出前序遍历节点的数值，所以参数里需要传入vector来放节点的数值，除了这一点就不需要再处理什么数据了也不需要有返回值，所以递归函数返回类型就是void，代码如下：\nvoid traversal(TreeNode* cur, vector\u0026lt;int\u0026gt;\u0026amp; vec); 2.确定终止条件：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要结束了，所以如果当前遍历的这个节点是空，就直接return，代码如下：\nif (cur == NULL) return; 3.确定单层递归的逻辑：前序遍历是中左右的顺序，所以在单层递归的逻辑，是要先取中节点的数值，代码如下：\nvec.push_back(cur-\u0026gt;val); // 中 traversal(cur-\u0026gt;left, vec); // 左 traversal(cur-\u0026gt;right, vec); // 右 其他语言版本 #\r// 前序遍历·递归·LC144_二叉树的前序遍历 class Solution { public List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;Integer\u0026gt;(); preorder(root, result); return result; } public void preorder(TreeNode root, List\u0026lt;Integer\u0026gt; result) { if (root == null) { return; } result.add(root.val); preorder(root.left, result); preorder(root.right, result); } } // 中序遍历·递归·LC94_二叉树的中序遍历 class Solution { public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); inorder(root, res); return res; } void inorder(TreeNode root, List\u0026lt;Integer\u0026gt; list) { if (root == null) { return; } inorder(root.left, list); list.add(root.val); // 注意这一句 inorder(root.right, list); } } // 后序遍历·递归·LC145_二叉树的后序遍历 class Solution { public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); postorder(root, res); return res; } void postorder(TreeNode root, List\u0026lt;Integer\u0026gt; list) { if (root == null) { return; } postorder(root.left, list); postorder(root.right, list); list.add(root.val); // 注意这一句 } } ","date":"2024-08-23","externalUrl":null,"permalink":"/algorithm/tree/","section":"Algorithms","summary":"二叉树理论基础篇 # 递归查找 # 递归算法的三个要素 1.确定递归函","title":"二叉树","type":"algorithm"},{"content":"\r二叉树理论基础篇 #\r递归查找 #\r递归算法的三个要素\n1.确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。\n2.确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。\n3.确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。\n前序遍历 #\r1.确定递归函数的参数和返回值：因为要打印出前序遍历节点的数值，所以参数里需要传入vector来放节点的数值，除了这一点就不需要再处理什么数据了也不需要有返回值，所以递归函数返回类型就是void，代码如下：\nvoid traversal(TreeNode* cur, vector\u0026lt;int\u0026gt;\u0026amp; vec); 2.确定终止条件：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要结束了，所以如果当前遍历的这个节点是空，就直接return，代码如下：\nif (cur == NULL) return; 3.确定单层递归的逻辑：前序遍历是中左右的顺序，所以在单层递归的逻辑，是要先取中节点的数值，代码如下：\nvec.push_back(cur-\u0026gt;val); // 中 traversal(cur-\u0026gt;left, vec); // 左 traversal(cur-\u0026gt;right, vec); // 右 其他语言版本 #\r// 前序遍历·递归·LC144_二叉树的前序遍历 class Solution { public List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;Integer\u0026gt;(); preorder(root, result); return result; } public void preorder(TreeNode root, List\u0026lt;Integer\u0026gt; result) { if (root == null) { return; } result.add(root.val); preorder(root.left, result); preorder(root.right, result); } } // 中序遍历·递归·LC94_二叉树的中序遍历 class Solution { public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); inorder(root, res); return res; } void inorder(TreeNode root, List\u0026lt;Integer\u0026gt; list) { if (root == null) { return; } inorder(root.left, list); list.add(root.val); // 注意这一句 inorder(root.right, list); } } // 后序遍历·递归·LC145_二叉树的后序遍历 class Solution { public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); postorder(root, res); return res; } void postorder(TreeNode root, List\u0026lt;Integer\u0026gt; list) { if (root == null) { return; } postorder(root.left, list); postorder(root.right, list); list.add(root.val); // 注意这一句 } } ","date":"2024-08-23","externalUrl":null,"permalink":"/all/algorithm/tree/","section":"Alls","summary":"二叉树理论基础篇 # 递归查找 # 递归算法的三个要素 1.确定递归函","title":"二叉树","type":"all"},{"content":"\r链表 #\r基础知识 #\r链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。 链表的入口节点称为链表的头结点也就是head。 1.链表的类型 #\r1.1单链表 #\r单链表中的指针域只能指向节点的下一个节点。\n1.2双链表 #\r双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。 双链表 既可以向前查询也可以向后查询。 1.3循环链表 #\r循环链表，顾名思义，就是链表首尾相连。 循环链表可以用来解决约瑟夫环问题。\n2.链表的存储方式 #\r数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。 链表是通过指针域的指针链接在内存中各个节点。 所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。\n3.链表的定义(JAVA) #\rpublic class ListNode { // 结点的值 int val; // 下一个结点 ListNode next; // 节点的构造函数(无参) public ListNode() { } // 节点的构造函数(有一个参数) public ListNode(int val) { this.val = val; } // 节点的构造函数(有两个参数) public ListNode(int val, ListNode next) { this.val = val; this.next = next; } } ","date":"2024-08-21","externalUrl":null,"permalink":"/algorithm/linkedlist/","section":"Algorithms","summary":"链表 # 基础知识 # 链表是一种通过指针串联在一起的线性结构，每一","title":"链表","type":"algorithm"},{"content":"\r链表 #\r基础知识 #\r链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。 链表的入口节点称为链表的头结点也就是head。 1.链表的类型 #\r1.1单链表 #\r单链表中的指针域只能指向节点的下一个节点。\n1.2双链表 #\r双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。 双链表 既可以向前查询也可以向后查询。 1.3循环链表 #\r循环链表，顾名思义，就是链表首尾相连。 循环链表可以用来解决约瑟夫环问题。\n2.链表的存储方式 #\r数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。 链表是通过指针域的指针链接在内存中各个节点。 所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。\n3.链表的定义(JAVA) #\rpublic class ListNode { // 结点的值 int val; // 下一个结点 ListNode next; // 节点的构造函数(无参) public ListNode() { } // 节点的构造函数(有一个参数) public ListNode(int val) { this.val = val; } // 节点的构造函数(有两个参数) public ListNode(int val, ListNode next) { this.val = val; this.next = next; } } ","date":"2024-08-21","externalUrl":null,"permalink":"/all/algorithm/linkedlist/","section":"Alls","summary":"链表 # 基础知识 # 链表是一种通过指针串联在一起的线性结构，每一","title":"链表","type":"all"},{"content":"\r哈希表理论基础 #\r哈希表 #\r哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素，如下图所示： 那么哈希表能解决什么问题呢，一般哈希表都是用来快速判断一个元素是否出现集合里。\n例如要查询一个名字是否在这所学校里。\n要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到。\n我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。\n将学生姓名映射到哈希表上就涉及到了hash function ，也就是哈希函数。\n哈希函数 #\r哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。\n哈希函数如下图所示，通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。\n如果hashCode得到的数值大于 哈希表的大小了，也就是大于tableSize了，怎么办呢？\n此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作，这样我们就保证了学生姓名一定可以映射到哈希表上了。\n此时问题又来了，哈希表我们刚刚说过，就是一个数组。\n如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。\n接下来哈希碰撞登场\n哈希碰撞 #\r如图所示，小李和小王都映射到了索引下标 1 的位置，这一现象叫做哈希碰撞。\n一般哈希碰撞有两种解决方法， 拉链法和线性探测法。\n拉链法 #\r（数据规模是dataSize， 哈希表的大小为tableSize）\n其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。\n线性探测法 #\r使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。\n例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。如图所示：\n其实关于哈希碰撞还有非常多的细节，感兴趣的同学可以再好好研究一下，这里我就不再赘述了。\n常见的三种哈希结构 #\r当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。\n数组 set （集合） map(映射) 这里数组就没啥可说的了，我们来看一下set。\n在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：\nstd::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。 std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。\n当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。\n那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。\n其他语言例如：java里的HashMap ，TreeMap 都是一样的原理。可以灵活贯通。\n虽然std::set和std::multiset 的底层实现基于红黑树而非哈希表，它们通过红黑树来索引和存储数据。不过给我们的使用方式，还是哈希法的使用方式，即依靠键（key）来访问值（value）。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。std::map也是一样的道理。\n这里在说一下，一些C++的经典书籍上 例如STL源码剖析，说到了hash_set hash_map，这个与unordered_set，unordered_map又有什么关系呢？\n实际上功能都是一样一样的， 但是unordered_set在C++11的时候被引入标准库了，而hash_set并没有，所以建议还是使用unordered_set比较好，这就好比一个是官方认证的，hash_set，hash_map 是C++11标准之前民间高手自发造的轮子。 std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。\n当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。\n那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。\n其他语言例如：java里的HashMap ，TreeMap 都是一样的原理。可以灵活贯通。\n虽然std::set和std::multiset 的底层实现基于红黑树而非哈希表，它们通过红黑树来索引和存储数据。不过给我们的使用方式，还是哈希法的使用方式，即依靠键（key）来访问值（value）。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。std::map也是一样的道理。\n这里在说一下，一些C++的经典书籍上 例如STL源码剖析，说到了hash_set hash_map，这个与unordered_set，unordered_map又有什么关系呢？\n实际上功能都是一样一样的， 但是unordered_set在C++11的时候被引入标准库了，而hash_set并没有，所以建议还是使用unordered_set比较好，这就好比一个是官方认证的，hash_set，hash_map 是C++11标准之前民间高手自发造的轮子。\n总结 #\r总结一下，当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。\n但是哈希法也是牺牲了空间换取了时间，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。\n如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！\n","date":"2024-08-20","externalUrl":null,"permalink":"/algorithm/hash/basicknowledge/","section":"Algorithms","summary":"哈希表理论基础 # 哈希表 # 哈希表中关键码就是数组的索引下标，然","title":"哈希表基础知识","type":"algorithm"},{"content":"\r哈希表理论基础 #\r哈希表 #\r哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素，如下图所示： 那么哈希表能解决什么问题呢，一般哈希表都是用来快速判断一个元素是否出现集合里。\n例如要查询一个名字是否在这所学校里。\n要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到。\n我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。\n将学生姓名映射到哈希表上就涉及到了hash function ，也就是哈希函数。\n哈希函数 #\r哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。\n哈希函数如下图所示，通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。\n如果hashCode得到的数值大于 哈希表的大小了，也就是大于tableSize了，怎么办呢？\n此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作，这样我们就保证了学生姓名一定可以映射到哈希表上了。\n此时问题又来了，哈希表我们刚刚说过，就是一个数组。\n如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。\n接下来哈希碰撞登场\n哈希碰撞 #\r如图所示，小李和小王都映射到了索引下标 1 的位置，这一现象叫做哈希碰撞。\n一般哈希碰撞有两种解决方法， 拉链法和线性探测法。\n拉链法 #\r（数据规模是dataSize， 哈希表的大小为tableSize）\n其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。\n线性探测法 #\r使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。\n例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。如图所示：\n其实关于哈希碰撞还有非常多的细节，感兴趣的同学可以再好好研究一下，这里我就不再赘述了。\n常见的三种哈希结构 #\r当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。\n数组 set （集合） map(映射) 这里数组就没啥可说的了，我们来看一下set。\n在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：\nstd::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。 std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。\n当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。\n那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。\n其他语言例如：java里的HashMap ，TreeMap 都是一样的原理。可以灵活贯通。\n虽然std::set和std::multiset 的底层实现基于红黑树而非哈希表，它们通过红黑树来索引和存储数据。不过给我们的使用方式，还是哈希法的使用方式，即依靠键（key）来访问值（value）。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。std::map也是一样的道理。\n这里在说一下，一些C++的经典书籍上 例如STL源码剖析，说到了hash_set hash_map，这个与unordered_set，unordered_map又有什么关系呢？\n实际上功能都是一样一样的， 但是unordered_set在C++11的时候被引入标准库了，而hash_set并没有，所以建议还是使用unordered_set比较好，这就好比一个是官方认证的，hash_set，hash_map 是C++11标准之前民间高手自发造的轮子。 std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。\n当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。\n那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。\n其他语言例如：java里的HashMap ，TreeMap 都是一样的原理。可以灵活贯通。\n虽然std::set和std::multiset 的底层实现基于红黑树而非哈希表，它们通过红黑树来索引和存储数据。不过给我们的使用方式，还是哈希法的使用方式，即依靠键（key）来访问值（value）。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。std::map也是一样的道理。\n这里在说一下，一些C++的经典书籍上 例如STL源码剖析，说到了hash_set hash_map，这个与unordered_set，unordered_map又有什么关系呢？\n实际上功能都是一样一样的， 但是unordered_set在C++11的时候被引入标准库了，而hash_set并没有，所以建议还是使用unordered_set比较好，这就好比一个是官方认证的，hash_set，hash_map 是C++11标准之前民间高手自发造的轮子。\n总结 #\r总结一下，当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。\n但是哈希法也是牺牲了空间换取了时间，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。\n如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！\n","date":"2024-08-20","externalUrl":null,"permalink":"/all/algorithm/hash/basicknowledge/","section":"Alls","summary":"哈希表理论基础 # 哈希表 # 哈希表中关键码就是数组的索引下标，然","title":"哈希表基础知识","type":"all"},{"content":"\r题目 #\r给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。\n示例 1: 输入: s = \u0026ldquo;anagram\u0026rdquo;, t = \u0026ldquo;nagaram\u0026rdquo; 输出: true\n示例 2: 输入: s = \u0026ldquo;rat\u0026rdquo;, t = \u0026ldquo;car\u0026rdquo; 输出: false\n说明: 你可以假设字符串只包含小写字母。\n思路 #\r先看暴力的解法，两层for循环，同时还要记录字符是否重复出现，很明显时间复杂度是 O(n^2)。\n暴力的方法这里就不做介绍了，直接看一下有没有更优的方式。\n数组其实就是一个简单哈希表，而且这道题目中字符串只有小写字符，那么就可以定义一个数组，来记录字符串s里字符出现的次数。\n如果对哈希表的理论基础关于数组，set，map不了解的话可以看这篇：关于哈希表，你该了解这些！(opens new window)\n需要定义一个多大的数组呢，定一个数组叫做record，大小为26 就可以了，初始化为0，因为字符a到字符z的ASCII也是26个连续的数值。\n定义一个数组叫做record用来上记录字符串s里字符出现的次数。\n需要把字符映射到数组也就是哈希表的索引下标上，因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。\n再遍历 字符串s的时候，只需要将 s[i] - ‘a’ 所在的元素做+1 操作即可，并不需要记住字符a的ASCII，只要求出一个相对数值就可以了。 这样就将字符串s中字符出现的次数，统计出来了。\n那看一下如何检查字符串t中是否出现了这些字符，同样在遍历字符串t的时候，对t中出现的字符映射哈希表索引上的数值再做-1的操作。\n那么最后检查一下，record数组如果有的元素不为零0，说明字符串s和t一定是谁多了字符或者谁少了字符，return false。\n最后如果record数组所有元素都为零0，说明字符串s和t是字母异位词，return true。\n时间复杂度为O(n)，空间上因为定义是的一个常量大小的辅助数组，所以空间复杂度为O(1)。\n/** * 242. 有效的字母异位词 字典解法 * 时间复杂度O(m+n) 空间复杂度O(1) */ class Solution { public boolean isAnagram(String s, String t) { int[] record = new int[26]; for (int i = 0; i \u0026lt; s.length(); i++) { record[s.charAt(i) - \u0026#39;a\u0026#39;]++; // 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了 } for (int i = 0; i \u0026lt; t.length(); i++) { record[t.charAt(i) - \u0026#39;a\u0026#39;]--; } for (int count: record) { if (count != 0) { // record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。 return false; } } return true; // record数组所有元素都为零0，说明字符串s和t是字母异位词 } } ","date":"2024-08-20","externalUrl":null,"permalink":"/algorithm/hash/validalphabeticwords/","section":"Algorithms","summary":"题目 # 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字","title":"有效的字母异位词","type":"algorithm"},{"content":"\r题目 #\r给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。\n示例 1: 输入: s = \u0026ldquo;anagram\u0026rdquo;, t = \u0026ldquo;nagaram\u0026rdquo; 输出: true\n示例 2: 输入: s = \u0026ldquo;rat\u0026rdquo;, t = \u0026ldquo;car\u0026rdquo; 输出: false\n说明: 你可以假设字符串只包含小写字母。\n思路 #\r先看暴力的解法，两层for循环，同时还要记录字符是否重复出现，很明显时间复杂度是 O(n^2)。\n暴力的方法这里就不做介绍了，直接看一下有没有更优的方式。\n数组其实就是一个简单哈希表，而且这道题目中字符串只有小写字符，那么就可以定义一个数组，来记录字符串s里字符出现的次数。\n如果对哈希表的理论基础关于数组，set，map不了解的话可以看这篇：关于哈希表，你该了解这些！(opens new window)\n需要定义一个多大的数组呢，定一个数组叫做record，大小为26 就可以了，初始化为0，因为字符a到字符z的ASCII也是26个连续的数值。\n定义一个数组叫做record用来上记录字符串s里字符出现的次数。\n需要把字符映射到数组也就是哈希表的索引下标上，因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。\n再遍历 字符串s的时候，只需要将 s[i] - ‘a’ 所在的元素做+1 操作即可，并不需要记住字符a的ASCII，只要求出一个相对数值就可以了。 这样就将字符串s中字符出现的次数，统计出来了。\n那看一下如何检查字符串t中是否出现了这些字符，同样在遍历字符串t的时候，对t中出现的字符映射哈希表索引上的数值再做-1的操作。\n那么最后检查一下，record数组如果有的元素不为零0，说明字符串s和t一定是谁多了字符或者谁少了字符，return false。\n最后如果record数组所有元素都为零0，说明字符串s和t是字母异位词，return true。\n时间复杂度为O(n)，空间上因为定义是的一个常量大小的辅助数组，所以空间复杂度为O(1)。\n/** * 242. 有效的字母异位词 字典解法 * 时间复杂度O(m+n) 空间复杂度O(1) */ class Solution { public boolean isAnagram(String s, String t) { int[] record = new int[26]; for (int i = 0; i \u0026lt; s.length(); i++) { record[s.charAt(i) - \u0026#39;a\u0026#39;]++; // 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了 } for (int i = 0; i \u0026lt; t.length(); i++) { record[t.charAt(i) - \u0026#39;a\u0026#39;]--; } for (int count: record) { if (count != 0) { // record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。 return false; } } return true; // record数组所有元素都为零0，说明字符串s和t是字母异位词 } } ","date":"2024-08-20","externalUrl":null,"permalink":"/all/algorithm/hash/validalphabeticwords/","section":"Alls","summary":"题目 # 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字","title":"有效的字母异位词","type":"all"},{"content":"\r数组 #\r二分查找 #\r第一种写法：target在[left,right]区间\nclass solution{ public int search(int[] nums,int target) { if(target \u0026lt; nums[0] || target\u0026gt; nums[nums.length-1]){ return -1; } int left=0,right= nums.length-1; while(left \u0026lt;= right){ int middle=left+((right-left)\u0026gt;\u0026gt;1); if(nums[middle]==target){ return middle; } else if(nums[middle]\u0026gt;target){ right=middle-1; } else (nums[middle]\u0026lt;target) { left=middle+1; } } return -1; } } ","date":"2024-08-15","externalUrl":null,"permalink":"/algorithm/mid/","section":"Algorithms","summary":"数组 # 二分查找 # 第一种写法：target在[left,rig","title":"二分查找","type":"algorithm"},{"content":"\r数组 #\r二分查找 #\r第一种写法：target在[left,right]区间\nclass solution{ public int search(int[] nums,int target) { if(target \u0026lt; nums[0] || target\u0026gt; nums[nums.length-1]){ return -1; } int left=0,right= nums.length-1; while(left \u0026lt;= right){ int middle=left+((right-left)\u0026gt;\u0026gt;1); if(nums[middle]==target){ return middle; } else if(nums[middle]\u0026gt;target){ right=middle-1; } else (nums[middle]\u0026lt;target) { left=middle+1; } } return -1; } } ","date":"2024-08-15","externalUrl":null,"permalink":"/all/algorithm/mid/","section":"Alls","summary":"数组 # 二分查找 # 第一种写法：target在[left,rig","title":"二分查找","type":"all"},{"content":"\r栈与队列理论基础 #\r用栈实现队列 #\rclass MyQueue { Stack\u0026lt;Integer\u0026gt; stackIn; Stack\u0026lt;Integer\u0026gt; stackOut; /** Initialize your data structure here. */ public MyQueue() { stackIn = new Stack\u0026lt;\u0026gt;(); // 负责进栈 stackOut = new Stack\u0026lt;\u0026gt;(); // 负责出栈 } /** Push element x to the back of queue. */ public void push(int x) { stackIn.push(x); } /** Removes the element from in front of queue and returns that element. */ public int pop() { dumpstackIn(); return stackOut.pop(); } /** Get the front element. */ public int peek() { dumpstackIn(); return stackOut.peek(); } /** Returns whether the queue is empty. */ public boolean empty() { return stackIn.isEmpty() \u0026amp;\u0026amp; stackOut.isEmpty(); } // 如果stackOut为空，那么将stackIn中的元素全部放到stackOut中 private void dumpstackIn(){ if (!stackOut.isEmpty()) return; while (!stackIn.isEmpty()){ stackOut.push(stackIn.pop()); } } } 用队列实现栈 #\r队列是先进先出的规则，把一个队列中的数据导入另一个队列中，数据的顺序并没有变，并没有变成先进后出的顺序。\n所以用栈实现队列， 和用队列实现栈的思路还是不一样的，这取决于这两个数据结构的性质。\n但是依然还是要用两个队列来模拟栈，只不过没有输入和输出的关系，而是另一个队列完全用来备份的！\n如下面动画所示，用两个队列que1和que2实现队列的功能，que2其实完全就是一个备份的作用，把que1最后面的元素以外的元素都备份到que2，然后弹出最后面的元素，再把其他元素从que2导回que1。\n使用两个queue实习栈 #\rclass MyStack { Queue\u0026lt;Integer\u0026gt; queue1; // 和栈中保持一样元素的队列 Queue\u0026lt;Integer\u0026gt; queue2; // 辅助队列 /** Initialize your data structure here. */ public MyStack() { queue1 = new LinkedList\u0026lt;\u0026gt;(); queue2 = new LinkedList\u0026lt;\u0026gt;(); } /** Push element x onto stack. */ public void push(int x) { queue2.offer(x); // 先放在辅助队列中 while (!queue1.isEmpty()){ queue2.offer(queue1.poll()); } Queue\u0026lt;Integer\u0026gt; queueTemp; queueTemp = queue1; queue1 = queue2; queue2 = queueTemp; // 最后交换queue1和queue2，将元素都放到queue1中 } /** Removes the element on top of the stack and returns that element. */ public int pop() { return queue1.poll(); // 因为queue1中的元素和栈中的保持一致，所以这个和下面两个的操作只看queue1即可 } /** Get the top element. */ public int top() { return queue1.peek(); } /** Returns whether the stack is empty. */ public boolean empty() { return queue1.isEmpty(); } } 有效的括号 #\r","date":"2024-08-10","externalUrl":null,"permalink":"/algorithm/stack/","section":"Algorithms","summary":"栈与队列理论基础 # 用栈实现队列 # class MyQueue { Stack\u0026lt;Integer\u0026gt; stackIn; Stack\u0026lt;Integer\u0026gt; stackOut; /** Initialize your data structure here. */","title":"栈","type":"algorithm"},{"content":"\r栈与队列理论基础 #\r用栈实现队列 #\rclass MyQueue { Stack\u0026lt;Integer\u0026gt; stackIn; Stack\u0026lt;Integer\u0026gt; stackOut; /** Initialize your data structure here. */ public MyQueue() { stackIn = new Stack\u0026lt;\u0026gt;(); // 负责进栈 stackOut = new Stack\u0026lt;\u0026gt;(); // 负责出栈 } /** Push element x to the back of queue. */ public void push(int x) { stackIn.push(x); } /** Removes the element from in front of queue and returns that element. */ public int pop() { dumpstackIn(); return stackOut.pop(); } /** Get the front element. */ public int peek() { dumpstackIn(); return stackOut.peek(); } /** Returns whether the queue is empty. */ public boolean empty() { return stackIn.isEmpty() \u0026amp;\u0026amp; stackOut.isEmpty(); } // 如果stackOut为空，那么将stackIn中的元素全部放到stackOut中 private void dumpstackIn(){ if (!stackOut.isEmpty()) return; while (!stackIn.isEmpty()){ stackOut.push(stackIn.pop()); } } } 用队列实现栈 #\r队列是先进先出的规则，把一个队列中的数据导入另一个队列中，数据的顺序并没有变，并没有变成先进后出的顺序。\n所以用栈实现队列， 和用队列实现栈的思路还是不一样的，这取决于这两个数据结构的性质。\n但是依然还是要用两个队列来模拟栈，只不过没有输入和输出的关系，而是另一个队列完全用来备份的！\n如下面动画所示，用两个队列que1和que2实现队列的功能，que2其实完全就是一个备份的作用，把que1最后面的元素以外的元素都备份到que2，然后弹出最后面的元素，再把其他元素从que2导回que1。\n使用两个queue实习栈 #\rclass MyStack { Queue\u0026lt;Integer\u0026gt; queue1; // 和栈中保持一样元素的队列 Queue\u0026lt;Integer\u0026gt; queue2; // 辅助队列 /** Initialize your data structure here. */ public MyStack() { queue1 = new LinkedList\u0026lt;\u0026gt;(); queue2 = new LinkedList\u0026lt;\u0026gt;(); } /** Push element x onto stack. */ public void push(int x) { queue2.offer(x); // 先放在辅助队列中 while (!queue1.isEmpty()){ queue2.offer(queue1.poll()); } Queue\u0026lt;Integer\u0026gt; queueTemp; queueTemp = queue1; queue1 = queue2; queue2 = queueTemp; // 最后交换queue1和queue2，将元素都放到queue1中 } /** Removes the element on top of the stack and returns that element. */ public int pop() { return queue1.poll(); // 因为queue1中的元素和栈中的保持一致，所以这个和下面两个的操作只看queue1即可 } /** Get the top element. */ public int top() { return queue1.peek(); } /** Returns whether the stack is empty. */ public boolean empty() { return queue1.isEmpty(); } } 有效的括号 #\r","date":"2024-08-10","externalUrl":null,"permalink":"/all/algorithm/stack/","section":"Alls","summary":"栈与队列理论基础 # 用栈实现队列 # class MyQueue { Stack\u0026lt;Integer\u0026gt; stackIn; Stack\u0026lt;Integer\u0026gt; stackOut; /** Initialize your data structure here. */","title":"栈","type":"all"},{"content":"\rnginx:使用nginx进行反向代理，前端发起的请求先发给nginx服务器，nginx服务器再向后端服务器发起请求 #\r登录模块：使用md5进行加密，数据库明文改为密文 #\r使用swagger生成接口文档 #\rJWT全称为JSON Web Token，是一种用于身份验证的开放标准。它是一个基于JSON格式的安全令牌，主要用于在网络上传输声明或者用户身份信息。JWT通常被用作API的认证方式，以及跨域身份验证。 #\rJWT令牌由三部分组成，分别是头部（Header）、载荷（Payload）和签名（Signature）。头部包含了令牌使用的加密算法信息，载荷包含了所需传输的用户信息，签名用于保证令牌的完整性和真实性，防止令牌被篡改。 #\rJWT使用流程 用户向服务器发送登录请求，服务器进行身份验证，如果验证成功则返回一个JWT令牌给客户端。\n客户端收到JWT令牌后，将其保存在本地。每次向服务器发送请求时，在请求的头部中携带该令牌，以便服务器对请求进行身份验证。\n服务器收到请求后，从请求头中提取JWT令牌，并进行解析和验证。如果令牌有效，则允许请求继续执行；否则返回错误信息。\nThreadLocal\n业务表公共字段，用切面来处理，为公共字段来赋值 自定义注解 自定义切面类，统一拦截加入注解，通过反射为公共字段赋值 再mapper方法上加入注解\n文件上传：浏览器-后端服务\n","date":"0001-01-01","externalUrl":null,"permalink":"/all/project/foodordersystem/","section":"Alls","summary":"nginx:使用nginx进行反向代理，前端发起的请求先发给","title":"","type":"all"},{"content":"友链\n","date":"0001-01-01","externalUrl":null,"permalink":"/friend/","section":"欢迎来到 JohnnyBlog 的个人博客","summary":"友链","title":"","type":"page"},{"content":"\rnginx:使用nginx进行反向代理，前端发起的请求先发给nginx服务器，nginx服务器再向后端服务器发起请求 #\r登录模块：使用md5进行加密，数据库明文改为密文 #\r使用swagger生成接口文档 #\rJWT全称为JSON Web Token，是一种用于身份验证的开放标准。它是一个基于JSON格式的安全令牌，主要用于在网络上传输声明或者用户身份信息。JWT通常被用作API的认证方式，以及跨域身份验证。 #\rJWT令牌由三部分组成，分别是头部（Header）、载荷（Payload）和签名（Signature）。头部包含了令牌使用的加密算法信息，载荷包含了所需传输的用户信息，签名用于保证令牌的完整性和真实性，防止令牌被篡改。 #\rJWT使用流程 用户向服务器发送登录请求，服务器进行身份验证，如果验证成功则返回一个JWT令牌给客户端。\n客户端收到JWT令牌后，将其保存在本地。每次向服务器发送请求时，在请求的头部中携带该令牌，以便服务器对请求进行身份验证。\n服务器收到请求后，从请求头中提取JWT令牌，并进行解析和验证。如果令牌有效，则允许请求继续执行；否则返回错误信息。\nThreadLocal\n业务表公共字段，用切面来处理，为公共字段来赋值 自定义注解 自定义切面类，统一拦截加入注解，通过反射为公共字段赋值 再mapper方法上加入注解\n文件上传：浏览器-后端服务\n","date":"0001-01-01","externalUrl":null,"permalink":"/project/foodordersystem/","section":"Projects","summary":"nginx:使用nginx进行反向代理，前端发起的请求先发给","title":"","type":"project"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/tags/interview/","section":"Tags","summary":"","title":"Interview","type":"tags"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/interview/","section":"Interviews","summary":"","title":"Interviews","type":"interview"},{"content":"\rJVM #\r1.概念： #\rJVM是可运行Java代码的假想计算机，包括一套字节码指令集、一组寄存器、一个栈、 一个垃圾回收，堆和一个存储方法域。JVM是运行在操作系统之上的，它与硬件没有直接 的交互\n① Java源文件—-\u0026gt;编译器—-\u0026gt;字节码文件\n② 字节码文件—-\u0026gt;JVM—-\u0026gt;机器码\n2.线程 #\r2.1当线程本地存储、缓冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程。 #\rJava 线程结束，原生线程随之被回收。操作系统负责调度所有线程，并把它们分配到任何可用的 CPU 上。当原生线程初始化完毕，就会调用 Java 线程的 run() 方法。当线程结束时，会释放原生线程和 Java 线程的所有资源。\nHotspot JVM 后台运行的系统线程主要有下面几个： 2.2. JVM 内存区域 #\r线程私有数据区域(ThreadLocal)生命周期与线程相同, 依赖用户线程的启动/结束 而 创建/销毁(在Hotspot VM 内, 每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的存/否跟随本地线程的 生/死对应)。 线程共享区域(ThreadShared)随虚拟机的启动/关闭而创建/销毁。 直接内存并不是JVM运行时数据区的一部分, 但也会被频繁的使用: 在JDK 1.4引入的NIO提 供了基于Channel 与 Buffer 的 IO 方式, 它可以使用 Native 函数库直接分配堆外内存, 然后使用 DirectByteBuffer 对象作为这块内存的引用进行操作(详见: Java I/O 扩展), 这样就避免了在 Java 堆和Native堆中来回复制数据, 因此在一些场景中可以显著提高性能。\n2.2.1. 程序计数器PC(线程私有) #\r一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的 程序计数器，这类内存也称为“线程私有”的内存。\n2.2.2. 虚拟机栈(线程私有) #\r是描述java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame） 用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成 的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。\n2.2.3. 本地方法区(线程私有) #\r本地方法区和Java Stack作用类似, 区别是虚拟机栈为执行Java方法服务, 而本地方法栈则为 Native 方法服务\n2.2.4. 堆（Heap-线程共享）-运行时数据区 #\r是被线程共享的一块内存区域，创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行 垃圾收集的最重要的内存区域。\n2.2.5. 方法区/永久代（线程共享） #\r用于存储被 JVM 加载的类信息、常量、静 态变量、即时编译器编译后的代码等数据. HotSpot VM把GC分代收集扩展至方法区, 即使用Java 堆的永久代来实现方法区.\n运行时常量池（Runtime Constant Pool）是方法区的一部分。用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加 载后存放到方法区的运行时常量池中。\n2.3. JVM 运行时内存 #\rJava 堆从GC的角度还可以细分为: 新生代(Eden区、From Survivor区和To Survivor区)和老年 代。\n2.3.1. 新生代 #\r是用来存放新生的对象。一般占据堆的1/3空间。由于频繁创建对象，所以新生代会频繁触发 MinorGC 进行垃圾回收。新生代又分为 Eden区、ServivorFrom、ServivorTo三个区。\n2.3.1.1.Eden区 #\rJava新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老 年代）。当Eden区内存不够的时候就会触发MinorGC，对新生代区进行 一次垃圾回收。\n2.3.1.2.ServivorFrom #\r上一次GC的幸存者，作为这一次GC的被扫描者。\n2.3.1.3.ServivorTo #\r保留了一次MinorGC过程中的幸存者。\n2.3.1.4.MinorGC的过程（复制-\u0026gt;清空-\u0026gt;互换） #\rMinorGC采用复制算法。 1：eden、servicorFrom 复制到 ServicorTo，年龄+1 首先，把Eden和ServivorFrom区域中存活的对象复制到ServicorTo区域（如果有对象的年 龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果ServicorTo不 够位置了就放到老年区）； 2：清空eden、servicorFrom 然后，清空Eden和ServicorFrom中的对象； 3：ServicorTo 和 ServicorFrom 互换 最后，ServicorTo和ServicorFrom互换，原ServicorTo成为下一次GC时的ServicorFrom 区。\n2.3.2. 老年代 #\r主要存放应用程序中生命周期长的内存对象。 老年代的对象比较稳定，所以MajorGC不会频繁执行。在进行MajorGC前一般都先进行 了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足 够大的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC进行垃圾回收腾出空间。 MajorGC 采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没 有标记的对象。MajorGC的耗时比较长，因为要扫描再回收。MajorGC会产生内存碎片，为了减 少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的 时候，就会抛出OOM（Out of Memory）异常。\n2.3.3. 永久代 #\r指内存的永久保存区域，主要存放Class 和 Meta（元数据）的信息,Class 在被加载的时候被 放入永久区域，它和和存放实例的区域不同,GC不会在主程序运行期对永久区域进行清理。所以这 也导致了永久代的区域会随着加载的Class的增多而胀满，最终抛出OOM异常。\n2.4. 垃圾回收与算法 #\r2.4.1. 如何确定垃圾 #\r2.4.1.1.引用计数法 #\r在 Java 中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单 的办法是通过引用计数来判断一个对象是否可以回收。简单说，即一个对象如果没有任何与之关 联的引用，即他们的引用计数都不为0，则说明对象不太可能再被用到，那么这个对象就是可回收 对象。\n2.4.1.2.可达性分析 #\r为了解决引用计数法的循环引用问题，Java 使用了可达性分析的方法。通过一系列的“GC roots” 对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。\n2.4.2. 标记清除算法（Mark-Sweep） #\r最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清 除阶段回收被标记的对象所占用的空间。\n2.4.3. 复制算法（copying） #\r为了解决Mark-Sweep算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小 的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用 的内存清掉，\n标记整理算法(Mark-Compact) #\r结合了以上两个算法，为了避免缺陷而提出。标记阶段和Mark-Sweep算法相同，标记后不是清 理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。\n2.4.5. 分代收集算法 #\r分代收集法是目前大部分JVM所采用的方法，其核心思想是根据对象存活的不同生命周期将内存 划分为不同的域，一般情况下将GC堆划分为老生代(Tenured/Old Generation)和新生代(Young Generation)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃 圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。\n2.4.5.1. #\r新生代与复制算法\n目前大部分JVM的GC对于新生代都采取Copying算法，因为新生代中每次垃圾回收都要 回收大部分对象，即要复制的操作比较少，但通常并不是按照1：1来划分新生代。一般将新生代 划分为一块较大的Eden空间和两个较小的Survivor空间(From Space, To Space)，每次使用 Eden 空间和其中的一块Survivor空间，当进行回收时，将该两块空间中还存活的对象复制到另 一块Survivor空间中。\n2.4.5.2. #\r老年代与标记复制算法 而老年代因为每次只回收少量对象，因而采用Mark-Compact算法。\nJAVA虚拟机提到过的处于方法区的永生代(Permanet Generation)，它用来存储class类， 常量，方法描述等。对永生代的回收主要包括废弃常量和无用的类。 对象的内存分配主要在新生代的Eden Space和Survivor Space的From Space(Survivor目 前存放对象的那一块)，少数情况会直接分配到老生代。 当新生代的Eden Space和From Space空间不足时就会发生一次GC，进行GC后，Eden Space 和From Space区的存活对象会被挪到To Space，然后将Eden Space和From Space 进行清理。 如果To Space无法足够存储某个对象，则将这个对象存储到老生代。 在进行GC后，使用的便是Eden Space和To Space了，如此反复循环。 当对象在Survivor区躲过一次GC后，其年龄就会+1。默认情况下年龄到达15的对象会被 移到老生代中。 2.5. JAVA 四中引用类型 #\r2.5.1. 强引用 #\r在 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引 用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即 使该对象以后永远都不会被用到JVM也不会回收。因此强引用是造成Java内存泄漏的主要原因之 一。\n2.5.2. 软引用 #\r软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它 不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。\n2.5.3. 弱引用 #\r弱引用需要用WeakReference类来实现，它比软引用的生存期更短，对于只有弱引用的对象 来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，总会回收该对象占用的内存。\n2.5.3. 弱引用 #\r弱引用需要用WeakReference类来实现，它比软引用的生存期更短，对于只有弱引用的对象 来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，总会回收该对象占用的内存。\n2.5.3. 弱引用 #\r弱引用需要用WeakReference类来实现，它比软引用的生存期更短，对于只有弱引用的对象 来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，总会回收该对象占用的内存。\n2.6. GC 分代收集算法 VS 分区收集算法 #\r2.6.1. 分代收集算法 #\r当前主流VM垃圾收集都采用”分代收集”(Generational Collection)算法, 这种算法会根据 对象存活周期的不同将内存划分为几块, 如JVM中的 新生代、老年代、永久代，这样就可以根据 各年代特点分别采用最适当的GC算法\n2.6.1.2. #\r在老年代-标记整理算法 因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清理”或“标 记—整理”算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存.\n2.6.2. 分区收集算法 #\r分区算法则将整个堆空间划分为连续的不同小区间, 每个小区间独立使用, 独立回收. 这样做的 好处是可以控制一次回收多少个小区间 , 根据目标停顿时间, 每次合理地回收若干个小区间(而不是 整个堆), 从而减少一次GC所产生的停顿。\n","date":"0001-01-01","externalUrl":null,"permalink":"/all/interview/jvm/","section":"Alls","summary":"JVM # 1.概念： # JVM是可运行Java代码的假想计算机，包括","title":"JVM知识点","type":"all"},{"content":"\rJVM #\r1.概念： #\rJVM是可运行Java代码的假想计算机，包括一套字节码指令集、一组寄存器、一个栈、 一个垃圾回收，堆和一个存储方法域。JVM是运行在操作系统之上的，它与硬件没有直接 的交互\n① Java源文件—-\u0026gt;编译器—-\u0026gt;字节码文件\n② 字节码文件—-\u0026gt;JVM—-\u0026gt;机器码\n2.线程 #\r2.1当线程本地存储、缓冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程。 #\rJava 线程结束，原生线程随之被回收。操作系统负责调度所有线程，并把它们分配到任何可用的 CPU 上。当原生线程初始化完毕，就会调用 Java 线程的 run() 方法。当线程结束时，会释放原生线程和 Java 线程的所有资源。\nHotspot JVM 后台运行的系统线程主要有下面几个： 2.2. JVM 内存区域 #\r线程私有数据区域(ThreadLocal)生命周期与线程相同, 依赖用户线程的启动/结束 而 创建/销毁(在Hotspot VM 内, 每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的存/否跟随本地线程的 生/死对应)。 线程共享区域(ThreadShared)随虚拟机的启动/关闭而创建/销毁。 直接内存并不是JVM运行时数据区的一部分, 但也会被频繁的使用: 在JDK 1.4引入的NIO提 供了基于Channel 与 Buffer 的 IO 方式, 它可以使用 Native 函数库直接分配堆外内存, 然后使用 DirectByteBuffer 对象作为这块内存的引用进行操作(详见: Java I/O 扩展), 这样就避免了在 Java 堆和Native堆中来回复制数据, 因此在一些场景中可以显著提高性能。\n2.2.1. 程序计数器PC(线程私有) #\r一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的 程序计数器，这类内存也称为“线程私有”的内存。\n2.2.2. 虚拟机栈(线程私有) #\r是描述java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame） 用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成 的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。\n2.2.3. 本地方法区(线程私有) #\r本地方法区和Java Stack作用类似, 区别是虚拟机栈为执行Java方法服务, 而本地方法栈则为 Native 方法服务\n2.2.4. 堆（Heap-线程共享）-运行时数据区 #\r是被线程共享的一块内存区域，创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行 垃圾收集的最重要的内存区域。\n2.2.5. 方法区/永久代（线程共享） #\r用于存储被 JVM 加载的类信息、常量、静 态变量、即时编译器编译后的代码等数据. HotSpot VM把GC分代收集扩展至方法区, 即使用Java 堆的永久代来实现方法区.\n运行时常量池（Runtime Constant Pool）是方法区的一部分。用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加 载后存放到方法区的运行时常量池中。\n2.3. JVM 运行时内存 #\rJava 堆从GC的角度还可以细分为: 新生代(Eden区、From Survivor区和To Survivor区)和老年 代。\n2.3.1. 新生代 #\r是用来存放新生的对象。一般占据堆的1/3空间。由于频繁创建对象，所以新生代会频繁触发 MinorGC 进行垃圾回收。新生代又分为 Eden区、ServivorFrom、ServivorTo三个区。\n2.3.1.1.Eden区 #\rJava新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老 年代）。当Eden区内存不够的时候就会触发MinorGC，对新生代区进行 一次垃圾回收。\n2.3.1.2.ServivorFrom #\r上一次GC的幸存者，作为这一次GC的被扫描者。\n2.3.1.3.ServivorTo #\r保留了一次MinorGC过程中的幸存者。\n2.3.1.4.MinorGC的过程（复制-\u0026gt;清空-\u0026gt;互换） #\rMinorGC采用复制算法。 1：eden、servicorFrom 复制到 ServicorTo，年龄+1 首先，把Eden和ServivorFrom区域中存活的对象复制到ServicorTo区域（如果有对象的年 龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果ServicorTo不 够位置了就放到老年区）； 2：清空eden、servicorFrom 然后，清空Eden和ServicorFrom中的对象； 3：ServicorTo 和 ServicorFrom 互换 最后，ServicorTo和ServicorFrom互换，原ServicorTo成为下一次GC时的ServicorFrom 区。\n2.3.2. 老年代 #\r主要存放应用程序中生命周期长的内存对象。 老年代的对象比较稳定，所以MajorGC不会频繁执行。在进行MajorGC前一般都先进行 了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足 够大的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC进行垃圾回收腾出空间。 MajorGC 采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没 有标记的对象。MajorGC的耗时比较长，因为要扫描再回收。MajorGC会产生内存碎片，为了减 少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的 时候，就会抛出OOM（Out of Memory）异常。\n2.3.3. 永久代 #\r指内存的永久保存区域，主要存放Class 和 Meta（元数据）的信息,Class 在被加载的时候被 放入永久区域，它和和存放实例的区域不同,GC不会在主程序运行期对永久区域进行清理。所以这 也导致了永久代的区域会随着加载的Class的增多而胀满，最终抛出OOM异常。\n2.4. 垃圾回收与算法 #\r2.4.1. 如何确定垃圾 #\r2.4.1.1.引用计数法 #\r在 Java 中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单 的办法是通过引用计数来判断一个对象是否可以回收。简单说，即一个对象如果没有任何与之关 联的引用，即他们的引用计数都不为0，则说明对象不太可能再被用到，那么这个对象就是可回收 对象。\n2.4.1.2.可达性分析 #\r为了解决引用计数法的循环引用问题，Java 使用了可达性分析的方法。通过一系列的“GC roots” 对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。\n2.4.2. 标记清除算法（Mark-Sweep） #\r最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清 除阶段回收被标记的对象所占用的空间。\n2.4.3. 复制算法（copying） #\r为了解决Mark-Sweep算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小 的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用 的内存清掉，\n标记整理算法(Mark-Compact) #\r结合了以上两个算法，为了避免缺陷而提出。标记阶段和Mark-Sweep算法相同，标记后不是清 理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。\n2.4.5. 分代收集算法 #\r分代收集法是目前大部分JVM所采用的方法，其核心思想是根据对象存活的不同生命周期将内存 划分为不同的域，一般情况下将GC堆划分为老生代(Tenured/Old Generation)和新生代(Young Generation)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃 圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。\n2.4.5.1. #\r新生代与复制算法\n目前大部分JVM的GC对于新生代都采取Copying算法，因为新生代中每次垃圾回收都要 回收大部分对象，即要复制的操作比较少，但通常并不是按照1：1来划分新生代。一般将新生代 划分为一块较大的Eden空间和两个较小的Survivor空间(From Space, To Space)，每次使用 Eden 空间和其中的一块Survivor空间，当进行回收时，将该两块空间中还存活的对象复制到另 一块Survivor空间中。\n2.4.5.2. #\r老年代与标记复制算法 而老年代因为每次只回收少量对象，因而采用Mark-Compact算法。\nJAVA虚拟机提到过的处于方法区的永生代(Permanet Generation)，它用来存储class类， 常量，方法描述等。对永生代的回收主要包括废弃常量和无用的类。 对象的内存分配主要在新生代的Eden Space和Survivor Space的From Space(Survivor目 前存放对象的那一块)，少数情况会直接分配到老生代。 当新生代的Eden Space和From Space空间不足时就会发生一次GC，进行GC后，Eden Space 和From Space区的存活对象会被挪到To Space，然后将Eden Space和From Space 进行清理。 如果To Space无法足够存储某个对象，则将这个对象存储到老生代。 在进行GC后，使用的便是Eden Space和To Space了，如此反复循环。 当对象在Survivor区躲过一次GC后，其年龄就会+1。默认情况下年龄到达15的对象会被 移到老生代中。 2.5. JAVA 四中引用类型 #\r2.5.1. 强引用 #\r在 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引 用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即 使该对象以后永远都不会被用到JVM也不会回收。因此强引用是造成Java内存泄漏的主要原因之 一。\n2.5.2. 软引用 #\r软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它 不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。\n2.5.3. 弱引用 #\r弱引用需要用WeakReference类来实现，它比软引用的生存期更短，对于只有弱引用的对象 来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，总会回收该对象占用的内存。\n2.5.3. 弱引用 #\r弱引用需要用WeakReference类来实现，它比软引用的生存期更短，对于只有弱引用的对象 来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，总会回收该对象占用的内存。\n2.5.3. 弱引用 #\r弱引用需要用WeakReference类来实现，它比软引用的生存期更短，对于只有弱引用的对象 来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，总会回收该对象占用的内存。\n2.6. GC 分代收集算法 VS 分区收集算法 #\r2.6.1. 分代收集算法 #\r当前主流VM垃圾收集都采用”分代收集”(Generational Collection)算法, 这种算法会根据 对象存活周期的不同将内存划分为几块, 如JVM中的 新生代、老年代、永久代，这样就可以根据 各年代特点分别采用最适当的GC算法\n2.6.1.2. #\r在老年代-标记整理算法 因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清理”或“标 记—整理”算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存.\n2.6.2. 分区收集算法 #\r分区算法则将整个堆空间划分为连续的不同小区间, 每个小区间独立使用, 独立回收. 这样做的 好处是可以控制一次回收多少个小区间 , 根据目标停顿时间, 每次合理地回收若干个小区间(而不是 整个堆), 从而减少一次GC所产生的停顿。\n","date":"0001-01-01","externalUrl":null,"permalink":"/interview/jvm/","section":"Interviews","summary":"JVM # 1.概念： # JVM是可运行Java代码的假想计算机，包括","title":"JVM知识点","type":"interview"},{"content":"\rmysql #\r慢查询 #\r聚合查询 多表查询 表数据量过大查询 深度分页查询 表象：页面加载过慢、接口压测响应时间过长（超过1s）\n如何定位慢查询? 方案二：MySQL自带慢日志 慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志 如果要开启慢查询日志，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息\n如何分析一个SQL语句执行很慢 可以采用EXPLAIN 或者DESC命令获取MySQL 如何执行SELECT 语句的信息 MYSQL支持的存储引擎 #\r存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的 ，所以存储引擎也可被称为表类型。 索引 #\r索引（index）是帮助MySQL高效获取数据的数据结构(有序)；提高数据检索的效率，降低数据库的IO成本（不需要全表扫描） ； 通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗\nB树： B+树： B树与B+树对比: ①：磁盘读写代价B+树更低；\n②：查询效率B+树更加稳定；\n③：B+树便于扫库和区间查询\n1.1聚集索引vs聚簇索引 #\r1.聚簇索引（聚集索引）：数据与索引放到一块，B+树的叶子节点保存了整行数据，有且只有一个\n2.非聚簇索引（二级索引）：数据与索引分开存储，B+树的叶子节点保存对应的主键，可以有多个\n1.2回表查询 #\r通过二级索引找到对应的主键值，到聚集索引中查找整行数据，这个过程就是回表查询\n1.3覆盖索引 #\r覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到\n如何对MYSQL超大分页处理？ #\r通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化\n","date":"0001-01-01","externalUrl":null,"permalink":"/all/interview/mysql/","section":"Alls","summary":"mysql # 慢查询 # 聚合查询 多表查询 表数据量过大查询 深度分页查询 表象","title":"mysql面试知识点","type":"all"},{"content":"\rmysql #\r慢查询 #\r聚合查询 多表查询 表数据量过大查询 深度分页查询 表象：页面加载过慢、接口压测响应时间过长（超过1s）\n如何定位慢查询? 方案二：MySQL自带慢日志 慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志 如果要开启慢查询日志，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息\n如何分析一个SQL语句执行很慢 可以采用EXPLAIN 或者DESC命令获取MySQL 如何执行SELECT 语句的信息 MYSQL支持的存储引擎 #\r存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的 ，所以存储引擎也可被称为表类型。 索引 #\r索引（index）是帮助MySQL高效获取数据的数据结构(有序)；提高数据检索的效率，降低数据库的IO成本（不需要全表扫描） ； 通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗\nB树： B+树： B树与B+树对比: ①：磁盘读写代价B+树更低；\n②：查询效率B+树更加稳定；\n③：B+树便于扫库和区间查询\n1.1聚集索引vs聚簇索引 #\r1.聚簇索引（聚集索引）：数据与索引放到一块，B+树的叶子节点保存了整行数据，有且只有一个\n2.非聚簇索引（二级索引）：数据与索引分开存储，B+树的叶子节点保存对应的主键，可以有多个\n1.2回表查询 #\r通过二级索引找到对应的主键值，到聚集索引中查找整行数据，这个过程就是回表查询\n1.3覆盖索引 #\r覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到\n如何对MYSQL超大分页处理？ #\r通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化\n","date":"0001-01-01","externalUrl":null,"permalink":"/interview/mysql/","section":"Interviews","summary":"mysql # 慢查询 # 聚合查询 多表查询 表数据量过大查询 深度分页查询 表象","title":"mysql面试知识点","type":"interview"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/project/","section":"Projects","summary":"","title":"Projects","type":"project"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]