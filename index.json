


[{"content":"友链\n","date":"0001-01-01","externalUrl":null,"permalink":"/friend/","section":"欢迎来到 JohnnyBlog 的个人博客","summary":"友链","title":"","type":"page"},{"content":"\rnginx:使用nginx进行反向代理，前端发起的请求先发给nginx服务器，nginx服务器再向后端服务器发起请求 #\r登录模块：使用md5进行加密，数据库明文改为密文 #\r使用swagger生成接口文档 #\rJWT全称为JSON Web Token，是一种用于身份验证的开放标准。它是一个基于JSON格式的安全令牌，主要用于在网络上传输声明或者用户身份信息。JWT通常被用作API的认证方式，以及跨域身份验证。 #\rJWT令牌由三部分组成，分别是头部（Header）、载荷（Payload）和签名（Signature）。头部包含了令牌使用的加密算法信息，载荷包含了所需传输的用户信息，签名用于保证令牌的完整性和真实性，防止令牌被篡改。 #\rJWT使用流程 用户向服务器发送登录请求，服务器进行身份验证，如果验证成功则返回一个JWT令牌给客户端。\n客户端收到JWT令牌后，将其保存在本地。每次向服务器发送请求时，在请求的头部中携带该令牌，以便服务器对请求进行身份验证。\n服务器收到请求后，从请求头中提取JWT令牌，并进行解析和验证。如果令牌有效，则允许请求继续执行；否则返回错误信息。\nThreadLocal\n业务表公共字段，用切面来处理，为公共字段来赋值 自定义注解 自定义切面类，统一拦截加入注解，通过反射为公共字段赋值 再mapper方法上加入注解\n文件上传：浏览器-后端服务\n","date":"0001-01-01","externalUrl":null,"permalink":"/project/foodordersystem/","section":"Projects","summary":"nginx:使用nginx进行反向代理，前端发起的请求先发给","title":"","type":"project"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/algorithm/","section":"Algorithms","summary":"","title":"Algorithms","type":"algorithm"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"\rDVWA暴力破解攻略 #\r一、\t靶场考核点 #\r弱口令(weak password) 没有严格和准确的定义，通常认为容易被别人（他们有可能对你很了解）猜测到或被破解工具破解的口令均为弱口令。 弱口令指的是仅包含简单数字和字母的口令，例如“123”、“abc”等，因为这样的口令很容易被别人破解，从而使用户的互联网账号受到他人控制，因此不推荐用户使用。\n二、\t靶场复现 #\r等级：LOW #\r1、开启代理，输入账号密码 2、打开抓包工具抓包 3、点击Acktion,点击send to Intruder,进入Intruder模块 4、快速设置，开启攻击，得到长度不同的情况极大可能是账号密码 暴力破解medium步骤跟low一样 #\r等级： high #\r1、 开启抓包，发现多了个token，发送至intruder模块positions设置为pitchfork 2、Option线程设置为1，grep-extract打勾，点击add 3、进行如下设置，复制好value的值，点击Ok,然后找到redirections设置为Always 4、最后进行payloads设置，第二个设置为recursive grep模式 5、最后进行攻击，破解成功 三、\t漏洞分析 #\r1、未设计安全的验证码； 2、未对认证错误的提交进行计数并给出限制； 3、未使用双因素认证；\nbasic knowledage and tools to get debugs #\r⽬录遍历漏洞 #\r⽬录扫描 #\r什么是⽬录？ url的组成： https://blog.mo60.cn/index.php/archiv1s/2024-HeiDun.html -\u0026gt; http服务 提供⽹⻚服务的 https://blog.mo60.cn:443/index.php/archiv1s/2024-HeiDun.html :80 :443 端⼝与服务有对应关系\nhttp服务 -\u0026gt; 80\nhttp -\u0026gt; tcp/80\nhttps -\u0026gt; tcp/443\nhttp:// / https:// protocol://(sub)domain:port/path1/path2/path3\nport -\u0026gt; 端⼝65535端⼝ tcp/ip协议\n端⼝：提供服务的\nhttp：明⽂传输\nhttps：加密传输\nftp：⽂件传输协议 file tralation protocol 明⽂ -\u0026gt; 传输流量是明⽂ 是可读的 可能会泄露敏感 信息\nsftp: 加密版本的ftp s -\u0026gt; ssl tls 加密协议\ndirsearch #\rpython3 -m pip install -r requirements.txt\nxxxx package exsting 版本⾼于requirement中要求的版本\npip uninstall -\u0026gt; pip卸载⾼版本的y -\u0026gt; cannot uninstall the package the package has\ninstalled by debian\napt\napt-get\napt list|grep termcolora\npython3-temcolora\napt remove python3-termcolora -\u0026gt;\n什么是debian？\nlinux最早 林纳斯·xxx ,linux：开源 源代码开放 ,允许任何个⼈或组织基于linux进⾏⼆次开发 ,开源协议要求使⽤这个程序⼆次开发的应⽤ 也需要开源 ubuntu centos readhat debian 就都是linux的发⾏版\nunix -\u0026gt; 闭源 -\u0026gt; macos 基于unix进⾏⼆次开发 -\u0026gt; macos就也闭源 linux命名 linux is not unix\n原理 #\rhttp协议基础\ntcp/ip协议 有状态性\n应⽤层 http协议\n表示层\n会话层\n传输层\n⽹络层\n数据链路层 arp协议\n物理层 ⽹线 光纤\nhttp协议 -\u0026gt; tcp/ip ⽆状态性\n服务端在默认情况下并不知道哪个请求来源于哪个客户端\n在http协议中 有7种请求⽅式 最常⻅的就是get / post\nget使⽤url传值:\nhttp://112.124.71.224:18080/vulnerabilities/brute/?username=admin\u0026amp;pa\nssword=admin\u0026amp;Login=Login#\n浏览器对于url的⻓度有限制\n?name1=value1\u0026amp;name2=value2 安全性⽐较低\n请求包： #\rGET /login?username=admin\u0026amp;password=admin HTTP/1.1 Host: mbinvest.tebon.com.cn Connection: close Content-Length: 358 Pragma: no-cache Cache-Control: no-cache tztWebdataEncrypt: 1 X-Requested-With: XMLHttpRequest User-Agent: Mozilla/5.0 (Linux; Android 6.0.1; MuMu Build/V417IR; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/91.0.4472.114 Mobile Safari/537.36;/dbzq Content-Type: application/x-www-form-urlencoded; Accept: */* Origin: https://mbinvest.tebon.com.cn Sec-Fetch-Site: same-origin Sec-Fetch-Mode: cors Sec-Fetch-Dest: empty Referer: https://mbinvest.tebon.com.cn/h5_vue/news/wealth-app/index.html Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 Cookie: sajssdk_2015_cross_new_user=1; sensorsdata2015jssdkcross=%7B%22distinct_id%22%3A%221919cdf8e18175 0bdab4c7be43008-20331d51-557200 1919cdf8e19227%22%2C%22first_id%22%3A%22%22%2C%22props%22%3A%7B%22%24late st_traffic_source_type%22%3A%22%E7%9B%B4%E6%8E%A5%E6%B5%81%E9%87%8F%22%2C %22%24latest_search_keyword%22%3A%22%E6%9C%AA%E5%8F%96%E5%88%B0%E5%80%BC_ %E7%9B%B4%E6%8E%A5%E6%89%93%E5%BC%80%22%2C%22%24latest_referrer%22%3A%22% 22%7D%2C%22identities%22%3A%22eyIkaWRlbnRpdHlfY29va2llX2lkIjoiMTkxOWNkZjh lMTgxNzUtMGJkYWI0YzdiZTQzMDA4LTIwMzMxZDUxLTU1NzIwMC0xOTE5Y2RmOGUxOTIyNyJ9 %22%2C%22history_login_id%22%3A%7B%22name%22%3A%22%22%2C%22value%22%3A%22 %22%7D%2C%22%24device_id%22%3A%221919cdf8e18175-0bdab4c7be43008-20331d51 557200-1919cdf8e19227%22%7D; t1=DEB48BC37658EAC11885AA1DFE8F8632CA2B49294C51C1BACC post传值 在body中传值 #\rPOST /login HTTP/1.1 Host: mbinvest.tebon.com.cn Connection: close Content-Length: 358 Pragma: no-cache Cache-Control: no-cache tztWebdataEncrypt: 1 X-Requested-With: XMLHttpRequest User-Agent: Mozilla/5.0 (Linux; Android 6.0.1; MuMu Build/V417IR; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/91.0.4472.114 Mobile Safari/537.36;/dbzq Content-Type: application/x-www-form-urlencoded; Accept: */* Origin: https://mbinvest.tebon.com.cn Sec-Fetch-Site: same-origin Sec-Fetch-Mode: cors Sec-Fetch-Dest: empty Referer: https://mbinvest.tebon.com.cn/h5_vue/news/wealth-app/index.html Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 Cookie: sajssdk_2015_cross_new_user=1; sensorsdata2015jssdkcross=%7B%22distinct_id%22%3A%221919cdf8e18175 0bdab4c7be43008-20331d51-557200 1919cdf8e19227%22%2C%22first_id%22%3A%22%22%2C%22props%22%3A%7B%22%24late st_traffic_source_type%22%3A%22%E7%9B%B4%E6%8E%A5%E6%B5%81%E9%87%8F%22%2C %22%24latest_search_keyword%22%3A%22%E6%9C%AA%E5%8F%96%E5%88%B0%E5%80%BC_ %E7%9B%B4%E6%8E%A5%E6%89%93%E5%BC%80%22%2C%22%24latest_referrer%22%3A%22% 22%7D%2C%22identities%22%3A%22eyIkaWRlbnRpdHlfY29va2llX2lkIjoiMTkxOWNkZjh lMTgxNzUtMGJkYWI0YzdiZTQzMDA4LTIwMzMxZDUxLTU1NzIwMC0xOTE5Y2RmOGUxOTIyNyJ9 %22%2C%22history_login_id%22%3A%7B%22name%22%3A%22%22%2C%22value%22%3A%22 %22%7D%2C%22%24device_id%22%3A%221919cdf8e18175-0bdab4c7be43008-20331d51 557200-1919cdf8e19227%22%7D; t1=DEB48BC37658EAC11885AA1DFE8F8632CA2B49294C51C1BACC username=admin\u0026amp;password=admin request header请求头： #\rHost: mbinvest.tebon.com.cn Connection: close Content-Length: 358 Pragma: no-cache Cache-Control: no-cache tztWebdataEncrypt: 1 X-Requested-With: XMLHttpRequest User-Agent: Mozilla/5.0 (Linux; Android 6.0.1; MuMu Build/V417IR; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/91.0.4472.114 Mobile Safari/537.36;/dbzq Content-Type: application/x-www-form-urlencoded; Accept: */* Origin: https://mbinvest.tebon.com.cn Sec-Fetch-Site: same-origin Sec-Fetch-Mode: cors Sec-Fetch-Dest: empty Referer: https://mbinvest.tebon.com.cn/h5_vue/news/wealth-app/index.html Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 Cookie: username=guest; sensorsdata2015jssdkcross=%7B%22distinct_id%22%3A%221919cdf8e18175 0bdab4c7be43008-20331d51-557200 1919cdf8e19227%22%2C%22first_id%22%3A%22%22%2C%22props%22%3A%7B%22%24late st_traffic_source_type%22%3A%22%E7%9B%B4%E6%8E%A5%E6%B5%81%E9%87%8F%22%2C %22%24latest_search_keyword%22%3A%22%E6%9C%AA%E5%8F%96%E5%88%B0%E5%80%BC_ %E7%9B%B4%E6%8E%A5%E6%89%93%E5%BC%80%22%2C%22%24latest_referrer%22%3A%22% 22%7D%2C%22identities%22%3A%22eyIkaWRlbnRpdHlfY29va2llX2lkIjoiMTkxOWNkZjh lMTgxNzUtMGJkYWI0YzdiZTQzMDA4LTIwMzMxZDUxLTU1NzIwMC0xOTE5Y2RmOGUxOTIyNyJ9 %22%2C%22history_login_id%22%3A%7B%22name%22%3A%22%22%2C%22value%22%3A%22 %22%7D%2C%22%24device_id%22%3A%221919cdf8e18175-0bdab4c7be43008-20331d51 557200-1919cdf8e19227%22%7D; t1=DEB48BC37658EAC11885AA1DFE8F8632CA2B49294C51C1BACC ","date":"0001-01-01","externalUrl":null,"permalink":"/networkengineering/","section":"欢迎来到 JohnnyBlog 的个人博客","summary":"DVWA暴力破解攻略 # 一、 靶场考核点 # 弱口令(weak password) 没有","title":"DVWA暴力破解攻略","type":"page"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/interview/","section":"Interviews","summary":"","title":"Interviews","type":"interview"},{"content":"\rJVM #\r1.概念： #\rJVM是可运行Java代码的假想计算机，包括一套字节码指令集、一组寄存器、一个栈、 一个垃圾回收，堆和一个存储方法域。JVM是运行在操作系统之上的，它与硬件没有直接 的交互\n① Java源文件—-\u0026gt;编译器—-\u0026gt;字节码文件\n② 字节码文件—-\u0026gt;JVM—-\u0026gt;机器码\n2.线程 #\r2.1当线程本地存储、缓冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程。 #\rJava 线程结束，原生线程随之被回收。操作系统负责调度所有线程，并把它们分配到任何可用的 CPU 上。当原生线程初始化完毕，就会调用 Java 线程的 run() 方法。当线程结束时，会释放原生线程和 Java 线程的所有资源。\nHotspot JVM 后台运行的系统线程主要有下面几个： 2.2. JVM 内存区域 #\r线程私有数据区域(ThreadLocal)生命周期与线程相同, 依赖用户线程的启动/结束 而 创建/销毁(在Hotspot VM 内, 每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的存/否跟随本地线程的 生/死对应)。 线程共享区域(ThreadShared)随虚拟机的启动/关闭而创建/销毁。 直接内存并不是JVM运行时数据区的一部分, 但也会被频繁的使用: 在JDK 1.4引入的NIO提 供了基于Channel 与 Buffer 的 IO 方式, 它可以使用 Native 函数库直接分配堆外内存, 然后使用 DirectByteBuffer 对象作为这块内存的引用进行操作(详见: Java I/O 扩展), 这样就避免了在 Java 堆和Native堆中来回复制数据, 因此在一些场景中可以显著提高性能。\n2.2.1. 程序计数器PC(线程私有) #\r一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的 程序计数器，这类内存也称为“线程私有”的内存。\n2.2.2. 虚拟机栈(线程私有) #\r是描述java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame） 用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成 的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。\n2.2.3. 本地方法区(线程私有) #\r本地方法区和Java Stack作用类似, 区别是虚拟机栈为执行Java方法服务, 而本地方法栈则为 Native 方法服务\n2.2.4. 堆（Heap-线程共享）-运行时数据区 #\r是被线程共享的一块内存区域，创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行 垃圾收集的最重要的内存区域。\n2.2.5. 方法区/永久代（线程共享） #\r用于存储被 JVM 加载的类信息、常量、静 态变量、即时编译器编译后的代码等数据. HotSpot VM把GC分代收集扩展至方法区, 即使用Java 堆的永久代来实现方法区.\n运行时常量池（Runtime Constant Pool）是方法区的一部分。用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加 载后存放到方法区的运行时常量池中。\n2.3. JVM 运行时内存 #\rJava 堆从GC的角度还可以细分为: 新生代(Eden区、From Survivor区和To Survivor区)和老年 代。\n2.3.1. 新生代 #\r是用来存放新生的对象。一般占据堆的1/3空间。由于频繁创建对象，所以新生代会频繁触发 MinorGC 进行垃圾回收。新生代又分为 Eden区、ServivorFrom、ServivorTo三个区。\n2.3.1.1.Eden区 #\rJava新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老 年代）。当Eden区内存不够的时候就会触发MinorGC，对新生代区进行 一次垃圾回收。\n2.3.1.2.ServivorFrom #\r上一次GC的幸存者，作为这一次GC的被扫描者。\n2.3.1.3.ServivorTo #\r保留了一次MinorGC过程中的幸存者。\n2.3.1.4.MinorGC的过程（复制-\u0026gt;清空-\u0026gt;互换） #\rMinorGC采用复制算法。 1：eden、servicorFrom 复制到 ServicorTo，年龄+1 首先，把Eden和ServivorFrom区域中存活的对象复制到ServicorTo区域（如果有对象的年 龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果ServicorTo不 够位置了就放到老年区）； 2：清空eden、servicorFrom 然后，清空Eden和ServicorFrom中的对象； 3：ServicorTo 和 ServicorFrom 互换 最后，ServicorTo和ServicorFrom互换，原ServicorTo成为下一次GC时的ServicorFrom 区。\n2.3.2. 老年代 #\r主要存放应用程序中生命周期长的内存对象。 老年代的对象比较稳定，所以MajorGC不会频繁执行。在进行MajorGC前一般都先进行 了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足 够大的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC进行垃圾回收腾出空间。 MajorGC 采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没 有标记的对象。MajorGC的耗时比较长，因为要扫描再回收。MajorGC会产生内存碎片，为了减 少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的 时候，就会抛出OOM（Out of Memory）异常。\n2.3.3. 永久代 #\r指内存的永久保存区域，主要存放Class 和 Meta（元数据）的信息,Class 在被加载的时候被 放入永久区域，它和和存放实例的区域不同,GC不会在主程序运行期对永久区域进行清理。所以这 也导致了永久代的区域会随着加载的Class的增多而胀满，最终抛出OOM异常。\n2.4. 垃圾回收与算法 #\r2.4.1. 如何确定垃圾 #\r2.4.1.1.引用计数法 #\r在 Java 中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单 的办法是通过引用计数来判断一个对象是否可以回收。简单说，即一个对象如果没有任何与之关 联的引用，即他们的引用计数都不为0，则说明对象不太可能再被用到，那么这个对象就是可回收 对象。\n2.4.1.2.可达性分析 #\r为了解决引用计数法的循环引用问题，Java 使用了可达性分析的方法。通过一系列的“GC roots” 对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。\n2.4.2. 标记清除算法（Mark-Sweep） #\r最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清 除阶段回收被标记的对象所占用的空间。\n2.4.3. 复制算法（copying） #\r为了解决Mark-Sweep算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小 的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用 的内存清掉，\n标记整理算法(Mark-Compact) #\r结合了以上两个算法，为了避免缺陷而提出。标记阶段和Mark-Sweep算法相同，标记后不是清 理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。\n2.4.5. 分代收集算法 #\r分代收集法是目前大部分JVM所采用的方法，其核心思想是根据对象存活的不同生命周期将内存 划分为不同的域，一般情况下将GC堆划分为老生代(Tenured/Old Generation)和新生代(Young Generation)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃 圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。\n2.4.5.1. #\r新生代与复制算法\n目前大部分JVM的GC对于新生代都采取Copying算法，因为新生代中每次垃圾回收都要 回收大部分对象，即要复制的操作比较少，但通常并不是按照1：1来划分新生代。一般将新生代 划分为一块较大的Eden空间和两个较小的Survivor空间(From Space, To Space)，每次使用 Eden 空间和其中的一块Survivor空间，当进行回收时，将该两块空间中还存活的对象复制到另 一块Survivor空间中。\n2.4.5.2. #\r老年代与标记复制算法 而老年代因为每次只回收少量对象，因而采用Mark-Compact算法。\nJAVA虚拟机提到过的处于方法区的永生代(Permanet Generation)，它用来存储class类， 常量，方法描述等。对永生代的回收主要包括废弃常量和无用的类。 对象的内存分配主要在新生代的Eden Space和Survivor Space的From Space(Survivor目 前存放对象的那一块)，少数情况会直接分配到老生代。 当新生代的Eden Space和From Space空间不足时就会发生一次GC，进行GC后，Eden Space 和From Space区的存活对象会被挪到To Space，然后将Eden Space和From Space 进行清理。 如果To Space无法足够存储某个对象，则将这个对象存储到老生代。 在进行GC后，使用的便是Eden Space和To Space了，如此反复循环。 当对象在Survivor区躲过一次GC后，其年龄就会+1。默认情况下年龄到达15的对象会被 移到老生代中。 2.5. JAVA 四中引用类型 #\r2.5.1. 强引用 #\r在 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引 用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即 使该对象以后永远都不会被用到JVM也不会回收。因此强引用是造成Java内存泄漏的主要原因之 一。\n2.5.2. 软引用 #\r软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它 不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。\n2.5.3. 弱引用 #\r弱引用需要用WeakReference类来实现，它比软引用的生存期更短，对于只有弱引用的对象 来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，总会回收该对象占用的内存。\n2.5.3. 弱引用 #\r弱引用需要用WeakReference类来实现，它比软引用的生存期更短，对于只有弱引用的对象 来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，总会回收该对象占用的内存。\n2.5.3. 弱引用 #\r弱引用需要用WeakReference类来实现，它比软引用的生存期更短，对于只有弱引用的对象 来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，总会回收该对象占用的内存。\n2.6. GC 分代收集算法 VS 分区收集算法 #\r2.6.1. 分代收集算法 #\r当前主流VM垃圾收集都采用”分代收集”(Generational Collection)算法, 这种算法会根据 对象存活周期的不同将内存划分为几块, 如JVM中的 新生代、老年代、永久代，这样就可以根据 各年代特点分别采用最适当的GC算法\n2.6.1.2. #\r在老年代-标记整理算法 因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清理”或“标 记—整理”算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存.\n2.6.2. 分区收集算法 #\r分区算法则将整个堆空间划分为连续的不同小区间, 每个小区间独立使用, 独立回收. 这样做的 好处是可以控制一次回收多少个小区间 , 根据目标停顿时间, 每次合理地回收若干个小区间(而不是 整个堆), 从而减少一次GC所产生的停顿。\n","date":"0001-01-01","externalUrl":null,"permalink":"/interview/jvm/","section":"Interviews","summary":"JVM # 1.概念： # JVM是可运行Java代码的假想计算机，包括","title":"JVM知识点","type":"interview"},{"content":"\rmysql #\r慢查询 #\r聚合查询 多表查询 表数据量过大查询 深度分页查询 表象：页面加载过慢、接口压测响应时间过长（超过1s）\n如何定位慢查询? 方案二：MySQL自带慢日志 慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志 如果要开启慢查询日志，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息\n如何分析一个SQL语句执行很慢 可以采用EXPLAIN 或者DESC命令获取MySQL 如何执行SELECT 语句的信息 MYSQL支持的存储引擎 #\r存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的 ，所以存储引擎也可被称为表类型。 索引 #\r索引（index）是帮助MySQL高效获取数据的数据结构(有序)；提高数据检索的效率，降低数据库的IO成本（不需要全表扫描） ； 通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗\nB树： B+树： B树与B+树对比: ①：磁盘读写代价B+树更低；\n②：查询效率B+树更加稳定；\n③：B+树便于扫库和区间查询\n1.1聚集索引vs聚簇索引 #\r1.聚簇索引（聚集索引）：数据与索引放到一块，B+树的叶子节点保存了整行数据，有且只有一个\n2.非聚簇索引（二级索引）：数据与索引分开存储，B+树的叶子节点保存对应的主键，可以有多个\n1.2回表查询 #\r通过二级索引找到对应的主键值，到聚集索引中查找整行数据，这个过程就是回表查询\n1.3覆盖索引 #\r覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到\n如何对MYSQL超大分页处理？ #\r通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化\n","date":"0001-01-01","externalUrl":null,"permalink":"/interview/mysql/","section":"Interviews","summary":"mysql # 慢查询 # 聚合查询 多表查询 表数据量过大查询 深度分页查询 表象","title":"mysql面试知识点","type":"interview"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/project/","section":"Projects","summary":"","title":"Projects","type":"project"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"\r二叉树理论基础篇 #\r递归查找 #\r递归算法的三个要素\n1.确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。\n2.确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。\n3.确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。\n前序遍历 #\r1.确定递归函数的参数和返回值：因为要打印出前序遍历节点的数值，所以参数里需要传入vector来放节点的数值，除了这一点就不需要再处理什么数据了也不需要有返回值，所以递归函数返回类型就是void，代码如下：\nvoid traversal(TreeNode* cur, vector\u0026lt;int\u0026gt;\u0026amp; vec); 2.确定终止条件：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要结束了，所以如果当前遍历的这个节点是空，就直接return，代码如下：\nif (cur == NULL) return; 3.确定单层递归的逻辑：前序遍历是中左右的顺序，所以在单层递归的逻辑，是要先取中节点的数值，代码如下：\nvec.push_back(cur-\u0026gt;val); // 中 traversal(cur-\u0026gt;left, vec); // 左 traversal(cur-\u0026gt;right, vec); // 右 其他语言版本 #\r// 前序遍历·递归·LC144_二叉树的前序遍历 class Solution { public List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;Integer\u0026gt;(); preorder(root, result); return result; } public void preorder(TreeNode root, List\u0026lt;Integer\u0026gt; result) { if (root == null) { return; } result.add(root.val); preorder(root.left, result); preorder(root.right, result); } } // 中序遍历·递归·LC94_二叉树的中序遍历 class Solution { public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); inorder(root, res); return res; } void inorder(TreeNode root, List\u0026lt;Integer\u0026gt; list) { if (root == null) { return; } inorder(root.left, list); list.add(root.val); // 注意这一句 inorder(root.right, list); } } // 后序遍历·递归·LC145_二叉树的后序遍历 class Solution { public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); postorder(root, res); return res; } void postorder(TreeNode root, List\u0026lt;Integer\u0026gt; list) { if (root == null) { return; } postorder(root.left, list); postorder(root.right, list); list.add(root.val); // 注意这一句 } } ","date":"0001-01-01","externalUrl":null,"permalink":"/algorithm/tree/","section":"Algorithms","summary":"二叉树理论基础篇 # 递归查找 # 递归算法的三个要素 1.确定递归函","title":"二叉树","type":"algorithm"},{"content":"\r数组 #\r二分查找 #\r第一种写法：target在[left,right]区间\nclass solution{ public int search(int[] nums,int target) { if(target \u0026lt; nums[0] || target\u0026gt; nums[nums.length-1]){ return -1; } int left=0,right= nums.length-1; while(left \u0026lt;= right){ int middle=left+((right-left)\u0026gt;\u0026gt;1); if(nums[middle]==target){ return middle; } else if(nums[middle]\u0026gt;target){ right=middle-1; } else (nums[middle]\u0026lt;target) { left=middle+1; } } return -1; } } ","date":"0001-01-01","externalUrl":null,"permalink":"/algorithm/mid/","section":"Algorithms","summary":"数组 # 二分查找 # 第一种写法：target在[left,rig","title":"二分查找","type":"algorithm"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/","section":"欢迎来到 JohnnyBlog 的个人博客","summary":"","title":"欢迎来到 JohnnyBlog 的个人博客","type":"page"},{"content":"\r链表 #\r基础知识 #\r链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。 链表的入口节点称为链表的头结点也就是head。 1.链表的类型 #\r1.1单链表 #\r单链表中的指针域只能指向节点的下一个节点。\n1.2双链表 #\r双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。 双链表 既可以向前查询也可以向后查询。 1.3循环链表 #\r循环链表，顾名思义，就是链表首尾相连。 循环链表可以用来解决约瑟夫环问题。\n2.链表的存储方式 #\r数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。 链表是通过指针域的指针链接在内存中各个节点。 所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。\n3.链表的定义(JAVA) #\rpublic class ListNode { // 结点的值 int val; // 下一个结点 ListNode next; // 节点的构造函数(无参) public ListNode() { } // 节点的构造函数(有一个参数) public ListNode(int val) { this.val = val; } // 节点的构造函数(有两个参数) public ListNode(int val, ListNode next) { this.val = val; this.next = next; } } ","date":"0001-01-01","externalUrl":null,"permalink":"/algorithm/linkedlist/","section":"Algorithms","summary":"链表 # 基础知识 # 链表是一种通过指针串联在一起的线性结构，每一","title":"链表","type":"algorithm"},{"content":"\r栈与队列理论基础 #\r用栈实现队列 #\rclass MyQueue { Stack\u0026lt;Integer\u0026gt; stackIn; Stack\u0026lt;Integer\u0026gt; stackOut; /** Initialize your data structure here. */ public MyQueue() { stackIn = new Stack\u0026lt;\u0026gt;(); // 负责进栈 stackOut = new Stack\u0026lt;\u0026gt;(); // 负责出栈 } /** Push element x to the back of queue. */ public void push(int x) { stackIn.push(x); } /** Removes the element from in front of queue and returns that element. */ public int pop() { dumpstackIn(); return stackOut.pop(); } /** Get the front element. */ public int peek() { dumpstackIn(); return stackOut.peek(); } /** Returns whether the queue is empty. */ public boolean empty() { return stackIn.isEmpty() \u0026amp;\u0026amp; stackOut.isEmpty(); } // 如果stackOut为空，那么将stackIn中的元素全部放到stackOut中 private void dumpstackIn(){ if (!stackOut.isEmpty()) return; while (!stackIn.isEmpty()){ stackOut.push(stackIn.pop()); } } } 用队列实现栈 #\r队列是先进先出的规则，把一个队列中的数据导入另一个队列中，数据的顺序并没有变，并没有变成先进后出的顺序。\n所以用栈实现队列， 和用队列实现栈的思路还是不一样的，这取决于这两个数据结构的性质。\n但是依然还是要用两个队列来模拟栈，只不过没有输入和输出的关系，而是另一个队列完全用来备份的！\n如下面动画所示，用两个队列que1和que2实现队列的功能，que2其实完全就是一个备份的作用，把que1最后面的元素以外的元素都备份到que2，然后弹出最后面的元素，再把其他元素从que2导回que1。\n使用两个queue实习栈 #\rclass MyStack { Queue\u0026lt;Integer\u0026gt; queue1; // 和栈中保持一样元素的队列 Queue\u0026lt;Integer\u0026gt; queue2; // 辅助队列 /** Initialize your data structure here. */ public MyStack() { queue1 = new LinkedList\u0026lt;\u0026gt;(); queue2 = new LinkedList\u0026lt;\u0026gt;(); } /** Push element x onto stack. */ public void push(int x) { queue2.offer(x); // 先放在辅助队列中 while (!queue1.isEmpty()){ queue2.offer(queue1.poll()); } Queue\u0026lt;Integer\u0026gt; queueTemp; queueTemp = queue1; queue1 = queue2; queue2 = queueTemp; // 最后交换queue1和queue2，将元素都放到queue1中 } /** Removes the element on top of the stack and returns that element. */ public int pop() { return queue1.poll(); // 因为queue1中的元素和栈中的保持一致，所以这个和下面两个的操作只看queue1即可 } /** Get the top element. */ public int top() { return queue1.peek(); } /** Returns whether the stack is empty. */ public boolean empty() { return queue1.isEmpty(); } } 有效的括号 #\r","date":"0001-01-01","externalUrl":null,"permalink":"/algorithm/stack/","section":"Algorithms","summary":"栈与队列理论基础 # 用栈实现队列 # class MyQueue { Stack\u0026lt;Integer\u0026gt; stackIn; Stack\u0026lt;Integer\u0026gt; stackOut; /** Initialize your data structure here. */","title":"栈","type":"algorithm"}]