


[{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/zh-cn/all/","section":"欢迎来到 JohnnyBlog 的个人博客","summary":"","title":"","type":"page"},{"content":"友链\n","date":"0001-01-01","externalUrl":null,"permalink":"/zh-cn/friend/","section":"欢迎来到 JohnnyBlog 的个人博客","summary":"友链","title":"","type":"page"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/algorithm/","section":"Algorithms","summary":"","title":"Algorithms","type":"algorithm"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"\r数组 #\r二分查找 #\r第一种写法：target在[left,right]区间\nclass solution{ public int search(int[] nums,int target) { if(target \u0026lt; nums[0] || target\u0026gt; nums[nums.length-1]){ return -1; } int left=0,right= nums.length-1; while(left \u0026lt;= right){ int middle=left+((right-left)\u0026gt;\u0026gt;1); if(nums[middle]==target){ return middle; } else if(nums[middle]\u0026gt;target){ right=middle-1; } else (nums[middle]\u0026lt;target) { left=middle+1; } } return -1; } } ","date":"1 January 0001","externalUrl":null,"permalink":"/algorithm/hash/","section":"Algorithms","summary":"数组 # 二分查找 # 第一种写法：target在[left,rig","title":"Binary Search","type":"algorithm"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/","section":"Welcome to Blowfish! 🎉","summary":"","title":"Welcome to Blowfish! 🎉","type":"page"},{"content":"\r数组 #\r二分查找 #\r第一种写法：target在[left,right]区间\nclass solution{ public int search(int[] nums,int target) { if(target \u0026lt; nums[0] || target\u0026gt; nums[nums.length-1]){ return -1; } int left=0,right= nums.length-1; while(left \u0026lt;= right){ int middle=left+((right-left)\u0026gt;\u0026gt;1); if(nums[middle]==target){ return middle; } else if(nums[middle]\u0026gt;target){ right=middle-1; } else (nums[middle]\u0026lt;target) { left=middle+1; } } return -1; } } ","date":"0001-01-01","externalUrl":null,"permalink":"/zh-cn/algorithm/mid/","section":"Algorithms","summary":"数组 # 二分查找 # 第一种写法：target在[left,rig","title":"哈希算法","type":"algorithm"}]