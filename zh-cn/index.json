


[{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/zh-cn/all/","section":"欢迎来到 JohnnyBlog 的个人博客","summary":"","title":"","type":"page"},{"content":"友链\n","date":"0001-01-01","externalUrl":null,"permalink":"/zh-cn/friend/","section":"欢迎来到 JohnnyBlog 的个人博客","summary":"友链","title":"","type":"page"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/zh-cn/algorithm/","section":"Algorithms","summary":"","title":"Algorithms","type":"algorithm"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/zh-cn/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/zh-cn/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/zh-cn/interview/","section":"Interviews","summary":"","title":"Interviews","type":"interview"},{"content":"\rmysql #\rMYSQL支持的存储引擎 #\r存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的 ，所以存储引擎也可被称为表类型。 索引 #\r索引（index）是帮助MySQL高效获取数据的数据结构(有序)；提高数据检索的效率，降低数据库的IO成本（不需要全表扫描） ； 通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗\nB树： B+树： B树与B+树对比: ①：磁盘读写代价B+树更低；\n②：查询效率B+树更加稳定；\n③：B+树便于扫库和区间查询\n1.1聚集索引vs聚簇索引 #\r1.聚簇索引（聚集索引）：数据与索引放到一块，B+树的叶子节点保存了整行数据，有且只有一个\n2.非聚簇索引（二级索引）：数据与索引分开存储，B+树的叶子节点保存对应的主键，可以有多个\n1.2回表查询 #\r通过二级索引找到对应的主键值，到聚集索引中查找整行数据，这个过程就是回表查询\n1.3覆盖索引 #\r覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到\n如何对MYSQL超大分页处理？ #\r通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化\n","date":"0001-01-01","externalUrl":null,"permalink":"/zh-cn/interview/mysql/mysqlinterview/","section":"Interviews","summary":"mysql # MYSQL支持的存储引擎 # 存储引擎就是存储数据、建立索引","title":"mysql面试知识点","type":"interview"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/zh-cn/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/zh-cn/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"\r数组 #\r二分查找 #\r第一种写法：target在[left,right]区间\nclass solution{ public int search(int[] nums,int target) { if(target \u0026lt; nums[0] || target\u0026gt; nums[nums.length-1]){ return -1; } int left=0,right= nums.length-1; while(left \u0026lt;= right){ int middle=left+((right-left)\u0026gt;\u0026gt;1); if(nums[middle]==target){ return middle; } else if(nums[middle]\u0026gt;target){ right=middle-1; } else (nums[middle]\u0026lt;target) { left=middle+1; } } return -1; } } ","date":"0001-01-01","externalUrl":null,"permalink":"/zh-cn/algorithm/hash/","section":"Algorithms","summary":"数组 # 二分查找 # 第一种写法：target在[left,rig","title":"二分查找","type":"algorithm"},{"content":"\r数组 #\r二分查找 #\r第一种写法：target在[left,right]区间\nclass solution{ public int search(int[] nums,int target) { if(target \u0026lt; nums[0] || target\u0026gt; nums[nums.length-1]){ return -1; } int left=0,right= nums.length-1; while(left \u0026lt;= right){ int middle=left+((right-left)\u0026gt;\u0026gt;1); if(nums[middle]==target){ return middle; } else if(nums[middle]\u0026gt;target){ right=middle-1; } else (nums[middle]\u0026lt;target) { left=middle+1; } } return -1; } } ","date":"0001-01-01","externalUrl":null,"permalink":"/zh-cn/algorithm/mid/","section":"Algorithms","summary":"数组 # 二分查找 # 第一种写法：target在[left,rig","title":"哈希算法","type":"algorithm"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/zh-cn/","section":"欢迎来到 JohnnyBlog 的个人博客","summary":"","title":"欢迎来到 JohnnyBlog 的个人博客","type":"page"}]