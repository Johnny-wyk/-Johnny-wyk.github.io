


[{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/zh-cn/all/","section":"欢迎来到 JohnnyBlog 的个人博客","summary":"","title":"","type":"page"},{"content":"友链\n","date":"0001-01-01","externalUrl":null,"permalink":"/zh-cn/friend/","section":"欢迎来到 JohnnyBlog 的个人博客","summary":"友链","title":"","type":"page"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/zh-cn/algorithm/","section":"Algorithms","summary":"","title":"Algorithms","type":"algorithm"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/zh-cn/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/zh-cn/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/zh-cn/interview/","section":"Interviews","summary":"","title":"Interviews","type":"interview"},{"content":"\rJVM #\r1.概念： #\rJVM是可运行Java代码的假想计算机，包括一套字节码指令集、一组寄存器、一个栈、 一个垃圾回收，堆和一个存储方法域。JVM是运行在操作系统之上的，它与硬件没有直接 的交互\n① Java源文件—-\u0026gt;编译器—-\u0026gt;字节码文件\n② 字节码文件—-\u0026gt;JVM—-\u0026gt;机器码\n2.线程 #\r2.1当线程本地存储、缓冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程。 #\rJava 线程结束，原生线程随之被回收。操作系统负责调度所有线程，并把它们分配到任何可用的 CPU 上。当原生线程初始化完毕，就会调用 Java 线程的 run() 方法。当线程结束时，会释放原生线程和 Java 线程的所有资源。\nHotspot JVM 后台运行的系统线程主要有下面几个： 2.2. JVM 内存区域 #\r线程私有数据区域(ThreadLocal)生命周期与线程相同, 依赖用户线程的启动/结束 而 创建/销毁(在Hotspot VM 内, 每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的存/否跟随本地线程的 生/死对应)。 线程共享区域(ThreadShared)随虚拟机的启动/关闭而创建/销毁。 直接内存并不是JVM运行时数据区的一部分, 但也会被频繁的使用: 在JDK 1.4引入的NIO提 供了基于Channel 与 Buffer 的 IO 方式, 它可以使用 Native 函数库直接分配堆外内存, 然后使用 DirectByteBuffer 对象作为这块内存的引用进行操作(详见: Java I/O 扩展), 这样就避免了在 Java 堆和Native堆中来回复制数据, 因此在一些场景中可以显著提高性能。\n2.2.1. 程序计数器PC(线程私有) #\r一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的 程序计数器，这类内存也称为“线程私有”的内存。\n2.2.2. 虚拟机栈(线程私有) #\r是描述java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame） 用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成 的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。\n2.2.3. 本地方法区(线程私有) #\r本地方法区和Java Stack作用类似, 区别是虚拟机栈为执行Java方法服务, 而本地方法栈则为 Native 方法服务\n2.2.4. 堆（Heap-线程共享）-运行时数据区 #\r是被线程共享的一块内存区域，创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行 垃圾收集的最重要的内存区域。\n2.2.5. 方法区/永久代（线程共享） #\r用于存储被 JVM 加载的类信息、常量、静 态变量、即时编译器编译后的代码等数据. HotSpot VM把GC分代收集扩展至方法区, 即使用Java 堆的永久代来实现方法区.\n运行时常量池（Runtime Constant Pool）是方法区的一部分。用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加 载后存放到方法区的运行时常量池中。\n2.3. JVM 运行时内存 #\rJava 堆从GC的角度还可以细分为: 新生代(Eden区、From Survivor区和To Survivor区)和老年 代。\n2.3.1. 新生代 #\r是用来存放新生的对象。一般占据堆的1/3空间。由于频繁创建对象，所以新生代会频繁触发 MinorGC 进行垃圾回收。新生代又分为 Eden区、ServivorFrom、ServivorTo三个区。\n2.3.1.1.Eden区 #\rJava新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老 年代）。当Eden区内存不够的时候就会触发MinorGC，对新生代区进行 一次垃圾回收。\n2.3.1.2.ServivorFrom #\r上一次GC的幸存者，作为这一次GC的被扫描者。\n2.3.1.3.ServivorTo #\r保留了一次MinorGC过程中的幸存者。\n2.3.1.4.MinorGC的过程（复制-\u0026gt;清空-\u0026gt;互换） #\rMinorGC采用复制算法。 1：eden、servicorFrom 复制到 ServicorTo，年龄+1 首先，把Eden和ServivorFrom区域中存活的对象复制到ServicorTo区域（如果有对象的年 龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果ServicorTo不 够位置了就放到老年区）； 2：清空eden、servicorFrom 然后，清空Eden和ServicorFrom中的对象； 3：ServicorTo 和 ServicorFrom 互换 最后，ServicorTo和ServicorFrom互换，原ServicorTo成为下一次GC时的ServicorFrom 区。\n2.3.2. 老年代 #\r主要存放应用程序中生命周期长的内存对象。 老年代的对象比较稳定，所以MajorGC不会频繁执行。在进行MajorGC前一般都先进行 了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足 够大的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC进行垃圾回收腾出空间。 MajorGC 采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没 有标记的对象。MajorGC的耗时比较长，因为要扫描再回收。MajorGC会产生内存碎片，为了减 少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的 时候，就会抛出OOM（Out of Memory）异常。\n2.3.3. 永久代 #\r指内存的永久保存区域，主要存放Class 和 Meta（元数据）的信息,Class 在被加载的时候被 放入永久区域，它和和存放实例的区域不同,GC不会在主程序运行期对永久区域进行清理。所以这 也导致了永久代的区域会随着加载的Class的增多而胀满，最终抛出OOM异常。\n2.4. 垃圾回收与算法 #\r2.4.1. 如何确定垃圾 #\r2.4.1.1.引用计数法 #\r在 Java 中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单 的办法是通过引用计数来判断一个对象是否可以回收。简单说，即一个对象如果没有任何与之关 联的引用，即他们的引用计数都不为0，则说明对象不太可能再被用到，那么这个对象就是可回收 对象。\n2.4.1.2.可达性分析 #\r为了解决引用计数法的循环引用问题，Java 使用了可达性分析的方法。通过一系列的“GC roots” 对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。\n2.4.2. 标记清除算法（Mark-Sweep） #\r最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清 除阶段回收被标记的对象所占用的空间。\n2.4.3. 复制算法（copying） #\r为了解决Mark-Sweep算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小 的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用 的内存清掉，\n标记整理算法(Mark-Compact) #\r结合了以上两个算法，为了避免缺陷而提出。标记阶段和Mark-Sweep算法相同，标记后不是清 理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。\n","date":"0001-01-01","externalUrl":null,"permalink":"/zh-cn/interview/jvm/jvminterview/","section":"Interviews","summary":"JVM # 1.概念： # JVM是可运行Java代码的假想计算机，包括","title":"JVM知识点","type":"interview"},{"content":"\rmysql #\rMYSQL支持的存储引擎 #\r存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的 ，所以存储引擎也可被称为表类型。 索引 #\r索引（index）是帮助MySQL高效获取数据的数据结构(有序)；提高数据检索的效率，降低数据库的IO成本（不需要全表扫描） ； 通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗\nB树： B+树： B树与B+树对比: ①：磁盘读写代价B+树更低；\n②：查询效率B+树更加稳定；\n③：B+树便于扫库和区间查询\n1.1聚集索引vs聚簇索引 #\r1.聚簇索引（聚集索引）：数据与索引放到一块，B+树的叶子节点保存了整行数据，有且只有一个\n2.非聚簇索引（二级索引）：数据与索引分开存储，B+树的叶子节点保存对应的主键，可以有多个\n1.2回表查询 #\r通过二级索引找到对应的主键值，到聚集索引中查找整行数据，这个过程就是回表查询\n1.3覆盖索引 #\r覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到\n如何对MYSQL超大分页处理？ #\r通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化\n","date":"0001-01-01","externalUrl":null,"permalink":"/zh-cn/interview/mysql/mysqlinterview/","section":"Interviews","summary":"mysql # MYSQL支持的存储引擎 # 存储引擎就是存储数据、建立索引","title":"mysql面试知识点","type":"interview"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/zh-cn/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/zh-cn/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"\r数组 #\r二分查找 #\r第一种写法：target在[left,right]区间\nclass solution{ public int search(int[] nums,int target) { if(target \u0026lt; nums[0] || target\u0026gt; nums[nums.length-1]){ return -1; } int left=0,right= nums.length-1; while(left \u0026lt;= right){ int middle=left+((right-left)\u0026gt;\u0026gt;1); if(nums[middle]==target){ return middle; } else if(nums[middle]\u0026gt;target){ right=middle-1; } else (nums[middle]\u0026lt;target) { left=middle+1; } } return -1; } } ","date":"0001-01-01","externalUrl":null,"permalink":"/zh-cn/algorithm/hash/","section":"Algorithms","summary":"数组 # 二分查找 # 第一种写法：target在[left,rig","title":"二分查找","type":"algorithm"},{"content":"\r数组 #\r二分查找 #\r第一种写法：target在[left,right]区间\nclass solution{ public int search(int[] nums,int target) { if(target \u0026lt; nums[0] || target\u0026gt; nums[nums.length-1]){ return -1; } int left=0,right= nums.length-1; while(left \u0026lt;= right){ int middle=left+((right-left)\u0026gt;\u0026gt;1); if(nums[middle]==target){ return middle; } else if(nums[middle]\u0026gt;target){ right=middle-1; } else (nums[middle]\u0026lt;target) { left=middle+1; } } return -1; } } ","date":"0001-01-01","externalUrl":null,"permalink":"/zh-cn/algorithm/mid/","section":"Algorithms","summary":"数组 # 二分查找 # 第一种写法：target在[left,rig","title":"哈希算法","type":"algorithm"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/zh-cn/","section":"欢迎来到 JohnnyBlog 的个人博客","summary":"","title":"欢迎来到 JohnnyBlog 的个人博客","type":"page"}]